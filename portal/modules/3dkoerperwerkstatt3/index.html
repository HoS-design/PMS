<!DOCTYPE html>
<html lang="de">
<head>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/app.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K√∂rperWerkstatt 3D Komposit ‚Ä¢ HoS</title>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
            }
        }
    </script>

    <style>
        :root {
            /* -- HoS Light Theme -- */
            --bg: #f2f4f7;
            --surface: #ffffff;
            --ink: #1e293b;
            --muted: #64748b;
            --line: #e2e8f0;
            --accent: #3b82f6; 
            --accent-soft: #eff6ff;
            --success: #10b981;
            --danger: #ef4444;
            --radius: 16px;
            --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.08), 0 2px 4px -1px rgba(0,0,0,0.04);
            --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            font-family: var(--font-sans);
            background-color: var(--bg);
            color: var(--ink);
            display: flex;
            flex-direction: column;
        }

        #app-header {
            flex: 0 0 auto;
            padding: 12px 24px;
            background: var(--surface);
            border-bottom: 1px solid var(--line);
            display: flex; align-items: center; justify-content: space-between;
            z-index: 10;
            box-shadow: var(--shadow-md);
        }

        .brand-row { display:flex; align-items:center; gap:12px; }
        .logo-img { width:44px; height:44px; object-fit:contain; border-radius:10px; background:var(--bg); border:1px solid var(--line); }
        .badge-main {
            display:inline-flex; align-items:center;
            background: var(--accent); color: white;
            font-size:10px; font-weight:700; text-transform:uppercase; letter-spacing:0.5px;
            padding:3px 8px; border-radius:99px; margin-bottom:2px;
        }
        .brand-title h1 { margin:0; font-size:18px; font-weight:800; letter-spacing:-0.5px; color: var(--ink); }
        .brand-title p { margin:0; font-size:12px; color: var(--muted); }

        .header-actions .btn { padding: 8px 16px; font-size: 13px; text-decoration: none; }

        #app-container { display: flex; flex: 1 1 auto; overflow: hidden; height: 100%; }

        #controls-sidebar {
            width: 420px;
            background: var(--surface);
            border-right: 1px solid var(--line);
            display: flex; flex-direction: column;
            overflow-y: auto;
            z-index: 5;
            flex-shrink: 0;
        }

        .sidebar-section { padding: 20px; border-bottom: 1px solid var(--line); }
        .section-title {
            font-size: 12px; text-transform: uppercase; font-weight: 700; color: var(--muted);
            margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center;
        }

        #canvas-container { flex-grow: 1; position: relative; background: var(--bg); overflow: hidden; }
        #view { width: 100%; height: 100%; display: block; }

        .btn {
            background: var(--surface); border: 1px solid var(--line);
            color: var(--ink); padding: 10px 16px; border-radius: 10px;
            font-size: 14px; font-weight: 600; cursor: pointer;
            transition: all 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 6px;
        }
        .btn:hover { background: var(--bg); transform: translateY(-1px); }
        .btn.primary { background: var(--accent); color: white; border-color: var(--accent); }
        .btn.primary:hover { background: #2563eb; }
        .btn.good { background: #ecfdf5; color: #047857; border-color: #a7f3d0; }
        .btn.good:hover { background: #d1fae5; }
        .btn.bad { background: #fef2f2; color: #b91c1c; border-color: #fecaca; }
        .btn.bad:hover { background: #fee2e2; }
        
        .btn-group { display: flex; gap: 8px; margin-top: 12px; }
        .btn-group .btn { flex: 1; }

        input, select {
            width: 100%; padding: 10px; border: 1px solid var(--line);
            border-radius: 10px; font-size: 14px; background: var(--bg); color: var(--ink);
            outline: none; transition: border-color 0.2s;
        }
        input:focus, select:focus { border-color: var(--accent); background: white; }

        .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px; }
        label { display: block; font-size: 12px; font-weight: 600; color: var(--muted); margin-bottom: 4px; }

        .task-box {
            background: var(--accent-soft);
            border: 1px solid #bfdbfe;
            border-radius: 12px; padding: 16px; margin-bottom: 16px;
        }
        .task-text { font-size: 15px; font-weight: 600; color: #1e3a8a; margin-bottom: 12px; line-height: 1.4; }
        
        .status-msg {
            margin-top: 12px; padding: 10px; border-radius: 8px; font-size: 13px; line-height: 1.4;
            background: white; border: 1px dashed var(--line); color: var(--muted);
        }
        .status-msg.ok { background: #ecfdf5; border-color: #34d399; color: #065f46; }
        .status-msg.no { background: #fff1f2; border-color: #fda4af; color: #9f1239; }

        .sol-box {
            margin-top: 12px; padding: 12px; background: white; 
            border: 1px solid var(--line); border-radius: 8px;
            font-family: ui-monospace, monospace; font-size: 12px; display: none;
            white-space: pre-wrap; color: var(--ink); line-height: 1.5;
            max-height: 300px; overflow-y: auto;
        }
        .sol-step { margin-bottom: 8px; border-bottom: 1px dashed #eee; padding-bottom: 4px; }
        .sol-step:last-child { border: none; }
        .sol-hl { font-weight: bold; color: var(--accent); }

        .pill-nav { display: flex; gap: 8px; margin-bottom: 16px; background: var(--bg); padding: 4px; border-radius: 99px; width: fit-content; }
        .pill {
            padding: 6px 14px; border-radius: 99px; font-size: 12px; font-weight: 700; 
            color: var(--muted); cursor: pointer; user-select: none;
        }
        .pill.active { background: white; color: var(--accent); box-shadow: var(--shadow-sm); }

        .stat-row { display: flex; justify-content: space-between; font-size: 13px; margin-top: 8px; padding-top: 8px; border-top: 1px dashed var(--line); }
        .stat-val { font-weight: 700; color: var(--ink); font-feature-settings: "tnum"; }

        .canvas-overlay {
            position: absolute; top: 16px; left: 16px; pointer-events: none; display: flex; gap: 8px; flex-wrap: wrap;
        }
        .chip {
            background: rgba(255,255,255,0.9); backdrop-filter: blur(4px);
            padding: 6px 10px; border-radius: 8px; font-size: 12px; font-weight: 600;
            color: var(--muted); box-shadow: var(--shadow-sm); border: 1px solid rgba(0,0,0,0.05);
        }

        @media (max-width: 900px) {
            #app-container { flex-direction: column; }
            #controls-sidebar { width: 100%; height: 45%; border-right: none; border-bottom: 1px solid var(--line); }
            #canvas-container { height: 55%; }
        }
    </style>
</head>
<body>

    <header class="app-header">
        <div class="brand-row">
            <img src="/chatisthisreal.png" alt="Logo" class="logo-img" onerror="this.style.display='none'">
            <div class="brand-title">
                <div class="badge-main is-mathe">Mathe</div>
                <h1>K√∂rperWerkstatt 3D</h1>
            </div>
        </div>
        <div class="header-actions">
            <a href="/index.html" class="btn">üè† Startseite</a>
        </div>
    </header>

    <div id="app-container">
        <aside id="controls-sidebar">
            
            <div class="sidebar-section">
                <div class="section-title">Modus</div>
                <div class="pill-nav">
                    <div class="pill active" id="pillFree">üß© Freies Bauen</div>
                    <div class="pill" id="pillTask">üìù Aufgaben</div>
                </div>

                <div id="taskArea" style="display:none">
                    <div class="task-box">
                        <div class="section-title" style="margin-bottom:8px">Aktuelle Aufgabe</div>
                        <div class="task-text" id="taskText">Klicke auf "Neue Aufgabe"</div>
                        
                        <div class="pill-nav" style="background:rgba(255,255,255,0.5); margin-bottom:12px">
                            <div class="pill active" id="pillEasy">üôÇ Leicht</div>
                            <div class="pill" id="pillExpert">üß† Experte</div>
                        </div>

                        <div class="btn-group">
                            <button class="btn primary" id="newTask">üé≤ Neue Aufgabe</button>
                            <button class="btn good" id="checkTask">‚úÖ Pr√ºfen</button>
                        </div>
                        <div style="margin-top:8px; text-align:center;">
                            <button class="btn" id="toggleSol" style="font-size:12px; padding:6px 12px">üëÅÔ∏è L√∂sungsweg zeigen</button>
                        </div>
                        <div class="sol-box" id="solBox"></div>
                    </div>
                    <div class="status-msg" id="status">W√§hle eine Aufgabe oder baue frei.</div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Bauteile</div>
                <label>Form</label>
                <select id="shape" style="margin-bottom:12px">
                    <option value="box">Quader / W√ºrfel</option>
                    <option value="cylinder">Zylinder</option>
                    <option value="cone">Kegel</option>
                    <option value="pyramid">Pyramide (quadratisch)</option>
                </select>

                <div class="row">
                    <div>
                        <label id="labelA">Breite (a)</label>
                        <input id="a" type="number" min="0.2" step="0.1" value="2.0">
                    </div>
                    <div>
                        <label id="labelB">Tiefe (b)</label>
                        <input id="b" type="number" min="0.2" step="0.1" value="2.0">
                    </div>
                </div>
                <div class="row">
                    <div>
                        <label id="labelH">H√∂he (h)</label>
                        <input id="h" type="number" min="0.2" step="0.1" value="2.0">
                    </div>
                    <div>
                        <label>Segmente</label>
                        <input id="seg" type="number" min="8" step="1" value="32">
                    </div>
                </div>

                <div class="btn-group">
                    <button class="btn primary" id="add" style="width:100%">‚ûï Bauteil hinzuf√ºgen</button>
                </div>
                <div class="btn-group">
                    <button class="btn bad" id="remove" style="width:100%">üóëÔ∏è Auswahl l√∂schen</button>
                </div>
                
                <div style="margin-top:16px; font-size:12px; color:var(--muted); display:flex; align-items:center; gap:8px;">
                    <input type="checkbox" id="snap" checked style="width:auto; margin:0">
                    <label for="snap" style="margin:0; font-weight:400">Magnet-Snapping (Auto-Zentrierung)</label>
                </div>
            </div>

            <div class="sidebar-section" style="border-bottom:none">
                <div class="section-title">Info & Berechnung</div>
                <div class="stat-row">
                    <span>Ausgew√§hlt:</span>
                    <span class="stat-val" id="iSel">‚Äî</span>
                </div>
                <div class="stat-row">
                    <span>Gesamt-Volumen (V):</span>
                    <span class="stat-val" id="valV">‚Äî</span>
                </div>
                <div class="stat-row">
                    <span>Oberfl√§che (O):</span>
                    <span class="stat-val" id="valO">‚Äî</span>
                </div>
                <div style="font-size:11px; color:var(--muted); margin-top:8px; font-style:italic">
                    *O berechnet automatisch abz√ºglich der Kontaktfl√§chen.
                </div>
                <div class="btn-group" style="margin-top:12px">
                     <button class="btn" id="resetAll">üßº Alles l√∂schen</button>
                </div>
            </div>
        </aside>

        <main id="canvas-container">
            <div id="view"></div>
            <div class="canvas-overlay">
                <div class="chip">üñ±Ô∏è Links + Drag = Schieben</div>
                <div class="chip">üñ±Ô∏è Rechts + Drag = Heben</div>
                <div class="chip">‚å®Ô∏è Q / E = Kippen 90¬∞</div>
                <div class="chip">üß≤ Snap = Intelligent</div>
            </div>
        </main>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Error Handler ---
        window.onerror = function(msg, url, line) {
            if(msg.includes('ResizeObserver')) return true;
            console.error("App Error:", msg);
        };

        // --- Helpers ---
        const SNAP_DIST = 1.0; 
        const round1 = (x) => Math.round(x*10)/10;
        const fmt1 = (x) => (Math.round(x*100)/100).toFixed(2);
        const approx = (a,b,t=0.1)=>Math.abs(a-b)<=t;

        // --- UI Refs ---
        const mount = document.getElementById("view");
        const elShape = document.getElementById("shape");
        const elA = document.getElementById("a"), elB = document.getElementById("b"), elH = document.getElementById("h"), elSeg = document.getElementById("seg");
        const elSnap = document.getElementById("snap");
        const labelA = document.getElementById("labelA"), labelB = document.getElementById("labelB"), labelH = document.getElementById("labelH");
        
        const iSel = document.getElementById("iSel");
        const valV = document.getElementById("valV");
        const valO = document.getElementById("valO");
        
        const taskBox = document.getElementById("taskArea");
        const statusEl = document.getElementById("status");
        const solBox = document.getElementById("solBox");

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf2f4f7); 
        scene.fog = new THREE.Fog(0xf2f4f7, 20, 60);

        const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
        camera.position.set(8, 12, 12);

        const renderer = new THREE.WebGLRenderer({ antialias:true });
        renderer.setSize(800, 600);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.SoftShadowMap;
        mount.appendChild(renderer.domElement);

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xe2e8f0, 0.8);
        scene.add(hemiLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048; 
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.0005; 
        scene.add(dirLight);

        // Floor
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.ShadowMaterial({ opacity: 0.05 })
        );
        floor.rotation.x = -Math.PI/2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Grid
        const grid = new THREE.GridHelper(50, 50, 0xcbd5e1, 0xe2e8f0);
        scene.add(grid);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; 
        
        // App State
        const objects = [];
        let selected = null;
        let mode = "free";
        let difficulty = "easy";
        let currentTask = null;

        // Materials - FIX Z-FIGHTING
        const matDefault = new THREE.MeshStandardMaterial({ 
            color: 0x3b82f6, 
            roughness: 0.4, 
            metalness: 0.1, 
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: 1, 
            polygonOffsetUnits: 1
        });
        
        // NEU: Helles Cyan/T√ºrkis f√ºr Auswahl
        const matSel = new THREE.MeshStandardMaterial({ 
            color: 0x22d3ee, // Hellblau/Cyan
            roughness: 0.4, 
            metalness: 0.1, 
            emissive: 0x0e7490, // Dunkles Cyan leuchten
            emissiveIntensity: 0.3, 
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: 1, 
            polygonOffsetUnits: 1
        });
        
        // --- Drag Logic ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const planeH = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const planeV = new THREE.Plane(); 
        
        const intersectPoint = new THREE.Vector3();
        const dragOffset = new THREE.Vector3();
        let draggable = null;
        let isRightClick = false;

        renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('keydown', (e) => {
            if (!selected) return;
            const k = e.key.toLowerCase();
            let rotated = false;
            
            if (k === 'q') {
                selected.rotation.x += Math.PI / 2;
                rotated = true;
            }
            if (k === 'e') {
                selected.rotation.z += Math.PI / 2;
                rotated = true;
            }

            if(rotated) {
                fixFloorCollision(selected);
                updateCalc();
            }
        });

        function fixFloorCollision(mesh) {
            mesh.updateMatrixWorld();
            const box = new THREE.Box3().setFromObject(mesh);
            const bottomY = box.min.y;
            if(bottomY < 0) {
                mesh.position.y += -bottomY;
            }
        }

        function onPointerDown(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects, true); 

            if (intersects.length > 0) {
                let target = intersects[0].object;
                while(target.parent && !target.userData.shape) {
                    target = target.parent;
                }
                
                if (objects.includes(target)) {
                    if(event.button === 0 || event.button === 2) {
                        draggable = target;
                        controls.enabled = false; 
                        setSelected(draggable);
                        
                        isRightClick = (event.button === 2); 

                        if (isRightClick) {
                            const camDir = new THREE.Vector3();
                            camera.getWorldDirection(camDir);
                            camDir.y = 0; camDir.normalize();
                            planeV.setFromNormalAndCoplanarPoint(camDir, draggable.position);
                            if (raycaster.ray.intersectPlane(planeV, intersectPoint)) {
                                dragOffset.y = draggable.position.y - intersectPoint.y; 
                            }
                        } else {
                            planeH.constant = -draggable.position.y;
                            if (raycaster.ray.intersectPlane(planeH, intersectPoint)) {
                                dragOffset.copy(draggable.position).sub(intersectPoint);
                            }
                        }
                    }
                }
            } else {
                // Klick in Leere -> Deselect
                controls.enabled = true;
                if(selected) {
                    selected.material = matDefault.clone();
                    selected = null;
                    iSel.textContent = "‚Äî";
                }
            }
        }

        function onPointerMove(event) {
            if (!draggable) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            if (isRightClick) {
                if (raycaster.ray.intersectPlane(planeV, intersectPoint)) {
                    const newY = intersectPoint.y + dragOffset.y;
                    draggable.position.y = newY;
                    fixFloorCollision(draggable); 
                }
            } else {
                planeH.constant = -draggable.position.y;
                if (raycaster.ray.intersectPlane(planeH, intersectPoint)) {
                    draggable.position.copy(intersectPoint.add(dragOffset));
                    fixFloorCollision(draggable);
                }
            }
        }

        function onPointerUp(event) {
            if (draggable) {
                if(elSnap.checked) performSmartSnap(draggable);
                updateCalc();
                draggable = null;
            }
            controls.enabled = true; 
        }

        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerup', onPointerUp);

        // --- SMART SNAP (Stapel + Seite) ---
        function performSmartSnap(active) {
            let bestTarget = null;
            let bestPos = null;
            let minDist = Infinity;
            const SNAP_THRESH = 1.2;

            active.updateMatrixWorld();
            const aBox = new THREE.Box3().setFromObject(active);
            const aSize = new THREE.Vector3(); aBox.getSize(aSize);
            const aCenter = new THREE.Vector3(); aBox.getCenter(aCenter);

            for(const target of objects) {
                if(target === active) continue;

                target.updateMatrixWorld();
                const tBox = new THREE.Box3().setFromObject(target);
                const tSize = new THREE.Vector3(); tBox.getSize(tSize);
                const tCenter = new THREE.Vector3(); tBox.getCenter(tCenter);

                // 1. STAPELN (Priorit√§t)
                const distH = new THREE.Vector2(aCenter.x, aCenter.z).distanceTo(new THREE.Vector2(tCenter.x, tCenter.z));
                
                if(distH < Math.max(tSize.x, tSize.z)/2 + 0.8) {
                    const distV = Math.abs(aBox.min.y - tBox.max.y);
                    if(distV < SNAP_THRESH) {
                        if(distV < minDist) {
                            minDist = distV;
                            bestTarget = target;
                            bestPos = new THREE.Vector3(tCenter.x, tBox.max.y + aSize.y/2, tCenter.z);
                        }
                    }
                }

                // 2. SEITLICH (Side Snap)
                const distY = Math.abs(aBox.min.y - tBox.min.y);
                if(distY < 0.5) { 
                    const distZ = Math.abs(aCenter.z - tCenter.z);
                    if(distZ < 0.5) {
                        const dRight = Math.abs(aBox.min.x - tBox.max.x);
                        if(dRight < SNAP_THRESH && dRight < minDist) {
                            minDist = dRight;
                            bestTarget = target;
                            bestPos = new THREE.Vector3(tBox.max.x + aSize.x/2, tBox.min.y + aSize.y/2, tCenter.z);
                        }
                        const dLeft = Math.abs(aBox.max.x - tBox.min.x);
                        if(dLeft < SNAP_THRESH && dLeft < minDist) {
                            minDist = dLeft;
                            bestTarget = target;
                            bestPos = new THREE.Vector3(tBox.min.x - aSize.x/2, tBox.min.y + aSize.y/2, tCenter.z);
                        }
                    }

                    const distX = Math.abs(aCenter.x - tCenter.x);
                    if(distX < 0.5) {
                        const dFront = Math.abs(aBox.min.z - tBox.max.z);
                        if(dFront < SNAP_THRESH && dFront < minDist) {
                            minDist = dFront;
                            bestTarget = target;
                            bestPos = new THREE.Vector3(tCenter.x, tBox.min.y + aSize.y/2, tBox.max.z + aSize.z/2);
                        }
                        const dBack = Math.abs(aBox.max.z - tBox.min.z);
                        if(dBack < SNAP_THRESH && dBack < minDist) {
                            minDist = dBack;
                            bestTarget = target;
                            bestPos = new THREE.Vector3(tCenter.x, tBox.min.y + aSize.y/2, tBox.min.z - aSize.z/2);
                        }
                    }
                }
            }

            if(bestTarget && bestPos) {
                active.position.copy(bestPos);
                return true;
            }
            return false;
        }

        function updateBuilderLabels(){
            const s = elShape.value;
            if (s === "box"){
                labelA.textContent = "Breite (a)";
                labelB.textContent = "Tiefe (b)";
                elB.disabled = false; elSeg.disabled = true;
            } else if (s === "cylinder" || s === "cone"){
                labelA.textContent = "Radius (r)";
                labelB.textContent = "‚Äî";
                elB.disabled = true; elSeg.disabled = false;
            } else { 
                labelA.textContent = "Grundkante (a)";
                labelB.textContent = "‚Äî";
                elB.disabled = true; elSeg.disabled = true;
            }
        }
        elShape.addEventListener("change", updateBuilderLabels);
        updateBuilderLabels(); 

        function createMesh(cfg) {
            if(selected && !cfg.a && !cfg.r) {
                const p = selected.userData.params;
                let base = p.a || (p.r ? p.r*2 : 2);
                if(elShape.value.includes('cyl') || elShape.value.includes('cone')) {
                    elA.value = base / 2; 
                } else {
                    elA.value = base;     
                    elB.value = base;     
                }
            }

            const shape = cfg.shape || elShape.value;
            const a = cfg.a || parseFloat(elA.value);
            const b = cfg.b || parseFloat(elB.value);
            const h = cfg.h || parseFloat(elH.value);
            const seg = cfg.seg || parseInt(elSeg.value);

            let geo, label, params = {};
            
            if (shape === "box"){
                geo = new THREE.BoxGeometry(a, h, b);
                label = (approx(a,b) && approx(a,h)) ? "W√ºrfel" : "Quader";
                params = { a, b, h };
            } else if (shape === "cylinder"){
                geo = new THREE.CylinderGeometry(a, a, h, seg);
                label = "Zylinder";
                params = { r:a, h, seg };
            } else if (shape === "cone"){
                geo = new THREE.CylinderGeometry(0, a, h, seg);
                label = "Kegel";
                params = { r:a, h, seg };
            } else { 
                const r = (a / 2) * Math.sqrt(2); 
                geo = new THREE.CylinderGeometry(0, r, h, 4, 1);
                geo.rotateY(Math.PI / 4); 
                label = "Pyramide";
                params = { a, h };
            }

            const mesh = new THREE.Mesh(geo, matDefault.clone());
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.position.y = h/2 + 0.1;
            mesh.position.x = (Math.random()-0.5)*2;
            mesh.position.z = (Math.random()-0.5)*2;
            
            mesh.userData = { shape, label, params };
            
            const edges = new THREE.LineSegments(
                new THREE.EdgesGeometry(geo, 30), 
                new THREE.LineBasicMaterial({ color: 0xffffff, opacity:0.5, transparent:true })
            );
            mesh.add(edges);

            return mesh;
        }

        function addObj(mesh) {
            scene.add(mesh);
            objects.push(mesh);
            setSelected(mesh);
            updateCalc();
        }

        function setSelected(obj) {
            if(selected) selected.material = matDefault.clone();
            
            selected = obj;
            if(selected) {
                selected.material = matSel.clone();
                iSel.textContent = `${selected.userData.label}`;
            } else {
                iSel.textContent = "‚Äî";
            }
        }

        function formatCalc(mesh) {
            const p = mesh.userData.params;
            const s = mesh.userData.shape;
            let vText = "", oText = "";
            let v = 0, o = 0;

            if(s==='box') {
                v = p.a * p.b * p.h;
                o = 2*(p.a*p.b + p.a*p.h + p.b*p.h);
                vText = `V = ${p.a}¬∑${p.b}¬∑${p.h} = ${fmt1(v)}`;
                oText = `O = 2¬∑(${p.a}¬∑${p.b} + ${p.a}¬∑${p.h} + ${p.b}¬∑${p.h}) = ${fmt1(o)}`;
            } else if(s==='cylinder') {
                v = Math.PI * p.r**2 * p.h;
                o = 2*Math.PI*p.r*(p.r+p.h);
                vText = `V = œÄ¬∑${p.r}¬≤¬∑${p.h} ‚âà ${fmt1(v)}`;
                oText = `O = 2œÄ¬∑${p.r}¬∑(${p.r}+${p.h}) ‚âà ${fmt1(o)}`;
            } else if(s==='cone') {
                v = (Math.PI * p.r**2 * p.h)/3;
                const sl = Math.sqrt(p.r**2 + p.h**2);
                o = Math.PI*p.r*(p.r+sl);
                vText = `V = (œÄ¬∑${p.r}¬≤¬∑${p.h})/3 ‚âà ${fmt1(v)}`;
                oText = `O = œÄ¬∑${p.r}¬∑(${p.r}+${fmt1(sl)}) ‚âà ${fmt1(o)}`;
            } else if(s==='pyramid') {
                v = (p.a**2 * p.h)/3;
                const sl = Math.sqrt((p.a/2)**2 + p.h**2);
                o = p.a**2 + 2*p.a*sl;
                vText = `V = (${p.a}¬≤¬∑${p.h})/3 ‚âà ${fmt1(v)}`;
                oText = `O = ${p.a}¬≤ + 2¬∑${p.a}¬∑${fmt1(sl)} ‚âà ${fmt1(o)}`;
            }
            return { v, o, vText, oText, label: mesh.userData.label };
        }

        function updateCalc() {
            if(objects.length === 0) {
                valV.textContent = "‚Äî"; valO.textContent = "‚Äî"; return {V:0, O:0};
            }

            let V_total = 0, O_total = 0, contactArea = 0, stepsHTML = "";

            stepsHTML += "<div class='sol-step'><span class='sol-hl'>1. Einzelk√∂rper:</span></div>";
            objects.forEach((o, i) => {
                const res = formatCalc(o);
                V_total += res.v;
                O_total += res.o;
                stepsHTML += `<div class='sol-step'><b>${i+1}. ${res.label}:</b><br>${res.vText}<br>${res.oText}</div>`;
            });

            let contacts = [];
            for(let i=0; i<objects.length; i++) {
                for(let j=i+1; j<objects.length; j++) {
                    const area = getContactArea(objects[i], objects[j]);
                    if(area > 0) {
                        contactArea += area;
                        contacts.push(`${objects[i].userData.label} ‚Üî ${objects[j].userData.label}: A = ${fmt1(area)}`);
                    }
                }
            }

            if(contacts.length > 0) {
                stepsHTML += `<div class='sol-step'><span class='sol-hl'>2. Kontaktfl√§chen (werden 2x abgezogen):</span><br>${contacts.join('<br>')}</div>`;
            } else {
                stepsHTML += `<div class='sol-step'>Keine Kontaktfl√§chen gefunden.</div>`;
            }

            O_total -= 2 * contactArea;
            stepsHTML += `<div class='sol-step'><span class='sol-hl'>3. Ergebnis:</span><br>V_ges = Summe V = <b>${fmt1(V_total)}</b><br>O_ges = Summe O - 2¬∑Kontakt = <b>${fmt1(O_total)}</b></div>`;

            valV.textContent = fmt1(V_total);
            valO.textContent = fmt1(O_total);
            solBox.innerHTML = stepsHTML;
            
            return {V: V_total, O: O_total};
        }

        function getContactArea(m1, m2) {
            const p1 = m1.userData.params;
            const p2 = m2.userData.params;
            
            const box1 = new THREE.Box3().setFromObject(m1);
            const box2 = new THREE.Box3().setFromObject(m2);
            
            const xOverlap = Math.max(0, Math.min(box1.max.x, box2.max.x) - Math.max(box1.min.x, box2.min.x));
            const yOverlap = Math.max(0, Math.min(box1.max.y, box2.max.y) - Math.max(box1.min.y, box2.min.y));
            const zOverlap = Math.max(0, Math.min(box1.max.z, box2.max.z) - Math.max(box1.min.z, box2.min.z));
            
            const touchingY = (Math.abs(box1.max.y - box2.min.y) < 0.1) || (Math.abs(box2.max.y - box1.min.y) < 0.1);
            
            if(xOverlap > 0.1 && zOverlap > 0.1 && touchingY) {
                const getBaseArea = (m) => {
                    const pp = m.userData.params;
                    if(m.userData.shape.includes('cyl') || m.userData.shape.includes('cone')) return Math.PI * pp.r**2;
                    return pp.a * (pp.b || pp.a);
                };
                return Math.min(getBaseArea(m1), getBaseArea(m2));
            }
            return 0;
        }

        function generateTask(difficulty) {
            const baseSize = Math.floor(Math.random() * 3 + 2); 
            const r = baseSize / 2;
            const a = baseSize;
            
            const partsConfig = [];
            let shapes = [];
            let desc = "";

            if(difficulty === 'easy') {
                desc = "Leicht: Baue diese 2 Formen √ºbereinander.";
                const combos = [['box', 'pyramid'], ['cylinder', 'cone'], ['box', 'cylinder'], ['cylinder', 'box']];
                shapes = combos[Math.floor(Math.random() * combos.length)];
            } else {
                desc = "Experte: Kombiniere diese 3 Formen.";
                let last = Math.random() > 0.5 ? 'box' : 'cylinder';
                shapes.push(last);
                let mid = (last === 'box') ? 'cylinder' : 'box';
                shapes.push(mid);
                last = mid;
                const tops = ['cone', 'pyramid', 'box', 'cylinder'].filter(s => s !== last);
                shapes.push(tops[Math.floor(Math.random() * tops.length)]);
            }

            shapes.forEach(type => {
                const h = Math.floor(Math.random() * 3 + 2); 
                if(type === 'box') partsConfig.push({shape:'box', a:a, b:a, h:h});
                else if(type === 'pyramid') partsConfig.push({shape:'pyramid', a:a, h:h});
                else if(type === 'cylinder') partsConfig.push({shape:'cylinder', r:r, h:h});
                else if(type === 'cone') partsConfig.push({shape:'cone', r:r, h:h});
            });

            let simV = 0, simO = 0, simContact = 0;
            const simVol = (p) => {
                if(p.shape==='box') return p.a*p.b*p.h;
                if(p.shape.includes('cyl')) return Math.PI*p.r**2*p.h;
                if(p.shape.includes('cone')) return (Math.PI*p.r**2*p.h)/3;
                return (p.a**2*p.h)/3;
            };
            const simSurf = (p) => {
                if(p.shape==='box') return 2*(p.a*p.b + p.a*p.h + p.b*p.h);
                if(p.shape.includes('cyl')) return 2*Math.PI*p.r*(p.r+p.h);
                if(p.shape.includes('cone')) { let sl=Math.sqrt(p.r**2+p.h**2); return Math.PI*p.r*(p.r+sl); }
                let sl=Math.sqrt((p.a/2)**2+p.h**2); return p.a**2+2*p.a*sl;
            };
            const simArea = (p) => p.shape.includes('cyl')||p.shape.includes('cone') ? Math.PI*p.r**2 : p.a**2;

            partsConfig.forEach(p => { simV += simVol(p); simO += simSurf(p); });
            for(let i=0; i < partsConfig.length - 1; i++) {
                simContact += Math.min(simArea(partsConfig[i]), simArea(partsConfig[i+1]));
            }
            simO -= 2 * simContact;

            let textParts = partsConfig.map(p => {
                if(p.shape==='box') return `W√ºrfel/Quader (a=${p.a}, h=${p.h})`;
                if(p.shape==='pyramid') return `Pyramide (a=${p.a}, h=${p.h})`;
                if(p.shape==='cylinder') return `Zylinder (r=${p.r}, h=${p.h})`;
                if(p.shape==='cone') return `Kegel (r=${p.r}, h=${p.h})`;
            });
            
            return {
                text: `${desc}\n‚Ä¢ ${textParts.join('\n‚Ä¢ ')}`,
                sol: `V ‚âà ${fmt1(simV)} | O ‚âà ${fmt1(simO)}`,
                targetV: simV, targetO: simO
            };
        }

        function setTaskMode(m) {
            mode = m;
            document.getElementById('pillFree').classList.toggle('active', m === 'free');
            document.getElementById('pillTask').classList.toggle('active', m === 'task');
            taskBox.style.display = m === 'task' ? 'block' : 'none';
        }
        document.getElementById('pillFree').addEventListener('click', ()=>setTaskMode('free'));
        document.getElementById('pillTask').addEventListener('click', ()=>setTaskMode('task'));
        document.getElementById('pillEasy').addEventListener('click', ()=>{ difficulty='easy'; document.getElementById('pillEasy').classList.add('active'); document.getElementById('pillExpert').classList.remove('active'); });
        document.getElementById('pillExpert').addEventListener('click', ()=>{ difficulty='expert'; document.getElementById('pillExpert').classList.add('active'); document.getElementById('pillEasy').classList.remove('active'); });

        document.getElementById('newTask').addEventListener('click', () => {
            objects.forEach(o => scene.remove(o));
            objects.length = 0;
            currentTask = generateTask(difficulty);
            document.getElementById('taskText').innerHTML = currentTask.text.replace(/\n/g, '<br>');
            solBox.style.display = 'none';
            statusEl.textContent = "Baue die Figur nach!";
            statusEl.className = "status-msg";
            updateCalc();
        });

        document.getElementById('checkTask').addEventListener('click', () => {
            if(!currentTask) return;
            const res = updateCalc();
            const tol = 0.5; 
            if(approx(res.V, currentTask.targetV, tol) && approx(res.O, currentTask.targetO, tol)) {
                statusEl.textContent = "‚úÖ Richtig! Alle Ma√üe stimmen.";
                statusEl.className = "status-msg ok";
            } else {
                statusEl.textContent = `‚ùå Nicht ganz. Dein V=${fmt1(res.V)}, O=${fmt1(res.O)}.`;
                statusEl.className = "status-msg no";
            }
        });

        document.getElementById('add').addEventListener('click', () => addObj(createMesh({})));
        document.getElementById('remove').addEventListener('click', () => {
            if(selected) { scene.remove(selected); objects.splice(objects.indexOf(selected), 1); selected = null; iSel.textContent = "‚Äî"; updateCalc(); }
        });
        document.getElementById('resetAll').addEventListener('click', () => {
            objects.forEach(o => scene.remove(o)); objects.length = 0; selected = null; iSel.textContent = "‚Äî"; updateCalc();
        });
        document.getElementById('toggleSol').addEventListener('click', () => {
            solBox.style.display = solBox.style.display === 'none' ? 'block' : 'none';
        });

        function handleResize() {
            if(!mount || !mount.clientWidth) return;
            camera.aspect = mount.clientWidth / mount.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(mount.clientWidth, mount.clientHeight);
        }
        window.addEventListener('resize', handleResize);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Init
        addObj(createMesh({}));
        setTimeout(handleResize, 100); 
        animate();

    </script>
</body>
</html>
