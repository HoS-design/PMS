<!doctype html>
<html lang="de">
<head>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/app.css">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HoS ¬∑ K√∂rpernetze ‚Äì Zylinder & Kegel</title>
  <style>
    :root{
      --subject-color:#3b82f6;
      --bg:#f2f4f7;
      --surface:#ffffff;
      --ink:#1e293b;
      --muted:#64748b;
      --line:#e2e8f0;
      --accent:#3b82f6;
      --accent-soft:#eff6ff;
      --success:#10b981;
      --danger:#ef4444;
      --shadow: 0 10px 30px rgba(0,0,0,.08);
      --r:18px;
      --a:var(--accent);
      --b:var(--success);
      --y:#f59e0b;
      --bad:var(--danger);
      --good:var(--success);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--ink);
      background:var(--bg);
      min-height:100vh;
    }
    a{color:inherit;text-decoration:none}
    .wrap{max-width:1200px;margin:0 auto;padding:18px 14px 40px}
    .app-intro{
      display:flex;gap:14px;align-items:center;
      padding:14px 16px;
      background:var(--surface);
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
    }
    .app-intro img,
    .app-intro h1,
    .app-intro .toplink,
    .app-intro .badge{
      display:none;
    }
    .meme{
      width:74px;height:74px;border-radius:14px;object-fit:cover;
      border:1px solid var(--line);
      background:var(--bg);
    }
    h1{margin:0;font-size:1.25rem;letter-spacing:.2px}
    .sub{margin:4px 0 0;color:var(--muted);font-size:.95rem}
    .toplink{
      margin-left:auto;
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:var(--surface);
      color:var(--muted);
      font-size:.9rem;
      white-space:nowrap;
    }
    .toplink:hover{background:var(--accent-soft)}
    .badge{
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:var(--surface);
      color:var(--muted);
      font-size:.9rem;
      white-space:nowrap;
    }

    .grid{
      display:grid;
      grid-template-columns: 320px 1fr 320px;
      gap:14px;
      margin-top:14px;
      align-items:start;
    }
    @media (max-width: 1050px){
      .grid{grid-template-columns:1fr}
      .badge{display:none}
    }

    .card{
      background:var(--surface);
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card h2{
      margin:0;
      padding:12px 14px;
      font-size:1rem;
      border-bottom:1px solid var(--line);
      color:var(--ink);
      display:flex;align-items:center;gap:10px;
    }
    .body{padding:12px 14px}
    .pill{
      font-size:.85rem;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background:var(--accent-soft);
      color:var(--muted);
    }
    .btn{
      border:1px solid var(--line);
      background:var(--surface);
      color:var(--ink);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:800;
      transition:.15s transform,.15s background;
      user-select:none;
    }
    .btn:hover{transform:translateY(-1px);background:var(--accent-soft)}
    .btn:active{transform:translateY(0px)}
    .btn.tiny{padding:8px 10px;border-radius:12px;font-size:.92rem}
    .btn.good{border-color:rgba(34,197,94,.45)}
    .btn.warn{border-color:rgba(251,191,36,.45)}
    .btn.bad{border-color:rgba(251,113,133,.45)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .row + .row{margin-top:10px}
    .sep{height:1px;background:var(--line);margin:12px 0}
    .hint{color:var(--muted);font-size:.92rem;line-height:1.35}
    .status{
      padding:10px 12px;border-radius:14px;border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:.95rem;
    }

    canvas{
      width:100%;
      height:620px;
      background:linear-gradient(180deg, rgba(0,0,0,.16), rgba(0,0,0,.24));
      border:1px solid var(--line);
      border-radius:16px;
      display:block;
      touch-action:none;
    }
    @media (max-width: 1050px){
      canvas{height:540px}
    }

    .tile{
      display:flex;align-items:center;justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
      transition: .12s transform, .12s background, .12s border-color;
    }
    .tile:hover{transform:translateY(-1px);background:rgba(255,255,255,.05)}
    .tile.active{
      border-color: rgba(96,165,250,.55);
      background: rgba(96,165,250,.12);
    }
    .tile .name{font-weight:900}
    .tile .meta{color:var(--muted);font-size:.9rem}
    .kbd{
      display:inline-block;
      padding:2px 8px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:.85rem;
      font-weight:800;
    }

    .kpi{
      display:grid;grid-template-columns:repeat(3,1fr);
      gap:10px;
    }
    .kpi .box{
      padding:10px 12px;border-radius:16px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
    }
    .kpi .big{font-size:1.2rem;font-weight:900;color:#eaf2ff}
    .kpi .lab{font-size:.85rem;color:var(--muted)}

    .tag{
      display:inline-flex;gap:6px;align-items:center;
      padding:6px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--muted);font-size:.9rem;
    }
    .dot{width:8px;height:8px;border-radius:99px;background:var(--a);display:inline-block}
    .dot.b{background:var(--b)}
    .dot.y{background:var(--y)}
    .dot.bad{background:var(--bad)}
  
    .app-header {
      padding: 12px 24px;
      background: var(--surface);
      border-bottom: 1px solid var(--line);
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 12px;
      box-shadow: var(--shadow-md, 0 4px 6px -1px rgba(0,0,0,0.08), 0 2px 4px -1px rgba(0,0,0,0.04));
    }
    .app-header .brand-row { display:flex; align-items:center; gap:12px; }
    .app-header .logo-img { width:44px; height:44px; object-fit:contain; border-radius:10px; background:var(--bg); border:1px solid var(--line); }
    .app-header .badge-main {
      display:inline-flex; align-items:center;
      background: var(--subject-color);
      color: white;
      font-size:10px; font-weight:700; text-transform:uppercase; letter-spacing:0.5px;
      padding:3px 8px; border-radius:99px;
    }

</style>
</head>
<body>

<header class="app-header">
  <div class="brand-row">
    <img src="/chatisthisreal.png" alt="Logo" class="logo-img" onerror="this.style.display='none'">
    <div class="brand-title">
      <div class="badge-main is-mathe">Mathe</div>
      <h1>Koerpernetze bauen</h1>
    </div>
  </div>
  <div class="header-actions">
    <a href="/index.html" class="header-link">Startseite</a>
  </div>
</header>

<div class="wrap">
  <div class="app-intro">
    <img src="/chatisthisreal.png" onerror="this.onerror=null;this.src='/chatisthisreal.png';" alt="Chat is this real?" class="meme">
    <div>
      <h1>K√∂rpernetze bauen <span style="color:var(--b)">HoS</span></h1>
      <div class="sub">Variante B: Netz bauen (mit Andocken) ¬∑ Aufgabenmodus: Zylinder & Kegel</div>
    </div>
    <a class="toplink" href="/index.html">‚¨ÖÔ∏é Startseite</a>
    <div class="badge">üß≤ Snap ¬∑ Platzieren + Drag</div>
  </div>

  <div class="grid">
    <!-- Palette -->
    <section class="card">
      <h2>Bausteine <span class="pill">klick ‚Üí klick</span></h2>
      <div class="body">
        <div class="tile" data-spawn="circle">
          <div>
            <div class="name">Kreis</div>
            <div class="meta">Grund/Deckfl√§che (Zylinder)</div>
          </div>
          <span class="kbd">klick</span>
        </div>

        <div class="row" style="margin-top:10px"></div>

        <div class="tile" data-spawn="rect">
          <div>
            <div class="name">Rechteck</div>
            <div class="meta">Mantelfl√§che (Zylinder)</div>
          </div>
          <span class="kbd">klick</span>
        </div>

        <div class="sep"></div>

        <div class="tile" data-spawn="sector">
          <div>
            <div class="name">Kreissektor</div>
            <div class="meta">Mantelfl√§che (Kegel)</div>
          </div>
          <span class="kbd">klick</span>
        </div>

        <div class="tile" data-spawn="circle_small">
          <div>
            <div class="name">Kreis (klein)</div>
            <div class="meta">Grundfl√§che (Kegel)</div>
          </div>
          <span class="kbd">klick</span>
        </div>

        <div class="sep"></div>

        <div class="hint">
          <b>Steuerung</b><br>
          ‚Ä¢ Baustein anklicken = ausw√§hlen zum Platzieren<br>
          ‚Ä¢ Dann ins Arbeitsfeld klicken = Teil erscheint dort<br>
          ‚Ä¢ <b>Danach endet der Platziermodus automatisch</b><br>
          ‚Ä¢ Teil anklicken = ausw√§hlen/ziehen<br>
          ‚Ä¢ <span class="kbd">Q</span>/<span class="kbd">E</span> drehen (15¬∞)<br>
          ‚Ä¢ <span class="kbd">Entf</span> l√∂schen (oder üóëÔ∏è)<br>
          ‚Ä¢ <b>Doppelklick / Doppeltap</b> auf Teil = l√∂schen
        </div>
      </div>
    </section>

    <!-- Board -->
    <section class="card">
      <h2>Arbeitsfeld <span class="pill" id="taskPill">Aufgabe</span></h2>
      <div class="body">
        <canvas id="cv" width="1200" height="720" aria-label="Baufeld"></canvas>

        <div class="row" style="margin-top:12px">
          <span class="tag"><span class="dot"></span> Zylinder: 2√ó Kreis + 1√ó Rechteck</span>
          <span class="tag"><span class="dot y"></span> Kegel: 1√ó Kreis(klein) + 1√ó Kreissektor</span>
          <span class="tag"><span class="dot bad"></span> Kein Live-Check</span>
        </div>

        <div class="sep"></div>

        <div class="row">
          <button class="btn good" id="checkBtn">Pr√ºfen</button>
          <button class="btn tiny" id="nextBtn">N√§chste Aufgabe</button>
          <button class="btn tiny" id="resetBtn">Alles l√∂schen</button>
          <div class="status" id="status" style="flex:1;min-width:240px">
            W√§hle links einen Baustein und klicke dann ins Arbeitsfeld, um ihn zu platzieren.
          </div>
        </div>
      </div>
    </section>

    <!-- Side panel -->
    <aside class="card">
      <h2>Lehrer/Info <span class="pill">Optional</span></h2>
      <div class="body">
        <div class="kpi">
          <div class="box"><div class="big" id="score">0</div><div class="lab">Punkte</div></div>
          <div class="box"><div class="big" id="streak">0</div><div class="lab">Streak</div></div>
          <div class="box"><div class="big" id="done">0</div><div class="lab">Aufgaben</div></div>
        </div>

        <div class="sep"></div>

        <div class="row">
          <button class="btn tiny" id="trashBtn">üóëÔ∏è L√∂schen</button>
          <button class="btn tiny" id="toggleSnapBtn">Snap: an</button>
        </div>

        <div class="sep"></div>

        <div class="hint">
          <b>Pr√ºflogik:</b><br>
          <b>Zylinder:</b> Rechteck muss an beide Kreise andocken.<br>
          <b>Kegel:</b> Kreissektor muss am kleinen Kreis andocken.
        </div>
      </div>
    </aside>
  </div>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const statusEl = document.getElementById('status');
  const taskPill = document.getElementById('taskPill');
  const checkBtn = document.getElementById('checkBtn');
  const nextBtn = document.getElementById('nextBtn');
  const resetBtn = document.getElementById('resetBtn');
  const trashBtn = document.getElementById('trashBtn');
  const toggleSnapBtn = document.getElementById('toggleSnapBtn');

  const scoreEl = document.getElementById('score');
  const streakEl = document.getElementById('streak');
  const doneEl = document.getElementById('done');

  let score = 0, streak = 0, done = 0;

  // Tasks
  const TASKS = [
    { key: 'cyl', label: 'Baue ein Netz f√ºr einen Zylinder.' },
    { key: 'cone', label: 'Baue ein Netz f√ºr einen Kegel.' }
  ];
  let currentTask = TASKS[Math.floor(Math.random()*TASKS.length)];

  // State
  let selectedId = null;
  let dragging = null;
  let dragOffset = {x:0,y:0};
  let snapEnabled = true;

  // Placement mode (selected palette type)
  let placeType = null;

  // Board items
  const items = [];
  let nextId = 1;

  function resizeForDPR(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = cv.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (cv.width !== w || cv.height !== h){
      cv.width = w; cv.height = h;
    }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return {w: rect.width, h: rect.height};
  }

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  function toPos(e){
    const r = cv.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  function rotatePoint(p, angle){
    const c = Math.cos(angle), s = Math.sin(angle);
    return { x: p.x*c - p.y*s, y: p.x*s + p.y*c };
  }

  function anchorsFor(item){
    const a = item.angle;
    const base = [];
    if(item.type === 'circle' || item.type === 'circle_small'){
      const r = item.r;
      base.push({name:'top',    x:0,  y:-r});
      base.push({name:'bottom', x:0,  y:r});
      base.push({name:'left',   x:-r, y:0});
      base.push({name:'right',  x:r,  y:0});
    } else if(item.type === 'rect'){
      const w = item.w, h = item.h;
      base.push({name:'top',    x:0,   y:-h/2});
      base.push({name:'bottom', x:0,   y:h/2});
      base.push({name:'left',   x:-w/2,y:0});
      base.push({name:'right',  x:w/2, y:0});
    } else if(item.type === 'sector'){
      const r = item.r;
      base.push({name:'arc',  x:0, y:r});
      base.push({name:'edge', x:r*0.6, y:-r*0.2});
    }
    return base.map(p => {
      const rp = rotatePoint(p, a);
      return { name:p.name, x: item.x + rp.x, y: item.y + rp.y };
    });
  }

  function boundingHit(item, p){
    const dx = p.x - item.x;
    const dy = p.y - item.y;
    const c = Math.cos(-item.angle), s = Math.sin(-item.angle);
    const lx = dx*c - dy*s;
    const ly = dx*s + dy*c;

    if(item.type === 'circle' || item.type === 'circle_small'){
      return Math.hypot(lx, ly) <= item.r;
    }
    if(item.type === 'rect'){
      return Math.abs(lx) <= item.w/2 && Math.abs(ly) <= item.h/2;
    }
    if(item.type === 'sector'){
      return Math.hypot(lx, ly) <= item.r;
    }
    return false;
  }

  function itemAt(p){
    for(let i=items.length-1;i>=0;i--){
      if(boundingHit(items[i], p)) return items[i];
    }
    return null;
  }

  function spawnAt(type, x, y){
    const {w,h} = resizeForDPR();
    const pad = 40;
    x = clamp(x, pad, w-pad);
    y = clamp(y, pad, h-pad);

    const item = { id: nextId++, type, x, y, angle:0, links:[] };

    if(type === 'circle'){ item.r = 48; item.kind = 'circle'; }
    else if(type === 'circle_small'){ item.r = 38; item.kind = 'circle'; }
    else if(type === 'rect'){ item.w = 150; item.h = 70; item.kind = 'rect'; }
    else if(type === 'sector'){ item.r = 90; item.kind = 'sector'; }

    items.push(item);
    selectedId = item.id;
    draw();
  }

  // Palette selection
  const tiles = [...document.querySelectorAll('.tile[data-spawn]')];

  function setActiveTile(type){
    placeType = type;
    tiles.forEach(t => t.classList.toggle('active', t.getAttribute('data-spawn') === type));
  }

  function clearPlacementMode(msg){
    placeType = null;
    tiles.forEach(t => t.classList.remove('active'));
    if(msg) statusEl.textContent = msg;
  }

  tiles.forEach(tile => {
    tile.addEventListener('click', () => {
      const type = tile.getAttribute('data-spawn');
      setActiveTile(type);
      statusEl.textContent = "Baustein gew√§hlt ‚Äì klicke ins Arbeitsfeld zum Platzieren.";
      draw();
    });
  });

  // Snap logic
  const SNAP_DIST = 18;

  function addLink(a,b){
    const A = items.find(x=>x.id===a);
    const B = items.find(x=>x.id===b);
    if(!A || !B) return;
    if(!A.links.includes(b)) A.links.push(b);
    if(!B.links.includes(a)) B.links.push(a);
  }

  function trySnap(item){
    if(!snapEnabled) return;

    const myAnch = anchorsFor(item);
    let best = null;

    for(const other of items){
      if(other.id === item.id) continue;
      const oAnch = anchorsFor(other);
      for(const ma of myAnch){
        for(const oa of oAnch){
          const d = Math.hypot(ma.x-oa.x, ma.y-oa.y);
          if(d <= SNAP_DIST && (!best || d < best.d)){
            best = { d, dx: (oa.x - ma.x), dy: (oa.y - ma.y), otherId: other.id };
          }
        }
      }
    }

    if(best){
      item.x += best.dx;
      item.y += best.dy;
      addLink(item.id, best.otherId);
    }
  }

  // Drawing
  function drawGrid(w,h){
    const step = 40;
    ctx.save();
    ctx.globalAlpha = 0.28;
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 1;
    for(let x=0;x<=w;x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    for(let y=0;y<=h;y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawLinks(){
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = "rgba(52,211,153,.9)";
    ctx.lineWidth = 2;
    const seen = new Set();
    for(const a of items){
      for(const bid of a.links){
        const key = a.id < bid ? `${a.id}-${bid}` : `${bid}-${a.id}`;
        if(seen.has(key)) continue;
        seen.add(key);
        const b = items.find(x=>x.id===bid);
        if(!b) continue;
        ctx.beginPath();
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function drawItem(item){
    const isSel = (item.id === selectedId);

    ctx.save();
    ctx.translate(item.x, item.y);
    ctx.rotate(item.angle);

    ctx.lineWidth = isSel ? 3 : 2;
    ctx.strokeStyle = isSel ? "rgba(96,165,250,.95)" : "rgba(255,255,255,.70)";
    ctx.fillStyle = isSel ? "rgba(96,165,250,.14)" : "rgba(255,255,255,.06)";

    if(item.type === 'circle' || item.type === 'circle_small'){
      ctx.beginPath();
      ctx.arc(0,0,item.r,0,Math.PI*2);
      ctx.fill(); ctx.stroke();

      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(255,255,255,.25)";
      ctx.beginPath(); ctx.arc(0,-item.r,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(0,item.r,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-item.r,0,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(item.r,0,4,0,Math.PI*2); ctx.fill();

    } else if(item.type === 'rect'){
      ctx.beginPath();
      ctx.rect(-item.w/2, -item.h/2, item.w, item.h);
      ctx.fill(); ctx.stroke();

      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(255,255,255,.25)";
      ctx.beginPath(); ctx.arc(0,-item.h/2,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(0,item.h/2,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-item.w/2,0,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(item.w/2,0,4,0,Math.PI*2); ctx.fill();

    } else if(item.type === 'sector'){
      const r = item.r;
      const ang = Math.PI * 0.95;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,r, -ang/2, ang/2);
      ctx.closePath();
      ctx.fill(); ctx.stroke();

      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(255,255,255,.25)";
      ctx.beginPath(); ctx.arc(0,r,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(r*0.6,-r*0.2,4,0,Math.PI*2); ctx.fill();
    }

    // id badge
    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    if(ctx.roundRect) ctx.roundRect(-18, -22, 36, 20, 6);
    else ctx.rect(-18, -22, 36, 20);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = "rgba(230,238,252,.90)";
    ctx.font = "800 12px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(item.id), 0, -12);

    ctx.restore();
  }

  function draw(){
    const {w,h} = resizeForDPR();
    ctx.clearRect(0,0,w,h);

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.12)";
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    drawGrid(w,h);
    drawLinks();
    for(const it of items) drawItem(it);

    ctx.save();
    ctx.fillStyle = "rgba(230,238,252,.92)";
    ctx.font = "900 16px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.fillText("Aufgabe: " + currentTask.label, 14, 26);
    ctx.restore();
  }

  function deleteById(id){
    const idx = items.findIndex(x=>x.id===id);
    if(idx === -1) return;
    const removed = items[idx].id;
    items.splice(idx,1);
    for(const it of items){
      it.links = it.links.filter(x=>x!==removed);
    }
    if(selectedId === removed){
      selectedId = items.length ? items[items.length-1].id : null;
    }
  }

  function deleteSelected(){
    if(selectedId == null) return;
    deleteById(selectedId);
    statusEl.textContent = "Teil gel√∂scht.";
    draw();
  }

  // Canvas interaction
  cv.addEventListener('pointerdown', (e) => {
    const pos = toPos(e);

    // Place new item if placement active
    if(placeType){
      spawnAt(placeType, pos.x, pos.y);
      clearPlacementMode("Teil platziert. W√§hle einen neuen Baustein, um weiterzubauen.");
      return;
    }

    const hit = itemAt(pos);
    if(hit){
      selectedId = hit.id;
      dragging = hit;
      dragOffset.x = pos.x - hit.x;
      dragOffset.y = pos.y - hit.y;
      cv.setPointerCapture?.(e.pointerId);
      draw();
    } else {
      selectedId = null;
      draw();
    }
  });

  cv.addEventListener('pointermove', (e) => {
    if(!dragging) return;
    const {w,h} = resizeForDPR();
    const pos = toPos(e);
    dragging.x = clamp(pos.x - dragOffset.x, 40, w-40);
    dragging.y = clamp(pos.y - dragOffset.y, 40, h-40);
    draw();
  });

  cv.addEventListener('pointerup', () => {
    if(dragging){
      trySnap(dragging);
      dragging = null;
      draw();
    }
  });

  cv.addEventListener('pointercancel', () => {
    dragging = null;
  });

  // Double click / double tap delete
  cv.addEventListener('dblclick', (e) => {
    const pos = toPos(e);
    const hit = itemAt(pos);
    if(hit){
      deleteById(hit.id);
      statusEl.textContent = "Teil per Doppelklick gel√∂scht.";
      draw();
    }
  });

  // Prevent context menu on right click (optional, cleaner for school devices)
  cv.addEventListener('contextmenu', (e) => e.preventDefault());

  // Keyboard: rotate/delete/escape
  window.addEventListener('keydown', (e) => {
    if(e.key === 'Escape'){
      clearPlacementMode("Platziermodus beendet.");
      return;
    }

    if(selectedId == null) return;
    const it = items.find(x=>x.id===selectedId);
    if(!it) return;

    if(e.key.toLowerCase() === 'q'){
      it.angle -= Math.PI/12;
      draw();
    } else if(e.key.toLowerCase() === 'e'){
      it.angle += Math.PI/12;
      draw();
    } else if(e.key === 'Delete' || e.key === 'Backspace'){
      deleteSelected();
    }
  });

  // Buttons
  resetBtn.addEventListener('click', () => {
    items.splice(0, items.length);
    selectedId = null;
    clearPlacementMode();
    statusEl.textContent = "Alles gel√∂scht. Baustein w√§hlen und ins Feld klicken.";
    draw();
  });

  trashBtn.addEventListener('click', deleteSelected);

  toggleSnapBtn.addEventListener('click', () => {
    snapEnabled = !snapEnabled;
    toggleSnapBtn.textContent = "Snap: " + (snapEnabled ? "an" : "aus");
    statusEl.textContent = snapEnabled ? "Snap ist an." : "Snap ist aus (freier).";
    draw();
  });

  nextBtn.addEventListener('click', () => {
    currentTask = TASKS[Math.floor(Math.random()*TASKS.length)];
    taskPill.textContent = "Aufgabe: " + (currentTask.key === 'cyl' ? "Zylinder" : "Kegel");
    statusEl.textContent = "Neue Aufgabe: " + currentTask.label;
    draw();
  });

  // Checking logic
  function isConnected(aId, bId){
    const a = items.find(x=>x.id===aId);
    if(!a) return false;
    return a.links.includes(bId);
  }

  function checkCylinder(){
    const circles = items.filter(it => it.type === 'circle');
    const rects = items.filter(it => it.type === 'rect');

    if(circles.length !== 2 || rects.length !== 1){
      return {ok:false, msg:"F√ºr den Zylinder brauchst du genau 2 Kreise und 1 Rechteck."};
    }

    const rect = rects[0];
    const ok1 = isConnected(rect.id, circles[0].id);
    const ok2 = isConnected(rect.id, circles[1].id);
    if(!(ok1 && ok2)){
      return {ok:false, msg:"Das Rechteck (Mantelfl√§che) muss an beide Kreise angedockt sein."};
    }

    return {ok:true, msg:"Zylinder-Netz passt: Mantelrechteck ist mit beiden Kreisfl√§chen verbunden."};
  }

  function checkCone(){
    const sectors = items.filter(it => it.type === 'sector');
    const base = items.filter(it => it.type === 'circle_small');

    if(sectors.length !== 1 || base.length !== 1){
      return {ok:false, msg:"F√ºr den Kegel brauchst du genau 1 Kreissektor und 1 kleinen Kreis."};
    }

    if(!isConnected(sectors[0].id, base[0].id)){
      return {ok:false, msg:"Der Kreissektor (Mantel) muss am Kreis (Grundfl√§che) angedockt sein."};
    }

    return {ok:true, msg:"Kegel-Netz passt: Kreissektor ist mit der Grundfl√§che verbunden."};
  }

  function addResult(ok, goodMsg, badMsg){
    done++; doneEl.textContent = done;
    if(ok){
      score += 10 + Math.min(10, streak*2);
      streak++;
      statusEl.textContent = "‚úÖ " + goodMsg;
    } else {
      streak = 0;
      statusEl.textContent = "‚ùå " + badMsg;
    }
    scoreEl.textContent = score;
    streakEl.textContent = streak;
  }

  checkBtn.addEventListener('click', () => {
    const res = (currentTask.key === 'cyl') ? checkCylinder() : checkCone();

    if(res.ok){
      addResult(true, res.msg + " Neue Aufgabe ‚Ä¶", res.msg);
      currentTask = TASKS[Math.floor(Math.random()*TASKS.length)];
      taskPill.textContent = "Aufgabe: " + (currentTask.key === 'cyl' ? "Zylinder" : "Kegel");
    } else {
      addResult(false, "‚Äî", res.msg);
    }
    draw();
  });

  // Init
  taskPill.textContent = "Aufgabe: " + (currentTask.key === 'cyl' ? "Zylinder" : "Kegel");
  window.addEventListener('resize', draw);
  draw();
})();
</script>
</body>
</html>
