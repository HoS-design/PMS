<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HoS 3D MÃ¤rchen-Generator</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
            }
        }
    </script>
    <style>
        :root {
            /* -- HoS Light Theme -- */
            --bg: #f2f4f7;
            --surface: #ffffff;
            --ink: #1e293b;
            --muted: #64748b;
            --line: #e2e8f0;
            --accent: #3b82f6; /* Blau fÃ¼r Aktionen */
            --accent2: #10b981; /* GrÃ¼n fÃ¼r Positives */
            --warn: #f59e0b;
            --danger: #ef4444; /* Rot fÃ¼r Locked */
            --radius: 16px;
            --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.08), 0 2px 4px -1px rgba(0,0,0,0.04);
            --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: var(--font-sans);
            background-color: var(--bg);
            color: var(--ink);
        }

        #app-header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 16px 24px;
            background: var(--surface);
            border-bottom: 1px solid var(--line);
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 10;
            box-shadow: var(--shadow-md);
        }

        /* Brand Styles wie im Lernstudio */
        .brand-row { display:flex; align-items:center; gap:12px; }
        .logo-img { width:48px; height:48px; object-fit:contain; border-radius:10px; background:var(--bg); border:1px solid var(--line); }
        .badge-main {
            display:inline-flex; align-items:center;
            background: var(--ink); color: white;
            font-size:10px; font-weight:700; text-transform:uppercase; letter-spacing:0.5px;
            padding:3px 8px; border-radius:99px; margin-bottom:4px;
        }
        .brand-title h1 { margin:0; font-size:18px; font-weight:800; letter-spacing:-0.5px; color: var(--ink); }

        #controls-area {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #roll-button {
            background: var(--ink);
            color: white;
            border: none;
            padding: 10px 24px;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            border-radius: var(--radius);
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: all 0.2s;
        }

        #roll-button:hover {
            background: var(--accent);
            transform: translateY(-2px);
        }

        #info-text {
            color: var(--muted);
            font-size: 13px;
            background: var(--surface);
            padding: 8px 16px;
            border-radius: var(--radius);
            border: 1px solid var(--line);
        }

        #app-container {
            display: flex;
            height: 100vh;
            padding-top: 80px; /* Platz fÃ¼r Header */
            box-sizing: border-box;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            /* Wichtig: Transparenter Hintergrund damit der CSS Hintergrund durchscheint */
            background: transparent; 
        }

        #results-sidebar {
            width: 320px;
            background: var(--surface);
            border-left: 1px solid var(--line);
            padding: 24px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-shadow: -4px 0 15px rgba(0,0,0,0.05);
        }

        .result-card {
            background: var(--bg);
            border: 1px solid var(--line);
            padding: 16px;
            border-radius: var(--radius);
            transition: all 0.3s;
        }

        .result-card h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
            text-transform: uppercase;
            color: var(--muted);
            display: flex;
            justify-content: space-between;
        }

        .result-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--ink);
            min-height: 20px;
        }

        /* Indikator fÃ¼r gesperrte WÃ¼rfel */
        .locked-indicator {
            color: var(--danger);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .result-card.locked .locked-indicator {
            opacity: 1;
        }
        .result-card.locked {
            border-color: var(--danger);
            background: #fef2f2; /* Helles Rot */
        }

        /* Overlay beim Laden */
        #loading-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: var(--bg); color: var(--muted);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">Lade 3D-Szene & Texturen...</div>

    <header id="app-header">
        <div class="brand-row">
             <img src="chatisthisreal.png" alt="Logo" class="logo-img" onerror="this.style.display='none'">
            <div class="brand-title">
                <div class="badge-main">HoS Creative</div>
                <h1>MÃ¤rchen-Generator 3D</h1>
            </div>
        </div>
        <div id="controls-area">
            <span id="info-text">Klicke auf WÃ¼rfel zum Sperren (ðŸ”’). 'R' oder Button zum Rollen.</span>
            <button id="roll-button">WÃ¼rfeln (R)</button>
        </div>
    </header>

    <div id="app-container">
        <div id="canvas-container"></div>
        <aside id="results-sidebar">
            <div class="result-card" id="card-Held"><h3>Held <span class="locked-indicator">ðŸ”’</span></h3><div class="result-value">...</div></div>
            <div class="result-card" id="card-Ort"><h3>Ort <span class="locked-indicator">ðŸ”’</span></h3><div class="result-value">...</div></div>
            <div class="result-card" id="card-Zauber"><h3>Zauber <span class="locked-indicator">ðŸ”’</span></h3><div class="result-value">...</div></div>
            <div class="result-card" id="card-BÃ¶sewicht"><h3>BÃ¶sewicht <span class="locked-indicator">ðŸ”’</span></h3><div class="result-value">...</div></div>
            <div class="result-card" id="card-PrÃ¼fung"><h3>PrÃ¼fung <span class="locked-indicator">ðŸ”’</span></h3><div class="result-value">...</div></div>
            <div class="result-card" id="card-Moral"><h3>Moral <span class="locked-indicator">ðŸ”’</span></h3><div class="result-value">...</div></div>
        </aside>
    </div>


    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Konfiguration ---
        const categories = ["Held", "Ort", "Zauber", "BÃ¶sewicht", "PrÃ¼fung", "Moral"];
        const diceData = {
            "Held": ["Mutiger Ritter", "Schlaues BauernmÃ¤dchen", "Verwunschener Prinz", "Armer MÃ¼llersohn", "Kleine Hexe", "Sprechendes Tier"],
            "Ort": ["Dunkler Wald", "Verlassenes Schloss", "Wolkenreich", "GlÃ¤serner Berg", "HÃ¤uschen aus SÃ¼ÃŸigkeiten", "Tiefsee-HÃ¶hle"],
            "Zauber": ["Unsichtbarkeitsmantel", "Fliegender Teppich", "Zauberspiegel", "Wunschring", "Verwandlungstrank", "Zeitreise-Uhr"],
            "BÃ¶sewicht": ["BÃ¶se Stiefmutter", "Feuerspeiender Drache", "Hinterlistiger Zauberer", "Riesiger Troll", "Neidische Fee", "Schattenwesen"],
            "PrÃ¼fung": ["Drei RÃ¤tsel lÃ¶sen", "Einen Drachen besiegen", "Einen verlorenen Gegenstand finden", "Einen Fluch brechen", "Mut beweisen", "Jemandem vergeben"],
            "Moral": ["Wahre SchÃ¶nheit kommt von innen", "Mut wird belohnt", "Gier fÃ¼hrt ins Verderben", "Zusammenhalt ist StÃ¤rke", "Ehrlich wÃ¤hrt am lÃ¤ngsten", "Jeder hat eine zweite Chance verdient"]
        };

        // --- Globale Variablen ---
        let scene, camera, renderer, controls;
        let dice = []; // Array fÃ¼r die WÃ¼rfel-Meshes
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        const textureLoader = new THREE.TextureLoader();
        let textures = {}; // Speichert geladene Texturen
        let isRolling = false; // Globaler Status

        // Hilfsfunktion: Textur erstellen
        function createTextTexture(text, bgColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Hintergrund (Hellerer Stil)
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Rahmen
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 10;
            ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);

            // Text
            ctx.fillStyle = '#1e293b'; // Dunkelgrauer Text
            ctx.font = 'bold 24px sans-serif'; // Klarere Schrift
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Einfacher Zeilenumbruch
            const words = text.split(' ');
            let line = '';
            let y = canvas.height / 2;
            if (words.length > 2) {
                 // Mehrzeilig fÃ¼r lÃ¤ngere Texte
                 const mid = Math.floor(words.length / 2);
                 const line1 = words.slice(0, mid).join(' ');
                 const line2 = words.slice(mid).join(' ');
                 ctx.fillText(line1, canvas.width / 2, y - 15);
                 ctx.fillText(line2, canvas.width / 2, y + 15);
            } else {
                 ctx.fillText(text, canvas.width / 2, y);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace; // Wichtig fÃ¼r korrekte Farben
            return texture;
        }

        // Texturen vorladen
        async function preloadTextures() {
            // Start-Textur (Fragezeichen) - Heller Stil
            textures['default'] = createTextTexture("?", "#ffffff");

            const colors = {
                "Held": "#eff6ff", "Ort": "#f0fdf4", "Zauber": "#faf5ff",
                "BÃ¶sewicht": "#fef2f2", "PrÃ¼fung": "#fff7ed", "Moral": "#fcfaf5"
            };

            for (const cat of categories) {
                textures[cat] = {};
                for (const result of diceData[cat]) {
                    // Wir nutzen Pastellfarben fÃ¼r die HintergrÃ¼nde der Texturen passend zum HoS Style
                    textures[cat][result] = createTextTexture(result, colors[cat] || "#ffffff");
                }
            }
        }


        // --- Initialisierung ---
        async function init() {
            await preloadTextures();
            document.getElementById('loading-overlay').style.display = 'none';

            const container = document.getElementById('canvas-container');

            // Szene - Hintergrundfarbe auf das HoS Hellgrau setzen
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf2f4f7); 

            // Kamera
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 10, 15); // Etwas hÃ¶here Kameraposition

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true; // Schatten aktivieren
            renderer.shadowMap.type = THREE.SoftShadowMap;
            container.appendChild(renderer.domElement);

            // Licht (Helleres, freundlicheres Licht)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Helles Umgebungslicht
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); // Starke Sonne
            dirLight.position.set(5, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 10;
            dirLight.shadow.camera.bottom = -10;
            dirLight.shadow.camera.left = -15;
            dirLight.shadow.camera.right = 15;
            dirLight.shadow.mapSize.width = 2048; // SchÃ¤rfere Schatten
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
            
            // Optional: Ein weiches FÃ¼lllicht von der Seite
            const fillLight = new THREE.PointLight(0xeff6ff, 0.5);
            fillLight.position.set(-10, 5, -10);
            scene.add(fillLight);


            // Boden (SchattenfÃ¤nger)
            const planeGeometry = new THREE.PlaneGeometry(50, 50);
            const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.05 }); // Sehr subtiler Schatten
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -1.5; // Etwas tiefer als die WÃ¼rfel
            plane.receiveShadow = true;
            scene.add(plane);

            // WÃ¼rfel erstellen
            const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
            // Abgerundete Ecken fÃ¼r modernen Look (braucht mehr Polygone, aber sieht besser aus)
            const roundedCubeGeo = createRoundedBox(2, 2, 2, 0.2, 10);

            categories.forEach((cat, index) => {
                // Basis-Material (weiÃŸ, glÃ¤nzend)
                const material = new THREE.MeshStandardMaterial({
                    map: textures['default'],
                    roughness: 0.3,
                    metalness: 0.1,
                    color: 0xffffff
                });

                const cube = new THREE.Mesh(roundedCubeGeo, material);
                // Positionierung in einer Reihe, etwas Abstand
                cube.position.set((index - 2.5) * 3.5, 0, 0);
                cube.castShadow = true;
                cube.receiveShadow = true;

                // Eigene Daten anhÃ¤ngen
                cube.userData = {
                    category: cat,
                    locked: false,
                    currentResult: null,
                    // Animations-Daten
                    velocity: new THREE.Vector3(),
                    rotVelocity: new THREE.Vector3(),
                    isAnimating: false
                };

                scene.add(cube);
                dice.push(cube);
            });

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 30;
            // Begrenzen, damit man nicht unter den Boden schaut
            controls.maxPolarAngle = Math.PI / 2 - 0.1; 

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('roll-button').addEventListener('click', rollDice);
            window.addEventListener('keydown', (e) => { if(e.key.toLowerCase() === 'r') rollDice(); });
            renderer.domElement.addEventListener('click', onMouseClick);

            // Start-Animation loop
            animate();
            
            // Initial einmal rollen fÃ¼r einen Startzustand
            setTimeout(rollDice, 500);
        }

        // Hilfsfunktion fÃ¼r abgerundete Box (sieht edler aus)
        function createRoundedBox( width, height, depth, radius0, smoothness ) {
            let shape = new THREE.Shape();
            let eps = 0.00001;
            let radius = radius0 - eps;
            shape.absarc( eps, eps, eps, -Math.PI / 2, -Math.PI, true );
            shape.absarc( eps, height -  radius * 2, eps, Math.PI, Math.PI / 2, true );
            shape.absarc( width - radius * 2, height -  radius * 2, eps, Math.PI / 2, 0, true );
            shape.absarc( width - radius * 2, eps, eps, 0, -Math.PI / 2, true );
            let geometry = new THREE.ExtrudeGeometry( shape, {
                depth: depth - radius0 * 2,
                bevelEnabled: true,
                bevelSegments: smoothness * 2,
                steps: 1,
                bevelSize: radius,
                bevelThickness: radius0,
                curveSegments: smoothness
            });
            geometry.center();
            return geometry;
        }


        // --- Logik ---
        function rollDice() {
            if (isRolling) return; // Verhindert Doppel-Klicks wÃ¤hrend Animation
            isRolling = true;
            document.getElementById('roll-button').disabled = true;

            let rollingCount = 0;

            dice.forEach(cube => {
                if (!cube.userData.locked) {
                    rollingCount++;
                    cube.userData.isAnimating = true;
                    
                    // 1. Ergebnis auswÃ¤hlen (wird erst am Ende der Animation gezeigt)
                    const possibleResults = diceData[cube.userData.category];
                    const newResult = possibleResults[Math.floor(Math.random() * possibleResults.length)];
                    cube.userData.nextTexture = textures[cube.userData.category][newResult];
                    cube.userData.nextResultText = newResult;
                    
                    // 2. Physik-Startwerte setzen fÃ¼r das "Hochwerfen"
                    // ZufÃ¤lliger Schub nach oben (y) und leichte seitliche Bewegung (x, z)
                    cube.userData.velocity.set(
                        (Math.random() - 0.5) * 0.1,  // x
                        0.3 + Math.random() * 0.2,    // y (starker Schub nach oben)
                        (Math.random() - 0.5) * 0.1   // z
                    );
                    // ZufÃ¤llige schnelle Rotation
                    cube.userData.rotVelocity.set(
                        (Math.random() - 0.5) * 0.4,
                        (Math.random() - 0.5) * 0.4,
                        (Math.random() - 0.5) * 0.4
                    );

                    // UI zurÃ¼cksetzen wÃ¤hrend des Rollens
                    updateSidebarCard(cube.userData.category, "...", false);
                }
            });

            if (rollingCount === 0) {
                isRolling = false;
                document.getElementById('roll-button').disabled = false;
            }
        }

        // Der wichtigste Teil: Der Animations-Loop
        function animate() {
            requestAnimationFrame(animate);

            let stillAnimating = false;

            dice.forEach(cube => {
                if (cube.userData.locked) {
                     // Gesperrte WÃ¼rfel schweben nur ganz leicht
                     cube.position.y = Math.sin(Date.now() * 0.002 + cube.position.x) * 0.05;
                }
                
                if (cube.userData.isAnimating) {
                    stillAnimating = true;
                    
                    // Physik anwenden
                    cube.position.add(cube.userData.velocity);
                    cube.rotation.x += cube.userData.rotVelocity.x;
                    cube.rotation.y += cube.userData.rotVelocity.y;
                    cube.rotation.z += cube.userData.rotVelocity.z;

                    // Schwerkraft (zieht nach unten)
                    cube.userData.velocity.y -= 0.015;

                    // Landung prÃ¼fen (wenn y unter 0 fÃ¤llt)
                    if (cube.position.y <= 0) {
                        cube.position.y = 0; // Auf den Boden setzen
                        cube.userData.isAnimating = false; // Animation stoppen
                        
                        // Ergebnis anwenden (Texturwechsel im Moment der Landung)
                        cube.material.map = cube.userData.nextTexture;
                        cube.userData.currentResult = cube.userData.nextResultText;
                        
                        // Rotation "sÃ¤ubern" (damit er gerade liegt)
                        // Ein kleiner Trick: Wir setzen die Rotation auf fast 0, mit leichter Variation, damit es natÃ¼rlich aussieht
                        cube.rotation.set(
                            Math.round(cube.rotation.x / (Math.PI/2)) * (Math.PI/2),
                             Math.round(cube.rotation.y / (Math.PI/2)) * (Math.PI/2),
                             Math.round(cube.rotation.z / (Math.PI/2)) * (Math.PI/2)
                        );

                        // UI Update fÃ¼r diesen WÃ¼rfel
                        updateSidebarCard(cube.userData.category, cube.userData.currentResult, cube.userData.locked);
                    }
                }
            });
            
            // PrÃ¼fen, ob alle fertig sind
            if (!stillAnimating && isRolling) {
                isRolling = false;
                document.getElementById('roll-button').disabled = false;
            }

            controls.update();
            renderer.render(scene, camera);
        }


        function toggleLock(cube) {
            if(isRolling) return; // Nicht sperren wÃ¤hrend des Rollens
            cube.userData.locked = !cube.userData.locked;

            // Visuelles Feedback am WÃ¼rfel
            if (cube.userData.locked) {
                cube.material.color.set(0xef4444); // RÃ¶tlicher Stich wenn gesperrt
                // WÃ¼rfel leicht anheben um Sperre zu zeigen
                gsap.to(cube.position, {y: 0.5, duration: 0.2});
            } else {
                cube.material.color.set(0xffffff); // ZurÃ¼ck zu weiÃŸ
                gsap.to(cube.position, {y: 0, duration: 0.2});
            }

            // UI Update
            updateSidebarCard(cube.userData.category, cube.userData.currentResult, cube.userData.locked);
        }

        function updateSidebarCard(category, result, isLocked) {
            const card = document.getElementById(`card-${category}`);
            if (!card) return;
            const valueEl = card.querySelector('.result-value');
            
            card.classList.toggle('locked', isLocked);
            if (valueEl) valueEl.textContent = result || "...";
        }

        // --- Event Handler Helpers ---
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function onMouseClick(event) {
            if (isRolling) return;
            // Mausposition im Canvas normalisieren
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(dice);

            if (intersects.length > 0) {
                toggleLock(intersects[0].object);
            }
        }
        
        // Einfache GSAP-Ã¤hnliche Animation fÃ¼r das Sperren (da wir keine externe Lib laden wollen fÃ¼r so wenig)
        const gsap = {
            to: (target, props) => {
                const duration = props.duration || 0.5;
                const startY = target.y;
                const endY = props.y;
                const startTime = Date.now();
                
                function step() {
                    const now = Date.now();
                    let progress = Math.min((now - startTime) / (duration * 1000), 1);
                    // Einfaches Easing (Smooth step)
                    progress = progress * progress * (3 - 2 * progress); 
                    
                    target.y = startY + (endY - startY) * progress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(step);
                    }
                }
                step();
            }
        };


        init();
    </script>
</body>
</html>
