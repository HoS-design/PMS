<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D M√§rchen-Generator ¬∑ HoS</title>
  <style>
    :root{
      --bg:#0b1220;
      --ink:#e7eefc;
      --muted:#b8c2dd;
      --line: rgba(255,255,255,.14);
      --a:#7c3aed;   /* Held */
      --b:#22c55e;   /* Ort */
      --c:#f59e0b;   /* Zauber/Helfer */
      --d:#3b82f6;   /* Pr√ºfung */
      --e:#f43f5e;   /* Moral/Ende */
      --f:#a3e635;   /* B√∂sewicht */
      --w:#f59e0b;
      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --radius2: 28px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); color:var(--ink);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(124,58,237,.25), transparent 60%),
        radial-gradient(900px 600px at 80% 20%, rgba(34,197,94,.18), transparent 55%),
        radial-gradient(1000px 700px at 50% 110%, rgba(245,158,11,.10), transparent 55%),
        var(--bg);
      min-height:100vh;
      overflow-x:hidden;
    }
    .wrap{max-width:1100px;margin:0 auto;padding:18px 16px 28px;}
    header{display:flex;gap:14px;align-items:center;justify-content:space-between;flex-wrap:wrap;margin-bottom:14px;}
    .leftHead{display:flex;gap:14px;align-items:center;min-width:260px;}
    .meme{
      width:58px;height:58px;border-radius:14px;object-fit:cover;
      border:1px solid var(--line);box-shadow: var(--shadow);
      background: rgba(255,255,255,.04);
    }
    .titleBlock h1{margin:0;font-size:18px;letter-spacing:.2px;line-height:1.1;}
    .titleBlock p{margin:6px 0 0;color:var(--muted);font-size:13px;max-width:720px;}
    .badgeRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .badge{
      padding:8px 10px;border-radius:999px;border:1px solid var(--line);
      background: rgba(255,255,255,.06);font-size:12px;color:var(--muted);
      display:inline-flex;align-items:center;gap:8px;user-select:none;
    }
    .badge b{color:var(--b)}
    .btn{
      appearance:none;border:1px solid var(--line);background: rgba(255,255,255,.06);
      color:var(--ink);padding:10px 12px;border-radius:14px;cursor:pointer;
      box-shadow: 0 12px 35px rgba(0,0,0,.22);
      display:inline-flex;align-items:center;gap:10px;user-select:none;
      transition: transform .08s ease, background .15s ease, border-color .15s ease;
      font-size:13px;white-space:nowrap;
    }
    .btn:hover{ background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.22);}
    .btn:active{ transform: translateY(1px) scale(.99); }
    .btn.primary{
      border-color: rgba(124,58,237,.35);
      background: linear-gradient(180deg, rgba(124,58,237,.24), rgba(124,58,237,.10));
    }
    .btn.good{
      border-color: rgba(34,197,94,.35);
      background: linear-gradient(180deg, rgba(34,197,94,.20), rgba(34,197,94,.08));
    }
    .btn.warn{
      border-color: rgba(245,158,11,.40);
      background: linear-gradient(180deg, rgba(245,158,11,.18), rgba(245,158,11,.08));
    }

    .grid{display:grid;grid-template-columns: 1.2fr .8fr;gap:14px;align-items:start;}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr;} }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05));
      border:1px solid var(--line);border-radius: var(--radius2);
      box-shadow: var(--shadow);overflow:hidden;position:relative;
    }
    .cardHeader{
      padding:14px 14px 12px;border-bottom:1px solid var(--line);
      display:flex;gap:12px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;
    }
    .cardHeader h2{margin:0;font-size:14px;color:var(--muted);letter-spacing:.3px;text-transform:uppercase;}
    .cardHeader .help{font-size:12px;color:var(--muted);display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .kbd{
      font-family:var(--mono);font-size:11px;padding:4px 6px;border-radius:10px;
      border:1px solid var(--line);background: rgba(0,0,0,.18);color:var(--ink);
    }

    .stage{
      position:relative;height:520px;
      background:
        radial-gradient(800px 420px at 30% 25%, rgba(124,58,237,.18), transparent 60%),
        radial-gradient(700px 400px at 75% 30%, rgba(34,197,94,.14), transparent 58%),
        rgba(0,0,0,.14);
    }
    @media (max-width: 980px){ .stage{height:480px;} }
    canvas{display:block;width:100%;height:100%}

    .hintOverlay{
      position:absolute;left:14px;right:14px;bottom:12px;
      display:flex;gap:10px;justify-content:space-between;align-items:flex-end;
      pointer-events:none;flex-wrap:wrap;
    }
    .hintBox{
      padding:10px 12px;border-radius:16px;border:1px solid var(--line);
      background: rgba(0,0,0,.20);color:var(--muted);font-size:12px;
      backdrop-filter: blur(8px);max-width:760px;
    }
    .legend{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:flex-end;}
    .chip{
      display:inline-flex;align-items:center;gap:7px;padding:7px 10px;border-radius:999px;
      border:1px solid var(--line);background: rgba(255,255,255,.06);
      font-size:12px;color:var(--muted);white-space:nowrap;
    }
    .dot{width:9px;height:9px;border-radius:50%;background: rgba(255,255,255,.55);box-shadow: 0 0 0 3px rgba(255,255,255,.08);}
    .dot.a{ background: rgba(124,58,237,.9); box-shadow: 0 0 0 3px rgba(124,58,237,.18);}
    .dot.b{ background: rgba(34,197,94,.9); box-shadow: 0 0 0 3px rgba(34,197,94,.18);}
    .dot.c{ background: rgba(245,158,11,.95); box-shadow: 0 0 0 3px rgba(245,158,11,.18);}
    .dot.d{ background: rgba(59,130,246,.92); box-shadow: 0 0 0 3px rgba(59,130,246,.18);}
    .dot.e{ background: rgba(244,63,94,.92); box-shadow: 0 0 0 3px rgba(244,63,94,.18);}
    .dot.f{ background: rgba(163,230,53,.92); box-shadow: 0 0 0 3px rgba(163,230,53,.18);}

    .side{padding:14px;display:flex;flex-direction:column;gap:12px;}
    .prompt{
      padding:14px;border-radius:18px;border:1px solid var(--line);
      background: rgba(0,0,0,.18);
    }
    .prompt h3{margin:0 0 8px;font-size:14px;color:var(--muted);text-transform:uppercase;letter-spacing:.25px;}
    .prompt .big{font-size:16px;line-height:1.45;margin:0;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .small{font-size:12px;color:var(--muted);line-height:1.5;}
    .list{display:flex;flex-direction:column;gap:10px;}
    .item{
      display:flex;gap:10px;align-items:flex-start;justify-content:space-between;
      padding:12px;border-radius:16px;border:1px solid var(--line);background: rgba(255,255,255,.05);
    }
    .item .k{min-width:120px;color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.25px;padding-top:2px;}
    .item .v{flex:1;font-size:13px;line-height:1.35;}
    .lock{
      display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);
      background: rgba(0,0,0,.14);border-radius:999px;padding:7px 9px;cursor:pointer;
      user-select:none;font-size:12px;color:var(--muted);
    }
    .lock[data-on="1"]{
      border-color: rgba(34,197,94,.35);
      color: rgba(210,255,227,.92);
      background: rgba(34,197,94,.10);
    }
    .toast{
      position:fixed;left:50%;bottom:16px;transform:translateX(-50%);
      padding:10px 12px;border-radius:14px;border:1px solid var(--line);
      background: rgba(0,0,0,.35);color:var(--ink);font-size:13px;
      box-shadow: var(--shadow);opacity:0;pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;z-index:50;
      backdrop-filter: blur(10px);
    }
    .toast.show{opacity:1;transform:translateX(-50%) translateY(-4px);}
    footer{margin-top:14px;color:rgba(255,255,255,.45);font-size:12px;text-align:center;}
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="leftHead">
        <img src="chatistthisreal.png"
             onerror="this.onerror=null;this.src='chatisthisreal.png';"
             alt="Chat is this real?"
             class="meme">
        <div class="titleBlock">
          <div class="badgeRow">
            <span class="badge">üßö 3D M√§rchen-Generator ‚Ä¢ <b>HoS</b> ‚Ä¢ mit B√∂sewicht</span>
          </div>
          <h1>Es war einmal‚Ä¶ (aber heute w√ºrfeln wir‚Äôs) ‚ú®</h1>
          <p>Klicke einen W√ºrfel an (nur diese Kategorie w√ºrfeln) oder dr√ºcke <span class="kbd">R</span> f√ºr alles. Locks fixieren Kategorien. OrbitControls: Drag zum Drehen.</p>
        </div>
      </div>

      <div class="row">
        <button class="btn" id="homeBtn" title="Zur Startseite">üè† Startseite</button>
        <button class="btn primary" id="rollAllBtn">üé≤ Alles w√ºrfeln <span class="kbd">R</span></button>
        <button class="btn good" id="copyBtn">üìã Kopieren <span class="kbd">C</span></button>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <div class="cardHeader">
          <h2>3D B√ºhne</h2>
          <div class="help">
            <span><span class="kbd">Klick</span> W√ºrfel = Kategorie w√ºrfeln</span>
            <span><span class="kbd">Drag</span> = OrbitControls</span>
            <span><span class="kbd">L</span> = alle Locks toggeln</span>
          </div>
        </div>

        <div class="stage" id="stage">
          <canvas id="c"></canvas>

          <div class="hintOverlay">
            <div class="hintBox">
              <b style="color:var(--ink)">M√§rchen-Regel:</b>
              Nutze typische Elemente: ‚ÄûEs war einmal‚Ä¶‚Äú, Zauber/Helfer, <b>B√∂sewicht</b>, Pr√ºfung, Belohnung oder Strafe, klare Moral.
              Optional: die <b>Zahl 3</b> (3 Versuche/3 Aufgaben/3 Helfer).
            </div>
            <div class="legend">
              <span class="chip"><span class="dot a"></span> Held:in</span>
              <span class="chip"><span class="dot b"></span> Ort</span>
              <span class="chip"><span class="dot c"></span> Zauber/Helfer</span>
              <span class="chip"><span class="dot f"></span> B√∂sewicht</span>
              <span class="chip"><span class="dot d"></span> Pr√ºfung</span>
              <span class="chip"><span class="dot e"></span> Moral/Ende</span>
            </div>
          </div>
        </div>
      </section>

      <aside class="card">
        <div class="cardHeader">
          <h2>Dein M√§rchenauftrag</h2>
          <div class="help"><span class="kbd">C</span> kopiert den Auftrag</div>
        </div>

        <div class="side">
          <div class="prompt">
            <h3>Schreibauftrag</h3>
            <p class="big" id="promptText">Dr√ºcke <b>R</b> oder klicke einen W√ºrfel an. üòÑ</p>
            <p class="small" id="bonusText" style="margin:10px 0 0;"></p>
          </div>

          <div class="row">
            <button class="btn warn" id="bonusBtn">‚ú® M√§rchen-Challenge</button>
            <button class="btn" id="resetLocksBtn">üîì Alle Locks l√∂sen</button>
          </div>

          <div class="list" id="list"></div>

          <div class="small">
            <b>Mini-Check (M√§rchen):</b><br>
            ‚Ä¢ Anfang: ‚ÄûEs war einmal‚Ä¶‚Äú oder gleichwertig.<br>
            ‚Ä¢ B√∂sewicht treibt die Handlung an.<br>
            ‚Ä¢ Mindestens 1 Zauber/Helfer.<br>
            ‚Ä¢ 1 Pr√ºfung + L√∂sung.<br>
            ‚Ä¢ Ende: Belohnung/Strafe + Moral.
          </div>
        </div>
      </aside>
    </div>

    <footer>HoS ‚Ä¢ 3D M√§rchen-Generator ‚Ä¢ ES-Module (three.module.js + OrbitControls.js)</footer>
  </div>

  <div class="toast" id="toast"></div>

  <script type="module">
    // Robust ES-module imports (works reliably on GitHub Pages)
    import * as THREE from "./lib/three.module.js";
    import { OrbitControls } from "./lib/OrbitControls.js";
    // DragControls w√§ren hier nicht n√∂tig (wir klicken nur), aber du k√∂nntest sie sp√§ter nutzen:
    // import { DragControls } from "./lib/DragControls.js";

    // ---------- M√§rchen-Pools ----------
    const POOLS = {
      held: [
        "ein j√ºngstes Kind, das niemand ernst nimmt",
        "eine neugierige M√ºllerstochter mit klarem Herz",
        "ein armer Holzf√§llerbub mit gro√üem Mut",
        "eine Prinzessin, die lieber fragt als befiehlt",
        "ein Lehrling, der zu schnell verspricht",
        "ein schlauer Kater (der sprechen kann)",
        "ein sch√ºchterner Riese, der niemandem schaden will",
        "ein bescheidener Hirte, der etwas Wertvolles findet",
        "eine B√§ckerin, die heimlich W√ºnsche sammelt",
        "ein K√∂nig, der eine wichtige Lektion lernen muss"
      ],
      ort: [
        "im dunklen Wald hinter drei H√ºgeln",
        "in einem Schloss mit 100 T√ºren",
        "in einem Dorf, das jede Nacht schweigt",
        "an einem Brunnen, der Antworten fl√ºstert",
        "auf einem Berg, den nur der Wind kennt",
        "in einer H√ºtte aus Lebkuchen (aber anders als erwartet)",
        "an einer Br√ºcke, die nur bei Mondschein erscheint",
        "in einer Bibliothek, in der die M√§rchen lebendig sind",
        "in einem Garten, der niemals welkt",
        "in einer H√∂hle, die wie ein Sternenhimmel gl√§nzt"
      ],
      zauber: [
        "eine alte Frau, die drei R√§tsel stellt",
        "ein sprechender Vogel, der nur die Wahrheit sagt",
        "ein Ring, der einmal pro Tag hilft",
        "eine Spindel, die Schicksal spinnt",
        "ein Spiegel, der verborgene Absichten zeigt",
        "ein Schl√ºssel, der nur f√ºr Mutige passt",
        "drei goldene Haare, die W√ºnsche erf√ºllen",
        "ein Beutel, der nie leer wird ‚Äì aber einen Preis hat",
        "eine Kerze, die L√ºgen sichtbar macht",
        "ein unscheinbarer Stock, der im Notfall erwacht"
      ],
      boesewicht: [
        "eine Hexe, die mit s√º√üen Worten t√§uscht",
        "ein Wolf, der h√∂flicher ist als er wirkt",
        "ein neidischer Bruder / eine neidische Schwester",
        "ein gieriger K√∂nig, der niemals genug hat",
        "ein Zauberer, der Lob wie Luft braucht",
        "eine Stiefmutter, die alles kontrollieren will",
        "ein Troll unter der Br√ºcke, der R√§tsel liebt",
        "ein Rabe, der Ungl√ºck prophezeit (und es ausl√∂st)",
        "ein Geist, der nur Ruhe will ‚Äì aber falsch verstanden wird",
        "ein H√§ndler, der falsche Versprechen verkauft"
      ],
      pruefung: [
        "eine Aufgabe, die dreimal wiederholt werden muss",
        "eine Versuchung: Abk√ºrzung nehmen oder ehrlich bleiben",
        "ein Versprechen, das beinahe gebrochen wird",
        "ein Fluch, der nur durch Mitgef√ºhl endet",
        "ein Wettstreit gegen den B√∂sewicht",
        "ein R√§tsel an einem Tor ohne Schloss",
        "eine Rettung in letzter Minute",
        "eine falsche Spur, die zur Wahrheit f√ºhrt",
        "ein Tauschhandel, der unfair beginnt",
        "eine Pr√ºfung des Herzens: Mut oder Eitelkeit?"
      ],
      moral: [
        "Am Ende wird klar: Ehrlichkeit wiegt mehr als Gold.",
        "Am Ende lernt jemand: Wer teilt, gewinnt doppelt.",
        "Am Ende zeigt sich: Hochmut kommt vor dem Fall.",
        "Am Ende gilt: Mut ist leiser als Prahlerei.",
        "Am Ende wird belohnt: Wer zuh√∂rt, versteht den Zauber.",
        "Am Ende endet es so: Gier macht blind, G√ºte macht frei.",
        "Am Ende erkennt man: Kleine Taten ver√§ndern gro√üe Dinge.",
        "Am Ende wird bestraft: Wer l√ºgt, verstrickt sich selbst.",
        "Am Ende bleibt: Freundlichkeit √∂ffnet T√ºren, die Gewalt verschlie√üt.",
        "Am Ende merkt man: Manchmal ist das ‚ÄûB√∂se‚Äú nur einsam."
      ]
    };

    const BONUS = [
      "Baue die Zahl 3 ein: 3 Aufgaben ODER 3 Versuche ODER 3 Helfer.",
      "Nutze 2 typische M√§rchens√§tze (z.B. ‚ÄûDa geschah es‚Ä¶‚Äú, ‚ÄûDoch kaum‚Ä¶‚Äú).",
      "Schreibe einen Dialog mit einem sprechenden Tier.",
      "Lass den Zaubergegenstand zuerst helfen ‚Äì und sp√§ter fast schaden.",
      "Baue eine klare Pr√ºfung ein: Mut, Ehrlichkeit oder Mitgef√ºhl.",
      "Verwende mindestens 5 starke Verben (nicht: machen/gehen/sein).",
      "Gib dem B√∂sewicht einen nachvollziehbaren Grund (1‚Äì2 S√§tze).",
      "Ende mit einem Spruch: ‚ÄûUnd wenn sie nicht gestorben sind‚Ä¶‚Äú (oder modern variiert)."
    ];

    const KEYS = ["held","ort","zauber","boesewicht","pruefung","moral"];
    const LABEL = {
      held: "Held:in",
      ort: "Ort",
      zauber: "Zauber/Helfer",
      boesewicht: "B√∂sewicht",
      pruefung: "Pr√ºfung",
      moral: "Moral/Ende"
    };

    // ---------- State ----------
    const state = {
      pick: { held:null, ort:null, zauber:null, boesewicht:null, pruefung:null, moral:null },
      locked: { held:false, ort:false, zauber:false, boesewicht:false, pruefung:false, moral:false },
      bonusOn: false
    };

    // ---------- Helpers ----------
    const $ = (q)=>document.querySelector(q);
    const toastEl = $("#toast");

    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=>toastEl.classList.remove("show"), 1300);
    }
    const randFrom = (arr)=>arr[Math.floor(Math.random()*arr.length)];

    function rollKey(k){
      if(state.locked[k] && state.pick[k]) return state.pick[k];
      const v = randFrom(POOLS[k]);
      state.pick[k] = v;
      return v;
    }
    function rollAll(){
      KEYS.forEach(k=>rollKey(k));
      updateUI();
      animateRollAll();
    }
    function promptString(){
      const p = state.pick;
      if(!p.held || !p.ort || !p.zauber || !p.boesewicht || !p.pruefung || !p.moral) return "";
      return `Es war einmal ${p.held} ${p.ort}. Dort begegnet die Held:in ${p.zauber}. Doch ${p.boesewicht} stellt sich in den Weg. Dann folgt ${p.pruefung}. Schreibe das M√§rchen so, dass es zu diesem Ende passt: ${p.moral}`;
    }

    function updateUI(){
      const s = promptString();
      $("#promptText").innerHTML = s ? s : `Dr√ºcke <b>R</b> oder klicke einen W√ºrfel an. üòÑ`;

      const bonusEl = $("#bonusText");
      if(state.bonusOn && s){
        bonusEl.innerHTML = `<b style="color:var(--w)">Challenge:</b> ${randFrom(BONUS)}`;
      }else bonusEl.textContent = "";

      const list = $("#list");
      list.innerHTML = "";
      KEYS.forEach(k=>{
        const item = document.createElement("div");
        item.className = "item";

        const left = document.createElement("div");
        left.className = "k";
        left.textContent = LABEL[k];

        const mid = document.createElement("div");
        mid.className = "v";
        mid.textContent = state.pick[k] || "‚Äî noch nicht gew√ºrfelt ‚Äî";

        const lock = document.createElement("div");
        lock.className = "lock";
        lock.dataset.key = k;
        lock.dataset.on = state.locked[k] ? "1" : "0";
        lock.innerHTML = state.locked[k] ? "üîí Lock" : "üîì Lock";

        lock.addEventListener("click", ()=>{
          state.locked[k] = !state.locked[k];
          updateUI();
          syncCubeLockVisual(k);
        });

        item.appendChild(left);
        item.appendChild(mid);
        item.appendChild(lock);
        list.appendChild(item);
      });
    }

    async function copyPrompt(){
      const s = promptString();
      if(!s){ toast("Erst w√ºrfeln üôÇ"); return; }
      const bonus = ($("#bonusText").textContent || "").trim();
      const out = bonus ? `${s}\n\nChallenge: ${bonus.replace(/^Challenge:\s*/i,"")}` : s;
      try{
        await navigator.clipboard.writeText(out);
        toast("Kopiert ‚úÖ");
      }catch(e){
        const ta = document.createElement("textarea");
        ta.value = out;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
        toast("Kopiert ‚úÖ");
      }
    }

    // ---------- Buttons ----------
    $("#homeBtn").addEventListener("click", ()=>{ window.location.href = "index.html"; });
    $("#rollAllBtn").addEventListener("click", rollAll);
    $("#copyBtn").addEventListener("click", copyPrompt);
    $("#bonusBtn").addEventListener("click", ()=>{
      state.bonusOn = !state.bonusOn;
      toast(state.bonusOn ? "Challenge an ‚ú®" : "Challenge aus");
      updateUI();
    });
    $("#resetLocksBtn").addEventListener("click", ()=>{
      KEYS.forEach(k=>state.locked[k]=false);
      toast("Locks gel√∂st üîì");
      updateUI();
      KEYS.forEach(syncCubeLockVisual);
    });

    window.addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      if(k==="r") rollAll();
      if(k==="c") copyPrompt();
      if(k==="l"){
        const anyUnlocked = KEYS.some(x=>!state.locked[x]);
        KEYS.forEach(x=> state.locked[x] = anyUnlocked ? true : false);
        toast(anyUnlocked ? "Alle gelockt üîí" : "Alle ungelockt üîì");
        updateUI();
        KEYS.forEach(syncCubeLockVisual);
      }
    });

    // ---------- Three.js Scene (ES Modules + OrbitControls) ----------
    const canvas = $("#c");
    const stage = $("#stage");

    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(0, 3.4, 10.8);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.enablePan = false;
    controls.minDistance = 7.5;
    controls.maxDistance = 14.5;
    controls.target.set(0, 0.05, 0);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.65));
    const dir = new THREE.DirectionalLight(0xffffff, 0.95);
    dir.position.set(5, 7, 3);
    scene.add(dir);
    const rim = new THREE.DirectionalLight(0xffffff, 0.45);
    rim.position.set(-6, 2, -6);
    scene.add(rim);

    // Floor
    const floor = new THREE.Mesh(
      new THREE.CircleGeometry(7.2, 64),
      new THREE.MeshStandardMaterial({ color: 0x0b1220, metalness: 0.05, roughness: 0.95, transparent:true, opacity:0.35 })
    );
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -1.25;
    scene.add(floor);

    // Cube textures (CanvasTexture works the same with modules)
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function makeLabelTexture(text){
      const c = document.createElement("canvas");
      c.width = 512; c.height = 512;
      const ctx = c.getContext("2d");
      ctx.clearRect(0,0,c.width,c.height);

      ctx.fillStyle = "rgba(0,0,0,0.25)";
      roundRect(ctx, 70, 170, 372, 172, 36);
      ctx.fill();

      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.lineWidth = 6;
      roundRect(ctx, 70, 170, 372, 172, 36);
      ctx.stroke();

      ctx.fillStyle = "#e7eefc";
      ctx.font = "700 58px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, 256, 252);

      ctx.fillStyle = "rgba(231,238,252,0.65)";
      ctx.font = "500 26px ui-monospace, Menlo, Consolas, monospace";
      ctx.fillText("CLICK", 256, 318);

      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = 8;
      return tex;
    }

    const COLORS = {
      held: 0x7c3aed,
      ort: 0x22c55e,
      zauber: 0xf59e0b,
      boesewicht: 0xa3e635,
      pruefung: 0x3b82f6,
      moral: 0xf43f5e
    };

    const cubeGeo = new THREE.BoxGeometry(1.45, 1.45, 1.45);
    const cubes = {};
    const cubeOrder = ["held","ort","zauber","boesewicht","pruefung","moral"];
    const positions = [
      [-2.6, 0.75, 0.0], [0.0, 0.75, 0.0], [2.6, 0.75, 0.0],
      [-2.6, -0.55, -0.5], [0.0, -0.55, -0.5], [2.6, -0.55, -0.5]
    ];

    cubeOrder.forEach((k, i)=>{
      const tex = makeLabelTexture(LABEL[k]);
      const baseColor = COLORS[k];

      const mats = [];
      for(let f=0; f<6; f++){
        const isLabelFace = (f===4);
        if(isLabelFace){
          mats.push(new THREE.MeshStandardMaterial({ map: tex, metalness: 0.15, roughness: 0.55 }));
        }else{
          mats.push(new THREE.MeshStandardMaterial({
            color: baseColor, metalness: 0.35, roughness: 0.35, transparent:true, opacity: 0.92
          }));
        }
      }

      const mesh = new THREE.Mesh(cubeGeo, mats);
      mesh.position.set(...positions[i]);
      mesh.userData.key = k;
      mesh.rotation.set(Math.random()*0.6, Math.random()*0.8, Math.random()*0.4);

      const wf = new THREE.LineSegments(
        new THREE.WireframeGeometry(cubeGeo),
        new THREE.LineBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.18 })
      );
      wf.scale.set(1.01,1.01,1.01);
      mesh.add(wf);

      scene.add(mesh);
      cubes[k] = mesh;
    });

    function syncCubeLockVisual(k){
      const m = cubes[k];
      if(!m) return;
      const on = state.locked[k];
      m.userData.locked = on;

      m.children.forEach(ch=>{
        if(ch.material && ch.material.opacity !== undefined){
          ch.material.opacity = on ? 0.12 : 0.18;
        }
      });

      m.material.forEach((mat)=>{
        if(mat.map) return;
        mat.opacity = on ? 0.55 : 0.92;
        mat.roughness = on ? 0.65 : 0.35;
      });
    }

    // Resize
    function resize(){
      const r = stage.getBoundingClientRect();
      renderer.setSize(r.width, r.height, false);
      camera.aspect = r.width / r.height;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);
    resize();

    // Raycaster click (OrbitControls friendly: ignore clicks that were drags)
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let down = null;

    stage.addEventListener("pointerdown", (e)=>{
      down = { x:e.clientX, y:e.clientY };
    });

    stage.addEventListener("pointerup", (e)=>{
      if(!down) return;
      const dx = Math.abs(e.clientX - down.x);
      const dy = Math.abs(e.clientY - down.y);
      down = null;
      if(dx > 6 || dy > 6) return; // was a drag, not a click

      const rect = renderer.domElement.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      mouse.x = x * 2 - 1;
      mouse.y = -(y * 2 - 1);

      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(Object.values(cubes), true);
      if(!hits.length) return;

      let obj = hits[0].object;
      while(obj && !obj.userData.key) obj = obj.parent;
      if(!obj) return;

      const key = obj.userData.key;
      if(state.locked[key] && state.pick[key]){
        toast(`${LABEL[key]} ist gelockt üîí`);
        bump(obj, 0.35);
        return;
      }
      rollKey(key);
      updateUI();
      animateRollOne(key);
      toast(`${LABEL[key]} gew√ºrfelt üé≤`);
    });

    function bump(mesh, strength=0.5){
      mesh.userData.bump = (mesh.userData.bump || 0) + strength;
    }
    function animateRollOne(key){
      const m = cubes[key];
      if(!m) return;
      m.userData.spin = 1.15;
      bump(m, 0.55);
    }
    function animateRollAll(){
      cubeOrder.forEach((k, idx)=>{
        if(state.locked[k] && state.pick[k]) return;
        const m = cubes[k];
        if(!m) return;
        m.userData.spin = 1.0 + idx*0.05;
        bump(m, 0.45);
      });
      toast("Alles gew√ºrfelt üé≤");
    }

    // Init
    rollAll();
    updateUI();

    // Animation loop
    const clock = new THREE.Clock();

    function tick(){
      const t = clock.getElapsedTime();
      const dt = Math.min(0.033, clock.getDelta());

      controls.update();

      cubeOrder.forEach((k, i)=>{
        const m = cubes[k];
        if(!m) return;

        const locked = !!m.userData.locked;
        const floatAmp = locked ? 0.06 : 0.13;
        const floatSpd = locked ? 0.85 : 1.15;

        m.position.y = positions[i][1] + Math.sin(t*floatSpd + i*0.8)*floatAmp;

        const base = locked ? 0.25 : 0.55;
        m.rotation.y += dt * base * (0.7 + i*0.07);
        m.rotation.x += dt * base * (0.45 + i*0.05);

        if(m.userData.spin && m.userData.spin > 0){
          const s = m.userData.spin;
          m.rotation.y += dt * 7.0 * s;
          m.rotation.x += dt * 6.0 * s;
          m.userData.spin = Math.max(0, s - dt*1.6);
        }
        if(m.userData.bump && m.userData.bump > 0){
          const b = m.userData.bump;
          m.position.y += b * 0.08;
          m.userData.bump = Math.max(0, b - dt*2.4);
        }
      });

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();
  </script>
</body>
</html>