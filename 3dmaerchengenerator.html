<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HoS 3D M√§rchen-Generator</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
            }
        }
    </script>
    <style>
        :root {
            --subject-color:#ef4444;
            /* -- HoS Light Theme -- */
            --bg: #f2f4f7;
            --surface: #ffffff;
            --ink: #1e293b;
            --muted: #64748b;
            --line: #e2e8f0;
            --accent: #3b82f6;
            --danger: #ef4444;
            --radius: 16px;
            --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.08), 0 2px 4px -1px rgba(0,0,0,0.04);
            --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: var(--font-sans);
            background-color: var(--bg);
            color: var(--ink);
        }

        #app-header {
            position: absolute;
            top: 0; left: 0; width: 100%;
            padding: 16px 24px;
            background: var(--surface);
            border-bottom: 1px solid var(--line);
            display: flex; align-items: center; justify-content: space-between;
            z-index: 10;
            box-shadow: var(--shadow-md);
        }

        .brand-row { display:flex; align-items:center; gap:12px; }
        .logo-img { width:48px; height:48px; object-fit:contain; border-radius:10px; background:var(--bg); border:1px solid var(--line); }
        .badge-main {
            display:inline-flex; align-items:center;
            background: var(--subject-color); color: white;
            font-size:10px; font-weight:700; text-transform:uppercase; letter-spacing:0.5px;
            padding:3px 8px; border-radius:99px; margin-bottom:4px;
        }
        .brand-title h1 { margin:0; font-size:18px; font-weight:800; letter-spacing:-0.5px; color: var(--ink); }

        #controls-area { display: flex; gap: 10px; align-items: center; }

        #roll-button {
            background: var(--ink); color: white; border: none;
            padding: 12px 32px; font-size: 15px; font-weight: 700; text-transform: uppercase;
            border-radius: var(--radius); cursor: pointer; box-shadow: var(--shadow-md);
            transition: all 0.2s;
        }
        #roll-button:hover { background: var(--accent); transform: translateY(-2px); }
        #roll-button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        #app-container {
            display: flex; height: 100vh; padding-top: 80px; box-sizing: border-box;
        }

        #canvas-container { flex-grow: 1; position: relative; background: transparent; }

        #results-sidebar {
            width: 380px;
            background: var(--surface);
            border-left: 1px solid var(--line);
            padding: 24px;
            overflow-y: auto;
            display: flex; flex-direction: column; gap: 20px;
            box-shadow: -4px 0 15px rgba(0,0,0,0.05);
            z-index: 5;
        }

        /* Zusammenfassungs-Box */
        .summary-box {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: var(--radius);
            padding: 20px;
        }
        .summary-box h3 { margin: 0 0 12px 0; font-size: 14px; text-transform: uppercase; color: #1e40af; }
        .summary-text { font-size: 15px; line-height: 1.6; color: #1e3a8a; }

        /* Karten */
        .result-card {
            background: var(--bg); border: 1px solid var(--line);
            padding: 12px 16px; border-radius: 12px;
            transition: all 0.2s; display: flex; align-items: center; gap: 12px;
        }
        .result-icon { font-size: 28px; }
        .result-content { flex: 1; }
        .result-label { font-size: 11px; text-transform: uppercase; color: var(--muted); font-weight: 700; display: block; margin-bottom: 2px;}
        .result-value { font-size: 15px; font-weight: 600; color: var(--ink); }
        
        .result-card.locked { border-color: var(--danger); background: #fef2f2; }
        .lock-icon { opacity: 0; color: var(--danger); font-size: 18px;}
        .result-card.locked .lock-icon { opacity: 1; }

        #loading-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: var(--bg); color: var(--muted);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; font-weight: 600;
        }
        
        @media (max-width: 800px) {
            #app-container { flex-direction: column; }
            #results-sidebar { width: 100%; height: 40%; order: 2; border-left: none; border-top: 1px solid var(--line); }
            #canvas-container { height: 60%; order: 1; }
        }

</style>
</head>
<body>

    <div id="loading-overlay">Lade M√§rchenwelt...</div>

    <header id="app-header">
        <div class="brand-row">
            <img src="chatisthisreal.png" alt="Logo" class="logo-img" onerror="this.style.display='none'">
            <div class="brand-title">
                <div class="badge-main">Deutsch</div>
                <h1>M√§rchen-Generator 3D</h1>
            </div>
        </div>
        <div id="controls-area">
            <button id="roll-button">W√ºrfeln (R)</button>
        </div>
    </header>

    <div id="app-container">
        <div id="canvas-container"></div>
        
        <aside id="results-sidebar">
            <div class="summary-box">
                <h3>Dein Schreibauftrag</h3>
                <div id="story-summary" class="summary-text">
                    Dr√ºcke auf "W√ºrfeln", um dein M√§rchen zu starten...
                </div>
            </div>

            <div id="cards-container">
                </div>
        </aside>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Daten ---
        const categories = ["Held", "Ort", "Zauber", "B√∂sewicht", "Pr√ºfung", "Moral"];
        const diceData = {
            "Held": [
                {text: "Mutiger Ritter", icon: "‚öîÔ∏è"}, {text: "Schlaues M√§dchen", icon: "üëß"},
                {text: "Prinz", icon: "ü§¥"}, {text: "M√ºllersohn", icon: "üåæ"},
                {text: "Kleine Hexe", icon: "üßô‚Äç‚ôÄÔ∏è"}, {text: "Sprechender Fuchs", icon: "ü¶ä"}
            ],
            "Ort": [
                {text: "Dunkler Wald", icon: "üå≤"}, {text: "Altes Schloss", icon: "üè∞"},
                {text: "Wolkenreich", icon: "‚òÅÔ∏è"}, {text: "Gl√§serner Berg", icon: "üèîÔ∏è"},
                {text: "Hexenhaus", icon: "üç™"}, {text: "Unterwasser", icon: "üåä"}
            ],
            "Zauber": [
                {text: "Tarnumhang", icon: "üß•"}, {text: "Fliegender Teppich", icon: "üß∂"},
                {text: "Zauberspiegel", icon: "ü™û"}, {text: "Wunschring", icon: "üíç"},
                {text: "Zaubertrank", icon: "üß™"}, {text: "Zeituhr", icon: "‚è≥"}
            ],
            "B√∂sewicht": [
                {text: "B√∂se Stiefmutter", icon: "üë∏"}, {text: "Feuerdrache", icon: "üêâ"},
                {text: "Zauberer", icon: "üßô‚Äç‚ôÇÔ∏è"}, {text: "Riesiger Troll", icon: "üëπ"},
                {text: "Neidische Fee", icon: "üßö‚Äç‚ôÄÔ∏è"}, {text: "Schattenmonster", icon: "üëª"}
            ],
            "Pr√ºfung": [
                {text: "3 R√§tsel l√∂sen", icon: "‚ùì"}, {text: "Drachenkampf", icon: "üó°Ô∏è"},
                {text: "Suche im Labyrinth", icon: "üåÄ"}, {text: "Fluch brechen", icon: "‚ú®"},
                {text: "Mutprobe", icon: "ü¶Å"}, {text: "Jemandem vergeben", icon: "ü§ù"}
            ],
            "Moral": [
                {text: "Wahre Sch√∂nheit", icon: "üíñ"}, {text: "Mut lohnt sich", icon: "üèÜ"},
                {text: "Gier schadet", icon: "üí∞"}, {text: "Zusammenhalt", icon: "ü§≤"},
                {text: "Ehrlichkeit", icon: "ü§•"}, {text: "2. Chance", icon: "üîÑ"}
            ]
        };

        // --- Global ---
        let scene, camera, renderer, controls;
        let dice = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let textures = {}; 
        let isRolling = false;
        
        let currentStory = {
            "Held": null, "Ort": null, "Zauber": null, 
            "B√∂sewicht": null, "Pr√ºfung": null, "Moral": null
        };

        // --- Textur Generator (Vollfl√§chig & Lesbar) ---
        function createTextTexture(text, icon, bgColor, textColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; 
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // 1. Hintergrund (Vollfl√§chig!)
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. Dekorativer Rahmen (damit es wie ein W√ºrfel aussieht)
            ctx.strokeStyle = "rgba(0,0,0,0.1)"; 
            ctx.lineWidth = 40;
            // Abgerundetes Rechteck simulieren
            ctx.strokeRect(0,0,canvas.width, canvas.height);

            // 3. Icon (Riesig in der Mitte)
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '220px serif'; 
            ctx.fillText(icon, canvas.width / 2, canvas.height / 2 - 50);

            // 4. Text (Unten, Fett)
            ctx.fillStyle = textColor; 
            ctx.font = 'bold 50px sans-serif'; 
            
            // Zeilenumbruch
            const words = text.split(' ');
            let y = canvas.height / 2 + 120;
            
            if (text.length > 12 && words.length > 1) {
                 const mid = Math.floor(words.length / 2);
                 const line1 = words.slice(0, mid).join(' ');
                 const line2 = words.slice(mid).join(' ');
                 ctx.fillText(line1, canvas.width / 2, y);
                 ctx.fillText(line2, canvas.width / 2, y + 60);
            } else {
                 ctx.fillText(text, canvas.width / 2, y + 30);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        async function preloadTextures() {
            textures['default'] = createTextTexture("Start", "üé≤", "#ffffff", "#94a3b8");

            const styles = {
                "Held": {bg: "#dbeafe", text: "#1e40af"}, // Blau
                "Ort": {bg: "#dcfce7", text: "#166534"}, // Gr√ºn
                "Zauber": {bg: "#f3e8ff", text: "#6b21a8"}, // Lila
                "B√∂sewicht": {bg: "#fee2e2", text: "#991b1b"}, // Rot
                "Pr√ºfung": {bg: "#ffedd5", text: "#9a3412"}, // Orange
                "Moral": {bg: "#f1f5f9", text: "#334155"} // Grau
            };

            for (const cat of categories) {
                textures[cat] = {};
                for (const item of diceData[cat]) {
                    textures[cat][item.text] = createTextTexture(item.text, item.icon, styles[cat].bg, styles[cat].text);
                }
            }
        }

        // --- Setup ---
        async function init() {
            await preloadTextures();
            document.getElementById('loading-overlay').style.display = 'none';
            initSidebar();

            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf2f4f7); 
            // Nebel f√ºr Tiefe
            scene.fog = new THREE.Fog(0xf2f4f7, 20, 50);

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(0, 14, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.SoftShadowMap;
            container.appendChild(renderer.domElement);

            // Licht Setup (Hell & Freundlich)
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(10, 20, 10);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 50;
            sun.shadow.camera.left = -20;
            sun.shadow.camera.right = 20;
            sun.shadow.camera.top = 20;
            sun.shadow.camera.bottom = -20;
            scene.add(sun);

            // Boden
            const groundMat = new THREE.ShadowMaterial({ opacity: 0.1 });
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);

            // W√ºrfel erstellen (BoxGeometry f√ºr perfekte Textur-Mapping)
            const boxGeo = new THREE.BoxGeometry(2.8, 2.8, 2.8); 

            categories.forEach((cat, i) => {
                // Initial Textur
                const mat = new THREE.MeshStandardMaterial({
                    map: textures['default'],
                    color: 0xffffff, // WICHTIG: Wei√ü, damit Texturfarben stimmen
                    roughness: 0.3,
                    metalness: 0.0
                });

                const cube = new THREE.Mesh(boxGeo, mat);
                
                // 2 Reihen √† 3
                const row = i < 3 ? 0 : 1;
                const col = i % 3;
                // Versatz f√ºr sch√∂ne Anordnung
                cube.position.set((col - 1) * 4.5, 0, (row - 0.5) * 4.5);
                
                cube.castShadow = true;
                cube.receiveShadow = true;
                
                cube.userData = {
                    category: cat,
                    locked: false,
                    velocity: new THREE.Vector3(),
                    rotVel: new THREE.Vector3(),
                    isAnimating: false,
                    startPos: cube.position.clone()
                };
                
                scene.add(cube);
                dice.push(cube);
            });

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            controls.enablePan = false;
            controls.minDistance = 10;
            controls.maxDistance = 40;

            window.addEventListener('resize', onResize);
            document.getElementById('roll-button').addEventListener('click', rollDice);
            window.addEventListener('keydown', (e) => { if(e.key.toLowerCase() === 'r') rollDice(); });
            renderer.domElement.addEventListener('click', onClick);

            animate();
            
            // Start Animation
            setTimeout(rollDice, 500);
        }

        // --- UI ---
        function initSidebar() {
            const container = document.getElementById('cards-container');
            categories.forEach(cat => {
                const el = document.createElement('div');
                el.className = 'result-card';
                el.id = `card-${cat}`;
                el.innerHTML = `
                    <div class="result-icon">üé≤</div>
                    <div class="result-content">
                        <span class="result-label">${cat}</span>
                        <div class="result-value">...</div>
                    </div>
                    <div class="lock-icon">üîí</div>
                `;
                container.appendChild(el);
            });
        }

        function updateStorySummary() {
            const p = currentStory;
            if (!p.Held || !p.Ort || !p.Zauber || !p.B√∂sewicht || !p.Pr√ºfung || !p.Moral) {
                document.getElementById('story-summary').textContent = "W√ºrfle, um die Geschichte zu enth√ºllen...";
                return;
            }

            // Dynamischer Text
            const text = `Es war einmal <b>${p.Held}</b>, unterwegs im <b>${p.Ort}</b>. 
            Pl√∂tzlich tauchte <b>${p.Zauber}</b> auf! Doch Vorsicht: <b>${p.B√∂sewicht}</b> lauerte bereits. 
            Die Aufgabe war schwer: <b>${p.Pr√ºfung}</b>. Und die Moral? <b>${p.Moral}</b>.`;
            
            document.getElementById('story-summary').innerHTML = text;
        }

        function updateCard(cat, item, locked) {
            const card = document.getElementById(`card-${cat}`);
            card.querySelector('.result-value').textContent = item.text;
            card.querySelector('.result-icon').textContent = item.icon;
            if (locked) card.classList.add('locked'); else card.classList.remove('locked');
            
            currentStory[cat] = item.text;
        }

        // --- Logik ---
        function rollDice() {
            if (isRolling) return;
            isRolling = true;
            document.getElementById('roll-button').disabled = true;

            let activeCount = 0;

            dice.forEach(cube => {
                if (!cube.userData.locked) {
                    activeCount++;
                    cube.userData.isAnimating = true;
                    
                    // Ergebnis
                    const pool = diceData[cube.userData.category];
                    const pick = pool[Math.floor(Math.random() * pool.length)];
                    cube.userData.nextTex = textures[cube.userData.category][pick.text];
                    cube.userData.nextInfo = pick;

                    // Reset Position leicht
                    cube.position.y = 0;

                    // Physik Start (Hochwerfen)
                    cube.userData.velocity.set(
                        (Math.random() - 0.5) * 0.2, // x drift
                        0.5 + Math.random() * 0.3,   // y Schub (hoch!)
                        (Math.random() - 0.5) * 0.2  // z drift
                    );
                    
                    // Rotation (Wild)
                    cube.userData.rotVel.set(
                        (Math.random() - 0.5) * 0.8,
                        (Math.random() - 0.5) * 0.8,
                        (Math.random() - 0.5) * 0.8
                    );
                }
            });

            if (activeCount === 0) {
                isRolling = false;
                document.getElementById('roll-button').disabled = false;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            let moving = false;

            dice.forEach(cube => {
                // Animation f√ºr gelockte (Schweben)
                if (cube.userData.locked) {
                    cube.position.y = 0.5 + Math.sin(Date.now() * 0.003 + cube.position.x) * 0.1;
                    // Sanfte Rotation zur√ºcksetzen wenn gelockt
                    cube.rotation.x = THREE.MathUtils.lerp(cube.rotation.x, 0, 0.1);
                    cube.rotation.z = THREE.MathUtils.lerp(cube.rotation.z, 0, 0.1);
                }
                
                // Physik Animation
                if (cube.userData.isAnimating) {
                    moving = true;
                    
                    // Position
                    cube.position.add(cube.userData.velocity);
                    
                    // Rotation
                    cube.rotation.x += cube.userData.rotVel.x;
                    cube.rotation.y += cube.userData.rotVel.y;
                    cube.rotation.z += cube.userData.rotVel.z;

                    // Schwerkraft
                    cube.userData.velocity.y -= 0.02;

                    // Bodenber√ºhrung
                    if (cube.position.y <= 0) {
                        cube.position.y = 0;
                        // Bounce Effekt (kleiner H√ºpfer wenn Energie √ºbrig)
                        if(Math.abs(cube.userData.velocity.y) > 0.1) {
                             cube.userData.velocity.y *= -0.4; // D√§mpfung
                        } else {
                            // Landung fertig
                            cube.userData.isAnimating = false;
                            
                            // Textur anwenden
                            cube.material.map = cube.userData.nextTex;
                            
                            // Ausrichten (damit Text oben ist)
                            cube.rotation.set(0, 0, 0); 
                            // Zur√ºck zur Startposition gleiten (falls zu weit weggesprungen)
                            cube.position.x = cube.userData.startPos.x;
                            cube.position.z = cube.userData.startPos.z;
                            
                            updateCard(cube.userData.category, cube.userData.nextInfo, false);
                            updateStorySummary();
                        }
                    }
                }
            });

            if (!moving && isRolling) {
                isRolling = false;
                document.getElementById('roll-button').disabled = false;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function onClick(e) {
            if (isRolling) return;
            // Raycast
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(dice);
            
            if (hits.length > 0) {
                const cube = hits[0].object;
                cube.userData.locked = !cube.userData.locked;
                
                // Update UI sofort
                const cat = cube.userData.category;
                const info = diceData[cat].find(i => i.text === currentStory[cat]) || {text:"...", icon:"üé≤"};
                updateCard(cat, info, cube.userData.locked);
            }
        }

        function onResize() {
            const c = document.getElementById('canvas-container');
            camera.aspect = c.clientWidth / c.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(c.clientWidth, c.clientHeight);
        }

        init();
    </script>
</body>
</html>
