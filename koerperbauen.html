<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HoS ¬∑ K√∂rpernetze ‚Äì Zylinder & Kegel</title>
  <style>
    :root{
      --bg:#0b1220;
      --ink:#e6eefc;
      --muted:#9fb0d0;
      --line:rgba(255,255,255,.12);
      --a:#60a5fa;
      --b:#34d399;
      --y:#fbbf24;
      --bad:#fb7185;
      --good:#22c55e;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --r:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--ink);
      background:
        radial-gradient(1200px 700px at 12% 10%, rgba(96,165,250,.22), transparent 60%),
        radial-gradient(900px 600px at 90% 18%, rgba(52,211,153,.18), transparent 55%),
        radial-gradient(900px 600px at 30% 95%, rgba(251,191,36,.14), transparent 55%),
        var(--bg);
      min-height:100vh;
    }
    a{color:inherit;text-decoration:none}
    .wrap{max-width:1200px;margin:0 auto;padding:18px 14px 40px}
    header{
      display:flex;gap:14px;align-items:center;
      padding:14px 16px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
    }
    .meme{
      width:74px;height:74px;border-radius:14px;object-fit:cover;
      border:1px solid var(--line);
      background:#0b1020;
    }
    h1{margin:0;font-size:1.25rem;letter-spacing:.2px}
    .sub{margin:4px 0 0;color:var(--muted);font-size:.95rem}
    .toplink{
      margin-left:auto;
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--muted);
      font-size:.9rem;
      white-space:nowrap;
    }
    .toplink:hover{background:rgba(255,255,255,.06)}
    .badge{
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--muted);
      font-size:.9rem;
      white-space:nowrap;
    }

    .grid{
      display:grid;
      grid-template-columns: 320px 1fr 320px;
      gap:14px;
      margin-top:14px;
      align-items:start;
    }
    @media (max-width: 1050px){
      .grid{grid-template-columns:1fr}
      .badge{display:none}
    }

    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card h2{
      margin:0;
      padding:12px 14px;
      font-size:1rem;
      border-bottom:1px solid var(--line);
      color:#dbe7ff;
      display:flex;align-items:center;gap:10px;
    }
    .body{padding:12px 14px}
    .pill{
      font-size:.85rem;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--muted);
    }
    .btn{
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--ink);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:800;
      transition:.15s transform,.15s background;
      user-select:none;
    }
    .btn:hover{transform:translateY(-1px);background:rgba(255,255,255,.06)}
    .btn:active{transform:translateY(0px)}
    .btn.tiny{padding:8px 10px;border-radius:12px;font-size:.92rem}
    .btn.good{border-color:rgba(34,197,94,.45)}
    .btn.warn{border-color:rgba(251,191,36,.45)}
    .btn.bad{border-color:rgba(251,113,133,.45)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .row + .row{margin-top:10px}
    .sep{height:1px;background:var(--line);margin:12px 0}
    .hint{color:var(--muted);font-size:.92rem;line-height:1.35}
    .status{
      padding:10px 12px;border-radius:14px;border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:.95rem;
    }

    /* Canvas area */
    canvas{
      width:100%;
      height:620px;
      background:linear-gradient(180deg, rgba(0,0,0,.16), rgba(0,0,0,.24));
      border:1px solid var(--line);
      border-radius:16px;
      display:block;
      touch-action:none;
    }
    @media (max-width: 1050px){
      canvas{height:540px}
    }

    /* Palette tiles */
    .tile{
      display:flex;align-items:center;justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:rgba(255,255,255,.03);
      cursor:grab;
      user-select:none;
    }
    .tile:active{cursor:grabbing}
    .tile .name{font-weight:900}
    .tile .meta{color:var(--muted);font-size:.9rem}
    .kbd{
      display:inline-block;
      padding:2px 8px;
      border-radius:10px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:.85rem;
      font-weight:800;
    }

    .kpi{
      display:grid;grid-template-columns:repeat(3,1fr);
      gap:10px;
    }
    .kpi .box{
      padding:10px 12px;border-radius:16px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
    }
    .kpi .big{font-size:1.2rem;font-weight:900;color:#eaf2ff}
    .kpi .lab{font-size:.85rem;color:var(--muted)}

    .tag{
      display:inline-flex;gap:6px;align-items:center;
      padding:6px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--muted);font-size:.9rem;
    }
    .dot{width:8px;height:8px;border-radius:99px;background:var(--a);display:inline-block}
    .dot.b{background:var(--b)}
    .dot.y{background:var(--y)}
    .dot.bad{background:var(--bad)}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <img src="chatistthisreal.png" onerror="this.onerror=null;this.src='chatisthisreal.png';" alt="Chat is this real?" class="meme">
    <div>
      <h1>K√∂rpernetze bauen <span style="color:var(--b)">HoS</span></h1>
      <div class="sub">Variante B: Netz bauen (mit Andocken) ¬∑ Aufgabenmodus: Zylinder & Kegel</div>
    </div>
    <a class="toplink" href="Index.html">‚¨ÖÔ∏é Startseite</a>
    <div class="badge">üß≤ Snap ¬∑ Drag & Drop</div>
  </header>

  <div class="grid">
    <!-- Palette -->
    <section class="card">
      <h2>Bausteine <span class="pill">Drag ins Feld</span></h2>
      <div class="body">
        <div class="tile" data-spawn="circle">
          <div>
            <div class="name">Kreis</div>
            <div class="meta">Grund/Deckfl√§che (Zylinder)</div>
          </div>
          <span class="kbd">ziehen</span>
        </div>
        <div class="row" style="margin-top:10px"></div>

        <div class="tile" data-spawn="rect">
          <div>
            <div class="name">Rechteck</div>
            <div class="meta">Mantelfl√§che (Zylinder)</div>
          </div>
          <span class="kbd">ziehen</span>
        </div>

        <div class="sep"></div>

        <div class="tile" data-spawn="sector">
          <div>
            <div class="name">Kreissektor</div>
            <div class="meta">Mantelfl√§che (Kegel)</div>
          </div>
          <span class="kbd">ziehen</span>
        </div>

        <div class="tile" data-spawn="circle_small">
          <div>
            <div class="name">Kreis (klein)</div>
            <div class="meta">Grundfl√§che (Kegel)</div>
          </div>
          <span class="kbd">ziehen</span>
        </div>

        <div class="sep"></div>

        <div class="hint">
          <b>Steuerung</b><br>
          ‚Ä¢ Teil anklicken = ausw√§hlen<br>
          ‚Ä¢ <span class="kbd">Q</span>/<span class="kbd">E</span> drehen (im 15¬∞-Schritt)<br>
          ‚Ä¢ <span class="kbd">Entf</span> l√∂schen (oder Papierkorb rechts)<br>
          ‚Ä¢ Andocken: Kanten/Marken werden ‚Äûmagnetisch‚Äú
        </div>
      </div>
    </section>

    <!-- Board -->
    <section class="card">
      <h2>Arbeitsfeld <span class="pill" id="taskPill">Aufgabe</span></h2>
      <div class="body">
        <canvas id="cv" width="1200" height="720" aria-label="Baufeld"></canvas>

        <div class="row" style="margin-top:12px">
          <span class="tag"><span class="dot"></span> Zylinder: 2√ó Kreis + 1√ó Rechteck</span>
          <span class="tag"><span class="dot y"></span> Kegel: 1√ó Kreis + 1√ó Kreissektor</span>
          <span class="tag"><span class="dot bad"></span> Kein Live-Check</span>
        </div>

        <div class="sep"></div>

        <div class="row">
          <button class="btn good" id="checkBtn">Pr√ºfen</button>
          <button class="btn tiny" id="nextBtn">N√§chste Aufgabe</button>
          <button class="btn tiny" id="resetBtn">Alles l√∂schen</button>
          <div class="status" id="status" style="flex:1;min-width:240px">Ziehe Bausteine ins Feld und docke sie aneinander an.</div>
        </div>
      </div>
    </section>

    <!-- Side panel -->
    <aside class="card">
      <h2>Lehrer/Info <span class="pill">Optional</span></h2>
      <div class="body">
        <div class="kpi">
          <div class="box"><div class="big" id="score">0</div><div class="lab">Punkte</div></div>
          <div class="box"><div class="big" id="streak">0</div><div class="lab">Streak</div></div>
          <div class="box"><div class="big" id="done">0</div><div class="lab">Aufgaben</div></div>
        </div>

        <div class="sep"></div>

        <div class="row">
          <button class="btn tiny" id="trashBtn">üóëÔ∏è L√∂schen</button>
          <button class="btn tiny" id="toggleSnapBtn">Snap: an</button>
        </div>

        <div class="sep"></div>

        <div class="hint">
          <b>Pr√ºflogik (einfach & robust):</b><br>
          Es wird gepr√ºft, ob die richtigen Teile vorhanden sind <i>und</i> ob sie sinnvoll verbunden sind:
          <br><br>
          <b>Zylinder:</b> Rechteck muss an <i>beide</i> Kreise angedockt sein.<br>
          <b>Kegel:</b> Kreissektor muss am Kreis angedockt sein.
          <br><br>
          Hinweis: Es geht um die Struktur, nicht um perfekte Zeichnungen.
        </div>
      </div>
    </aside>
  </div>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const statusEl = document.getElementById('status');
  const taskPill = document.getElementById('taskPill');
  const checkBtn = document.getElementById('checkBtn');
  const nextBtn = document.getElementById('nextBtn');
  const resetBtn = document.getElementById('resetBtn');
  const trashBtn = document.getElementById('trashBtn');
  const toggleSnapBtn = document.getElementById('toggleSnapBtn');

  const scoreEl = document.getElementById('score');
  const streakEl = document.getElementById('streak');
  const doneEl = document.getElementById('done');

  let score = 0, streak = 0, done = 0;

  // Tasks
  const TASKS = [
    { key: 'cyl', label: 'Baue ein Netz f√ºr einen Zylinder.' },
    { key: 'cone', label: 'Baue ein Netz f√ºr einen Kegel.' }
  ];
  let currentTask = TASKS[Math.floor(Math.random()*TASKS.length)];

  // Interaction state
  let selectedId = null;
  let dragging = null;
  let dragOffset = {x:0,y:0};
  let snapEnabled = true;

  // Board items
  const items = [];
  let nextId = 1;

  // Coordinate system: draw in CSS units (DPR-safe)
  function resizeForDPR(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = cv.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (cv.width !== w || cv.height !== h){
      cv.width = w; cv.height = h;
    }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // CSS units
    return {w: rect.width, h: rect.height};
  }

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

  function toPos(e){
    const r = cv.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  // Basic shapes & anchors (simplified "net" connectors)
  // Each item has anchor points where other items can snap.
  // We'll use a few anchors per shape:
  // - circle: top, bottom, left, right (on circumference)
  // - rect: midpoints of 4 edges
  // - sector: "arc midpoint" + "radius-edge midpoint" (approx)
  // Anchors rotate with the item.

  function rotatePoint(p, angle){
    const c = Math.cos(angle), s = Math.sin(angle);
    return { x: p.x*c - p.y*s, y: p.x*s + p.y*c };
  }

  function anchorsFor(item){
    const a = item.angle;
    const base = [];
    if(item.type === 'circle' || item.type === 'circle_small'){
      const r = item.r;
      base.push({name:'top',    x:0,  y:-r});
      base.push({name:'bottom', x:0,  y:r});
      base.push({name:'left',   x:-r, y:0});
      base.push({name:'right',  x:r,  y:0});
    } else if(item.type === 'rect'){
      const w = item.w, h = item.h;
      base.push({name:'top',    x:0,   y:-h/2});
      base.push({name:'bottom', x:0,   y:h/2});
      base.push({name:'left',   x:-w/2,y:0});
      base.push({name:'right',  x:w/2, y:0});
    } else if(item.type === 'sector'){
      // Approximate anchors:
      // - arc-midpoint (where the sector would meet the circle base when rolled)
      // - straight-edge midpoint (one radius edge)
      const r = item.r;
      base.push({name:'arc',  x:0, y:r});          // arc side
      base.push({name:'edge', x:r*0.6, y:-r*0.2}); // one straight edge-ish
    }
    return base.map(p => {
      const rp = rotatePoint(p, a);
      return { name:p.name, x: item.x + rp.x, y: item.y + rp.y };
    });
  }

  function boundingHit(item, p){
    // simple hit-test in local coords (good enough)
    const dx = p.x - item.x;
    const dy = p.y - item.y;
    const c = Math.cos(-item.angle), s = Math.sin(-item.angle);
    const lx = dx*c - dy*s;
    const ly = dx*s + dy*c;

    if(item.type === 'circle' || item.type === 'circle_small'){
      return Math.hypot(lx, ly) <= item.r;
    }
    if(item.type === 'rect'){
      return Math.abs(lx) <= item.w/2 && Math.abs(ly) <= item.h/2;
    }
    if(item.type === 'sector'){
      // rough: triangle-ish + circle segment ‚Äî we'll allow circular hit
      return Math.hypot(lx, ly) <= item.r;
    }
    return false;
  }

  function spawn(type){
    const {w,h} = resizeForDPR();
    const center = {x: w*0.5, y: h*0.45};

    let item = { id: nextId++, type, x:center.x, y:center.y, angle:0, links:[] };

    if(type === 'circle'){
      item.r = 48;
      item.kind = 'circle';
    } else if(type === 'circle_small'){
      item.r = 38;
      item.kind = 'circle';
    } else if(type === 'rect'){
      item.w = 150; item.h = 70;
      item.kind = 'rect';
    } else if(type === 'sector'){
      item.r = 90;
      item.kind = 'sector';
    }

    items.push(item);
    selectedId = item.id;
    statusEl.textContent = "Teil hinzugef√ºgt. Du kannst es verschieben, drehen (Q/E) und andocken.";
    draw();
  }

  // Palette drag-to-spawn: easiest via pointerdown and clone spawn at release in canvas
  let paletteDragType = null;
  document.querySelectorAll('.tile[data-spawn]').forEach(tile => {
    tile.addEventListener('pointerdown', (e) => {
      paletteDragType = tile.getAttribute('data-spawn');
      tile.setPointerCapture?.(e.pointerId);
      statusEl.textContent = "Zieh ins Arbeitsfeld und lass los.";
    });
    tile.addEventListener('pointerup', () => {
      // If user releases outside canvas, ignore
      paletteDragType = null;
    });
  });

  // Snap
  const SNAP_DIST = 18;

  function trySnap(item){
    if(!snapEnabled) return;

    const myAnch = anchorsFor(item);

    // Find best other anchor near any of my anchors
    let best = null; // {dx,dy, mineName, otherId, otherName, d}
    for(const other of items){
      if(other.id === item.id) continue;
      const oAnch = anchorsFor(other);
      for(const ma of myAnch){
        for(const oa of oAnch){
          const d = Math.hypot(ma.x-oa.x, ma.y-oa.y);
          if(d <= SNAP_DIST && (!best || d < best.d)){
            best = {
              d,
              dx: (oa.x - ma.x),
              dy: (oa.y - ma.y),
              mineName: ma.name,
              otherId: other.id,
              otherName: oa.name
            };
          }
        }
      }
    }

    if(best){
      item.x += best.dx;
      item.y += best.dy;

      // store link (undirected)
      addLink(item.id, best.otherId);
    }
  }

  function addLink(a,b){
    const A = items.find(x=>x.id===a);
    const B = items.find(x=>x.id===b);
    if(!A || !B) return;
    if(!A.links.includes(b)) A.links.push(b);
    if(!B.links.includes(a)) B.links.push(a);
  }

  // Drawing
  function drawGrid(w,h){
    const step = 40;
    ctx.save();
    ctx.globalAlpha = 0.28;
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 1;
    for(let x=0;x<=w;x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    for(let y=0;y<=h;y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawItem(item){
    const isSel = (item.id === selectedId);

    ctx.save();
    ctx.translate(item.x, item.y);
    ctx.rotate(item.angle);

    // style
    ctx.lineWidth = isSel ? 3 : 2;
    ctx.strokeStyle = isSel ? "rgba(96,165,250,.95)" : "rgba(255,255,255,.70)";
    ctx.fillStyle = isSel ? "rgba(96,165,250,.14)" : "rgba(255,255,255,.06)";

    if(item.type === 'circle' || item.type === 'circle_small'){
      ctx.beginPath();
      ctx.arc(0,0,item.r,0,Math.PI*2);
      ctx.fill(); ctx.stroke();

      // tiny "tab" markers (helps snapping visually)
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(255,255,255,.25)";
      ctx.beginPath(); ctx.arc(0,-item.r,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(0,item.r,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-item.r,0,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(item.r,0,4,0,Math.PI*2); ctx.fill();

    } else if(item.type === 'rect'){
      ctx.beginPath();
      ctx.rect(-item.w/2, -item.h/2, item.w, item.h);
      ctx.fill(); ctx.stroke();

      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(255,255,255,.25)";
      ctx.beginPath(); ctx.arc(0,-item.h/2,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(0,item.h/2,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-item.w/2,0,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(item.w/2,0,4,0,Math.PI*2); ctx.fill();

    } else if(item.type === 'sector'){
      // draw sector shape (simple)
      const r = item.r;
      const ang = Math.PI * 0.95; // ~171¬∞
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,r, -ang/2, ang/2);
      ctx.closePath();
      ctx.fill(); ctx.stroke();

      // markers
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(255,255,255,.25)";
      ctx.beginPath(); ctx.arc(0,r,4,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(r*0.6,-r*0.2,4,0,Math.PI*2); ctx.fill();
    }

    // id badge
    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect?.(-18, -22, 36, 20, 6);
    if(!ctx.roundRect){
      // fallback
      ctx.rect(-18, -22, 36, 20);
    }
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = "rgba(230,238,252,.90)";
    ctx.font = "800 12px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(item.id), 0, -12);

    ctx.restore();
  }

  function drawLinks(){
    // show links only subtly (no "solution"); just helps orientation
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = "rgba(52,211,153,.9)";
    ctx.lineWidth = 2;
    const seen = new Set();
    for(const a of items){
      for(const bid of a.links){
        const key = a.id < bid ? `${a.id}-${bid}` : `${bid}-${a.id}`;
        if(seen.has(key)) continue;
        seen.add(key);
        const b = items.find(x=>x.id===bid);
        if(!b) continue;
        ctx.beginPath();
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function draw(){
    const {w,h} = resizeForDPR();
    ctx.clearRect(0,0,w,h);

    // background wash
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.12)";
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    drawGrid(w,h);
    drawLinks();
    for(const it of items) drawItem(it);

    // task title (no spoiler)
    ctx.save();
    ctx.fillStyle = "rgba(230,238,252,.92)";
    ctx.font = "900 16px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.fillText("Aufgabe: " + currentTask.label, 14, 26);
    ctx.restore();
  }

  // Selection helpers
  function itemAt(p){
    for(let i=items.length-1;i>=0;i--){
      if(boundingHit(items[i], p)) return items[i];
    }
    return null;
  }

  function select(id){
    selectedId = id;
    draw();
  }

  function deleteSelected(){
    if(selectedId == null) return;
    const idx = items.findIndex(x=>x.id===selectedId);
    if(idx === -1) return;
    const removed = items[idx].id;
    items.splice(idx,1);
    // remove links referencing removed
    for(const it of items){
      it.links = it.links.filter(x=>x!==removed);
    }
    selectedId = items.length ? items[items.length-1].id : null;
    statusEl.textContent = "Teil gel√∂scht.";
    draw();
  }

  // Pointer events on canvas:
  cv.addEventListener('pointerdown', (e) => {
    const pos = toPos(e);

    // If paletteDragType is active and user releases on canvas area => spawn here (handled on pointerup)
    const hit = itemAt(pos);
    if(hit){
      selectedId = hit.id;
      dragging = hit;
      dragOffset.x = pos.x - hit.x;
      dragOffset.y = pos.y - hit.y;
      cv.setPointerCapture?.(e.pointerId);
      draw();
      return;
    }
    selectedId = null;
    draw();
  });

  cv.addEventListener('pointermove', (e) => {
    if(!dragging) return;
    const {w,h} = resizeForDPR();
    const pos = toPos(e);
    dragging.x = clamp(pos.x - dragOffset.x, 40, w-40);
    dragging.y = clamp(pos.y - dragOffset.y, 40, h-40);
    draw();
  });

  cv.addEventListener('pointerup', (e) => {
    // If user is dragging an existing item, try snap on release
    if(dragging){
      trySnap(dragging);
      dragging = null;
      draw();
      return;
    }

    // If user was dragging from palette and released on canvas, spawn
    if(paletteDragType){
      spawn(paletteDragType);
      paletteDragType = null;
    }
  });

  cv.addEventListener('pointercancel', () => {
    dragging = null;
    paletteDragType = null;
  });

  // Keyboard: rotate/delete
  window.addEventListener('keydown', (e) => {
    if(selectedId == null) return;
    const it = items.find(x=>x.id===selectedId);
    if(!it) return;

    if(e.key.toLowerCase() === 'q'){
      it.angle -= Math.PI/12; // 15¬∞
      draw();
    } else if(e.key.toLowerCase() === 'e'){
      it.angle += Math.PI/12;
      draw();
    } else if(e.key === 'Delete' || e.key === 'Backspace'){
      deleteSelected();
    }
  });

  // Buttons
  resetBtn.addEventListener('click', () => {
    items.splice(0, items.length);
    selectedId = null;
    statusEl.textContent = "Alles gel√∂scht. Neue Bausteine ziehen.";
    draw();
  });

  trashBtn.addEventListener('click', deleteSelected);

  toggleSnapBtn.addEventListener('click', () => {
    snapEnabled = !snapEnabled;
    toggleSnapBtn.textContent = "Snap: " + (snapEnabled ? "an" : "aus");
    statusEl.textContent = snapEnabled ? "Snap ist an." : "Snap ist aus (freier).";
    draw();
  });

  nextBtn.addEventListener('click', () => {
    currentTask = TASKS[Math.floor(Math.random()*TASKS.length)];
    taskPill.textContent = "Aufgabe: " + (currentTask.key === 'cyl' ? "Zylinder" : "Kegel");
    statusEl.textContent = "Neue Aufgabe: " + currentTask.label;
    draw();
  });

  // ---------- Checking logic ----------
  function countTypes(){
    const c = {circle:0, rect:0, sector:0, circle_small:0};
    for(const it of items){
      if(it.type in c) c[it.type]++;
    }
    return c;
  }

  function isConnected(aId, bId){
    const a = items.find(x=>x.id===aId);
    if(!a) return false;
    return a.links.includes(bId);
  }

  function allConnectedGraph(ids){
    // BFS from first id
    if(ids.length <= 1) return true;
    const set = new Set(ids);
    const q = [ids[0]];
    const seen = new Set([ids[0]]);
    while(q.length){
      const cur = q.shift();
      const it = items.find(x=>x.id===cur);
      if(!it) continue;
      for(const nb of it.links){
        if(set.has(nb) && !seen.has(nb)){
          seen.add(nb);
          q.push(nb);
        }
      }
    }
    return seen.size === set.size;
  }

  function checkCylinder(){
    // Need: 2 circles (any size circles allowed, but prefer "circle" pieces) and 1 rect
    const circles = items.filter(it => it.type === 'circle');
    const rects = items.filter(it => it.type === 'rect');

    if(circles.length !== 2 || rects.length !== 1){
      return {ok:false, msg:"F√ºr den Zylinder brauchst du genau 2 Kreise und 1 Rechteck."};
    }

    // Connectedness: rect must link to both circles (directly)
    const rect = rects[0];
    const ok1 = isConnected(rect.id, circles[0].id);
    const ok2 = isConnected(rect.id, circles[1].id);
    if(!(ok1 && ok2)){
      return {ok:false, msg:"Das Rechteck (Mantelfl√§che) muss an beide Kreise angedockt sein."};
    }

    // Also ensure the two circles are not only linked to each other without rect (already covered)
    return {ok:true, msg:"Zylinder-Netz passt: Mantelrechteck ist mit beiden Kreisfl√§chen verbunden."};
  }

  function checkCone(){
    // Need: 1 sector + 1 circle_small (use the dedicated small circle)
    const sectors = items.filter(it => it.type === 'sector');
    const base = items.filter(it => it.type === 'circle_small');

    if(sectors.length !== 1 || base.length !== 1){
      return {ok:false, msg:"F√ºr den Kegel brauchst du genau 1 Kreissektor und 1 kleinen Kreis."};
    }

    // Must be connected
    if(!isConnected(sectors[0].id, base[0].id)){
      return {ok:false, msg:"Der Kreissektor (Mantel) muss am Kreis (Grundfl√§che) angedockt sein."};
    }

    return {ok:true, msg:"Kegel-Netz passt: Kreissektor ist mit der Grundfl√§che verbunden."};
  }

  function addResult(ok, goodMsg, badMsg){
    done++; doneEl.textContent = done;
    if(ok){
      score += 10 + Math.min(10, streak*2);
      streak++;
      statusEl.textContent = "‚úÖ " + goodMsg;
    } else {
      streak = 0;
      statusEl.textContent = "‚ùå " + badMsg;
    }
    scoreEl.textContent = score;
    streakEl.textContent = streak;
  }

  checkBtn.addEventListener('click', () => {
    let res;
    if(currentTask.key === 'cyl'){
      res = checkCylinder();
    } else {
      res = checkCone();
    }

    if(res.ok){
      addResult(true, res.msg + " Neue Aufgabe ‚Ä¶", res.msg);
      // next task
      currentTask = TASKS[Math.floor(Math.random()*TASKS.length)];
      taskPill.textContent = "Aufgabe: " + (currentTask.key === 'cyl' ? "Zylinder" : "Kegel");
      // keep built net (optional). You can uncomment to auto-clear on success:
      // items.splice(0, items.length); selectedId = null;
    } else {
      addResult(false, "‚Äî", res.msg);
    }
    draw();
  });

  // Init pill + first draw
  taskPill.textContent = "Aufgabe: " + (currentTask.key === 'cyl' ? "Zylinder" : "Kegel");
  window.addEventListener('resize', draw);
  draw();
})();
</script>
</body>
</html>