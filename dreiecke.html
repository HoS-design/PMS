<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HoS ¬∑ Dreiecke ‚Äì Winkelarten</title>
  <style>
    :root{
      --bg:#0b1220;
      --ink:#e6eefc;
      --muted:#9fb0d0;
      --line:rgba(255,255,255,.12);
      --a:#60a5fa;
      --b:#34d399;
      --w:#fbbf24;
      --bad:#fb7185;
      --good:#22c55e;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --r:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--ink);
      background:
        radial-gradient(1200px 700px at 12% 10%, rgba(96,165,250,.22), transparent 60%),
        radial-gradient(900px 600px at 90% 18%, rgba(52,211,153,.18), transparent 55%),
        radial-gradient(900px 600px at 30% 95%, rgba(251,191,36,.14), transparent 55%),
        var(--bg);
      min-height:100vh;
    }
    a{color:inherit;text-decoration:none}
    .wrap{max-width:1100px;margin:0 auto;padding:18px 14px 40px}
    header{
      display:flex;gap:14px;align-items:center;
      padding:14px 16px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
    }
    .meme{
      width:74px;height:74px;border-radius:14px;object-fit:cover;
      border:1px solid var(--line);
      background:#0b1020;
    }
    h1{margin:0;font-size:1.25rem;letter-spacing:.2px}
    .sub{margin:4px 0 0;color:var(--muted);font-size:.95rem}
    .toplink{
      margin-left:auto;
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--muted);
      font-size:.9rem;
      white-space:nowrap;
    }
    .toplink:hover{background:rgba(255,255,255,.06)}
    .badge{
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--muted);
      font-size:.9rem;
      white-space:nowrap;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
      margin-top:14px;
    }
    @media (max-width: 900px){
      .grid{grid-template-columns:1fr}
      .badge{display:none}
    }

    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .switch{
      display:flex;gap:8px;flex-wrap:wrap;align-items:center;
      padding:10px 14px;
      border-bottom:1px solid var(--line);
      background:rgba(0,0,0,.12);
    }
    .pill{
      font-size:.85rem;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--muted);
    }
    .btn{
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--ink);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:700;
      transition:.15s transform,.15s background;
      user-select:none;
    }
    .btn:hover{transform:translateY(-1px);background:rgba(255,255,255,.06)}
    .btn:active{transform:translateY(0px)}
    .btn.active{
      background:rgba(96,165,250,.12);
      border-color:rgba(96,165,250,.55);
    }
    .btn.primary{border-color:rgba(96,165,250,.5);box-shadow:0 0 0 3px rgba(96,165,250,.12) inset}
    .btn.good{border-color:rgba(34,197,94,.45)}
    .btn.warn{border-color:rgba(251,191,36,.45)}
    .btn.bad{border-color:rgba(251,113,133,.45)}
    .btn.tiny{padding:8px 10px;border-radius:12px;font-size:.92rem}

    .body{padding:12px 14px}
    canvas{
      width:100%;
      height:auto;
      background:linear-gradient(180deg, rgba(0,0,0,.16), rgba(0,0,0,.24));
      border:1px solid var(--line);
      border-radius:16px;
      display:block;
      touch-action:none;
    }

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .row + .row{margin-top:10px}
    .status{
      padding:10px 12px;border-radius:14px;border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:.95rem;
      flex:1;
      min-width:220px;
    }
    .tag{
      display:inline-flex;gap:6px;align-items:center;
      padding:6px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--muted);font-size:.9rem;
    }
    .dot{width:8px;height:8px;border-radius:99px;background:var(--a);display:inline-block}
    .dot.b{background:var(--b)}
    .dot.w{background:var(--w)}
    .sep{height:1px;background:var(--line);margin:12px 0}

    .kpi{
      display:grid;grid-template-columns:repeat(3,1fr);
      gap:10px;
    }
    .kpi .box{
      padding:10px 12px;border-radius:16px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
    }
    .kpi .big{font-size:1.2rem;font-weight:800;color:#eaf2ff}
    .kpi .lab{font-size:.85rem;color:var(--muted)}
    .hint{color:var(--muted);font-size:.92rem;line-height:1.35}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <img src="chatistthisreal.png" onerror="this.onerror=null;this.src='chatisthisreal.png';" alt="Chat is this real?" class="meme">
      <div>
        <h1>Dreiecke ¬∑ Winkelart √ºben <span style="color:var(--b)">HoS</span></h1>
        <div class="sub">Erkennen & Herstellen: spitzwinkelig ¬∑ rechtwinkelig ¬∑ stumpfwinkelig</div>
      </div>
      <a class="toplink" href="Index.html">‚¨ÖÔ∏é Startseite</a>
      <div class="badge">üìê Mathe ¬∑ Interaktiv</div>
    </header>

    <div class="grid">
      <section class="card">
        <div class="switch">
          <button class="btn active" id="modeRecognize">1) Erkennen</button>
          <button class="btn" id="modeBuild">2) Herstellen</button>
          <span class="pill" id="taskPill">Aufgabe</span>
          <span class="pill" id="teacherPill" style="display:none">Lehrer-Modus</span>
        </div>

        <div class="body">
          <canvas id="cv" width="980" height="640" aria-label="Dreieck-Canvas"></canvas>

          <div class="row" style="margin-top:12px">
            <span class="tag"><span class="dot"></span> Punkt A</span>
            <span class="tag"><span class="dot b"></span> Punkt B</span>
            <span class="tag"><span class="dot w"></span> Punkt C</span>
            <div class="status" id="status">Modus ‚ÄûErkennen‚Äú: nur ausw√§hlen (Punkte sind gesperrt). Modus ‚ÄûHerstellen‚Äú: Punkte ziehen & pr√ºfen.</div>
          </div>

          <div class="sep"></div>

          <div class="row" id="answerRow">
            <button class="btn primary" data-ans="acute">Spitzwinkelig</button>
            <button class="btn warn" data-ans="right">Rechtwinkelig</button>
            <button class="btn bad" data-ans="obtuse">Stumpfwinkelig</button>
            <button class="btn tiny" id="nextBtn">N√§chste Aufgabe</button>
          </div>

          <div class="row" id="buildRow" style="display:none">
            <button class="btn good" id="checkBuild">Pr√ºfen</button>
            <button class="btn tiny" id="resetBuild">Neu anordnen</button>
            <button class="btn tiny" id="nextBuild">N√§chste Vorgabe</button>
            <span class="hint">Ziehe die Punkte. Ziel: die geforderte Winkelart herstellen.</span>
          </div>

          <div class="sep"></div>
          <div class="hint">
            <b>Hinweis:</b> Keine L√∂sung wird live angezeigt. (Lehrer-Modus: Taste <b>L</b>.)
          </div>
        </div>
      </section>

      <aside class="card">
        <div class="body">
          <div class="kpi">
            <div class="box"><div class="big" id="score">0</div><div class="lab">Punkte</div></div>
            <div class="box"><div class="big" id="streak">0</div><div class="lab">Streak</div></div>
            <div class="box"><div class="big" id="done">0</div><div class="lab">Aufgaben</div></div>
          </div>

          <div class="sep"></div>

          <div class="row">
            <button class="btn tiny" id="toggleGrid">Raster: an/aus</button>
            <button class="btn tiny" id="newTriangle">Neues Dreieck</button>
          </div>

          <div class="row">
            <button class="btn tiny" id="levelEasy">Level: easy</button>
            <button class="btn tiny" id="levelMed">Level: medium</button>
            <button class="btn tiny" id="levelHard">Level: hard</button>
          </div>

          <div class="sep"></div>

          <div class="hint">
            <b>Lehrer-Modus (L):</b> zeigt Winkelwerte & Klassifikation im Canvas an (f√ºr Kontrolle/Erkl√§rung). Standard: aus.
          </div>
        </div>
      </aside>
    </div>
  </div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  // UI
  const modeRecognizeBtn = document.getElementById('modeRecognize');
  const modeBuildBtn = document.getElementById('modeBuild');
  const answerRow = document.getElementById('answerRow');
  const buildRow = document.getElementById('buildRow');
  const nextBtn = document.getElementById('nextBtn');
  const checkBuild = document.getElementById('checkBuild');
  const resetBuild = document.getElementById('resetBuild');
  const nextBuild = document.getElementById('nextBuild');
  const taskPill = document.getElementById('taskPill');
  const teacherPill = document.getElementById('teacherPill');

  const statusEl = document.getElementById('status');
  const scoreEl = document.getElementById('score');
  const streakEl = document.getElementById('streak');
  const doneEl = document.getElementById('done');

  const toggleGridBtn = document.getElementById('toggleGrid');
  const newTriBtn = document.getElementById('newTriangle');
  const lvlEasy = document.getElementById('levelEasy');
  const lvlMed = document.getElementById('levelMed');
  const lvlHard = document.getElementById('levelHard');

  // State
  let mode = 'recognize';
  let showGrid = true;
  let level = 'medium';
  let score = 0, streak = 0, done = 0;

  let teacherMode = false; // toggled by "L"
  const EPS_RIGHT = 2.0;   // degrees tolerance for right angle

  // Work in CSS coords ALWAYS
  const P = {
    A: {x: 140, y: 120, c: '#60a5fa', name: 'A'},
    B: {x: 420, y: 170, c: '#34d399', name: 'B'},
    C: {x: 260, y: 360, c: '#fbbf24', name: 'C'}
  };
  let dragging = null;

  const pointRadius = 14;

  // Tasks
  const types = [
    {key:'acute',  label:'Spitzwinkelig'},
    {key:'right',  label:'Rechtwinkelig'},
    {key:'obtuse', label:'Stumpfwinkelig'}
  ];
  let currentExpected = null;

  // Helpers
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const dist = (p,q) => Math.hypot(p.x-q.x, p.y-q.y);

  function angleFromSides(a, b, c){
    const cosA = clamp((b*b + c*c - a*a) / (2*b*c), -1, 1);
    return Math.acos(cosA) * 180/Math.PI;
  }

  function triangleAngles(A,B,C){
    const ab = dist(A,B);
    const bc = dist(B,C);
    const ca = dist(C,A);
    const angA = angleFromSides(bc, ab, ca);
    const angB = angleFromSides(ca, ab, bc);
    const angC = 180 - angA - angB;
    return {angA, angB, angC, ab, bc, ca};
  }

  function classifyByAngles(angles){
    const maxAng = Math.max(angles.angA, angles.angB, angles.angC);
    if (Math.abs(maxAng - 90) <= EPS_RIGHT) return 'right';
    if (maxAng > 90 + EPS_RIGHT) return 'obtuse';
    return 'acute';
  }

  function prettyType(key){
    return types.find(t=>t.key===key)?.label ?? key;
  }

  function canvasCSSSize(){
    const rect = cv.getBoundingClientRect();
    return {w: rect.width, h: rect.height};
  }

  function area2(A,B,C){
    return Math.abs((B.x-A.x)*(C.y-A.y) - (B.y-A.y)*(C.x-A.x));
  }

  function randInt(lo, hi){ return Math.floor(Math.random()*(hi-lo+1))+lo; }

  function randomPointCSS(margin=60){
    const {w,h} = canvasCSSSize();
    return {
      x: randInt(margin, Math.max(margin+1, Math.floor(w - margin))),
      y: randInt(margin, Math.max(margin+1, Math.floor(h - margin)))
    };
  }

  function generateTriangleOfType(wanted){
    const tries = 3000;
    for(let i=0;i<tries;i++){
      const p1 = randomPointCSS();
      const p2 = randomPointCSS();
      const p3 = randomPointCSS();
      if(area2(p1,p2,p3) < 14000) continue;

      const ang = triangleAngles(p1,p2,p3);
      const cls = classifyByAngles(ang);
      const maxAng = Math.max(ang.angA, ang.angB, ang.angC);
      const nearRight = Math.abs(maxAng-90);

      if (wanted === 'right'){
        if (nearRight > (level==='easy' ? 0.7 : level==='medium' ? 1.6 : 2.0)) continue;
      } else if (wanted === 'obtuse'){
        if (cls !== 'obtuse') continue;
        if(level==='easy' && maxAng < 112) continue;
        if(level==='hard' && maxAng > 112) continue;
      } else {
        if (cls !== 'acute') continue;
        if(level==='easy' && maxAng > 80) continue;
        if(level==='hard' && maxAng < 80) continue;
      }
      return {p1,p2,p3, cls, ang};
    }

    const {w,h} = canvasCSSSize();
    const p1 = {x: w*0.2, y: h*0.25};
    const p2 = {x: w*0.8, y: h*0.30};
    const p3 = {x: w*0.45, y: h*0.80};
    const ang = triangleAngles(p1,p2,p3);
    return {p1,p2,p3, cls: classifyByAngles(ang), ang};
  }

  function placeTriangle(g){
    P.A.x = g.p1.x; P.A.y = g.p1.y;
    P.B.x = g.p2.x; P.B.y = g.p2.y;
    P.C.x = g.p3.x; P.C.y = g.p3.y;
  }

  function newRecognizeTask(){
    const wanted = types[randInt(0,2)].key;
    const g = generateTriangleOfType(wanted);
    placeTriangle(g);
    currentExpected = g.cls;
    statusEl.textContent = "Modus ‚ÄûErkennen‚Äú: Punkte sind gesperrt. W√§hle die richtige Winkelart.";
    draw();
  }

  function newBuildTask(){
    currentExpected = types[randInt(0,2)].key;
    const g = generateTriangleOfType('acute');
    placeTriangle(g);
    statusEl.textContent = "Vorgabe: " + prettyType(currentExpected) + " ‚Äî Ziehe die Punkte und dr√ºcke ‚ÄûPr√ºfen‚Äú.";
    draw();
  }

  function setMode(m){
    mode = m;
    const rec = (mode === 'recognize');
    modeRecognizeBtn.classList.toggle('active', rec);
    modeBuildBtn.classList.toggle('active', !rec);
    answerRow.style.display = rec ? '' : 'none';
    buildRow.style.display  = rec ? 'none' : '';
    taskPill.textContent = rec ? 'Aufgabe: Erkennen' : 'Aufgabe: Herstellen';

    // UX: cursor indicates whether dragging is possible
    cv.style.cursor = (mode === 'build') ? 'grab' : 'default';

    if(rec) newRecognizeTask(); else newBuildTask();
  }

  function addResult(ok, msgOK, msgBad){
    done++; doneEl.textContent = done;
    if(ok){
      score += 10 + Math.min(10, streak*2);
      streak++;
      statusEl.textContent = "‚úÖ " + msgOK;
    } else {
      streak = 0;
      statusEl.textContent = "‚ùå " + msgBad;
    }
    scoreEl.textContent = score;
    streakEl.textContent = streak;
  }

  // Drawing
  function resizeForDPR(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = cv.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (cv.width !== w || cv.height !== h){
      cv.width = w; cv.height = h;
    }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function drawGrid(){
    const {w,h} = canvasCSSSize();
    const step = 40;
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 1;
    for(let x=0;x<=w;x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    for(let y=0;y<=h;y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawTriangle(){
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,.75)";
    ctx.fillStyle = "rgba(96,165,250,.10)";
    ctx.beginPath();
    ctx.moveTo(P.A.x,P.A.y);
    ctx.lineTo(P.B.x,P.B.y);
    ctx.lineTo(P.C.x,P.C.y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawPoint(p){
    ctx.save();
    ctx.beginPath();
    ctx.arc(p.x,p.y, 18, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,.10)";
    ctx.fill();

    ctx.beginPath();
    ctx.arc(p.x,p.y, 10, 0, Math.PI*2);
    ctx.fillStyle = p.c;
    ctx.fill();

    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(230,238,252,.92)";
    ctx.fillText(p.name, p.x + 12, p.y - 12);
    ctx.restore();
  }

  function drawOverlayTeacher(){
    if(!teacherMode) return;
    const ang = triangleAngles(P.A,P.B,P.C);
    const cls = classifyByAngles(ang);

    ctx.save();
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(230,238,252,.92)";
    const txt = `Lehrer-Modus: ${prettyType(cls)} ¬∑ Winkel ${ang.angA.toFixed(1)}¬∞ / ${ang.angB.toFixed(1)}¬∞ / ${ang.angC.toFixed(1)}¬∞`;
    ctx.fillText(txt, 16, 26);
    ctx.restore();
  }

  function draw(){
    resizeForDPR();
    const {w,h} = canvasCSSSize();
    ctx.clearRect(0,0,w,h);

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.12)";
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    if(showGrid) drawGrid();
    drawTriangle();
    drawPoint(P.A); drawPoint(P.B); drawPoint(P.C);
    drawOverlayTeacher();
  }

  // Pointer interaction (ONLY in build mode)
  function toCSSCoords(evt){
    const rect = cv.getBoundingClientRect();
    return { x: (evt.clientX - rect.left), y: (evt.clientY - rect.top) };
  }
  function hit(p, x, y){
    return Math.hypot(p.x-x, p.y-y) <= (pointRadius + 8);
  }

  function onDown(e){
    const pos = toCSSCoords(e);
    dragging = hit(P.A,pos.x,pos.y) ? P.A :
               hit(P.B,pos.x,pos.y) ? P.B :
               hit(P.C,pos.x,pos.y) ? P.C : null;
    if(dragging){
      cv.style.cursor = 'grabbing';
      cv.setPointerCapture?.(e.pointerId);
    }
  }
  function onMove(e){
    if(!dragging) return;
    const pos = toCSSCoords(e);
    const {w,h} = canvasCSSSize();
    dragging.x = clamp(pos.x, 40, w-40);
    dragging.y = clamp(pos.y, 40, h-40);
    draw();
  }
  function onUp(){
    dragging = null;
    cv.style.cursor = (mode === 'build') ? 'grab' : 'default';
  }

  // Gate events by mode
  cv.addEventListener('pointerdown', (e) => { if(mode === 'build') onDown(e); });
  cv.addEventListener('pointermove', (e) => { if(mode === 'build') onMove(e); });
  cv.addEventListener('pointerup',   (e) => { if(mode === 'build') onUp(e); });
  cv.addEventListener('pointercancel', (e) => { if(mode === 'build') onUp(e); });

  window.addEventListener('resize', () => {
    const {w,h} = canvasCSSSize();
    [P.A,P.B,P.C].forEach(p=>{
      p.x = clamp(p.x, 40, w-40);
      p.y = clamp(p.y, 40, h-40);
    });
    draw();
  });

  // Answers
  document.querySelectorAll('#answerRow .btn[data-ans]').forEach(btn=>{
    btn.addEventListener('click', () => {
      if(mode !== 'recognize') return;
      const chosen = btn.getAttribute('data-ans');
      const ok = (chosen === currentExpected);
      addResult(ok, "Richtig! N√§chste Aufgabe ‚Ä¶", "Leider falsch. Versuch‚Äôs weiter!");
      if(ok) newRecognizeTask();
    });
  });

  nextBtn.addEventListener('click', () => {
    if(mode !== 'recognize') return;
    newRecognizeTask();
  });

  checkBuild.addEventListener('click', () => {
    if(mode !== 'build') return;
    const cls = classifyByAngles(triangleAngles(P.A,P.B,P.C));
    const ok = (cls === currentExpected);
    addResult(ok, "Passt! Neue Vorgabe ‚Ä¶", "Noch nicht. Zieh die Punkte anders und pr√ºfe erneut.");
    if(ok) newBuildTask();
    draw();
  });

  resetBuild.addEventListener('click', () => {
    if(mode !== 'build') return;
    const g = generateTriangleOfType('acute');
    placeTriangle(g);
    statusEl.textContent = "Vorgabe: " + prettyType(currentExpected) + " ‚Äî Ziehe die Punkte und dr√ºcke ‚ÄûPr√ºfen‚Äú.";
    draw();
  });

  nextBuild.addEventListener('click', () => {
    if(mode !== 'build') return;
    newBuildTask();
  });

  // Mode buttons
  modeRecognizeBtn.addEventListener('click', () => setMode('recognize'));
  modeBuildBtn.addEventListener('click', () => setMode('build'));

  // Settings
  toggleGridBtn.addEventListener('click', () => {
    showGrid = !showGrid;
    toggleGridBtn.textContent = "Raster: " + (showGrid ? "an" : "aus");
    draw();
  });

  newTriBtn.addEventListener('click', () => {
    if(mode === 'recognize') newRecognizeTask();
    else newBuildTask();
  });

  function setLevel(l){
    level = l;
    lvlEasy.classList.toggle('active', l==='easy');
    lvlMed.classList.toggle('active', l==='medium');
    lvlHard.classList.toggle('active', l==='hard');
  }
  lvlEasy.addEventListener('click', ()=>{setLevel('easy'); newTriBtn.click();});
  lvlMed.addEventListener('click', ()=>{setLevel('medium'); newTriBtn.click();});
  lvlHard.addEventListener('click', ()=>{setLevel('hard'); newTriBtn.click();});

  // Teacher mode toggle
  function toggleTeacher(){
    teacherMode = !teacherMode;
    teacherPill.style.display = teacherMode ? '' : 'none';
    draw();
  }
  window.addEventListener('keydown', (e) => {
    if(e.key.toLowerCase() === 'l') toggleTeacher();
  });

  // Init
  setLevel('medium');
  setMode('recognize');
  draw();
})();
</script>
</body>
</html>