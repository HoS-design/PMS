<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
<<<<<<< HEAD
  <title>HoS ¬∑ 3D Wasserpistole (Impact + Hint nach 2 Fehlern)</title>
  <style>
    :root{
      --ink:#e7eefc; --muted:#b8c2dd; --line: rgba(255,255,255,.14);
=======
  <title>HoS ¬∑ 3D Wasserpistolen-Spiel (Satz-Leiste, sch√∂n & hell)</title>
  <style>
    :root{
      --bg:#0b1220;
      --ink:#e7eefc;
      --muted:#b8c2dd;
      --line: rgba(255,255,255,.14);
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); color:var(--ink);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(124,58,237,.28), transparent 60%),
        radial-gradient(900px 600px at 80% 20%, rgba(34,197,94,.20), transparent 55%),
        radial-gradient(1000px 700px at 50% 110%, rgba(245,158,11,.12), transparent 55%),
        #09101d;
      height:100vh; overflow:hidden; user-select:none;
    }
    canvas{display:block;width:100%;height:100%}

    .hud{position:fixed; inset:0; pointer-events:none; display:flex; flex-direction:column; padding:14px; gap:10px;}
    .topbar{display:flex; gap:10px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;}
    .pill{
<<<<<<< HEAD
      pointer-events:auto; display:inline-flex; gap:10px; align-items:center; flex-wrap:wrap;
=======
      pointer-events:auto;
      display:inline-flex; gap:10px; align-items:center; flex-wrap:wrap;
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      padding:10px 12px; border-radius:999px; border:1px solid var(--line);
      background: rgba(0,0,0,.22); box-shadow: var(--shadow); backdrop-filter: blur(10px);
      font-size:13px; color:var(--muted);
    }
    .pill b{color:var(--ink)}
    .btn{
<<<<<<< HEAD
      pointer-events:auto; appearance:none; border:1px solid var(--line); background: rgba(255,255,255,.06);
=======
      pointer-events:auto;
      appearance:none; border:1px solid var(--line); background: rgba(255,255,255,.06);
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      color:var(--ink); padding:10px 12px; border-radius:14px; cursor:pointer;
      font-size:13px; box-shadow: 0 12px 35px rgba(0,0,0,.22);
    }
    .btn:hover{ background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.22); }

<<<<<<< HEAD
    .center{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:24px; height:24px; display:grid; place-items:center; opacity:.92;}
=======
    .center{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      width:24px; height:24px; display:grid; place-items:center; opacity:.92;
    }
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    .cross{width:24px; height:24px; position:relative;}
    .cross:before,.cross:after{
      content:""; position:absolute; left:50%; top:50%;
      background: rgba(231,238,252,.92);
      transform:translate(-50%,-50%);
      border-radius:2px;
      box-shadow: 0 0 0 4px rgba(255,255,255,.06);
    }
    .cross:before{ width:22px; height:2px; }
    .cross:after{ width:2px; height:22px; }

    .bottom{margin-top:auto; display:flex; justify-content:center;}
    .card{
      pointer-events:auto;
      width:min(1100px, calc(100vw - 24px));
      border:1px solid var(--line);
      background: rgba(0,0,0,.24);
      box-shadow: var(--shadow);
      border-radius:22px;
      padding:12px 14px;
      backdrop-filter: blur(10px);
    }
<<<<<<< HEAD
    .title{display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:8px;}
=======
    .title{
      display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap;
      align-items:center; margin-bottom:8px;
    }
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    .title h1{margin:0; font-size:14px; letter-spacing:.25px; text-transform:uppercase; color:var(--muted);}
    .sentence{margin:0; font-size:18px; line-height:1.35; color:var(--ink);}
    .hint{margin:8px 0 0; font-size:12px; color:var(--muted); line-height:1.5;}
    .kbd{
      font-family:var(--mono); font-size:11px; padding:4px 6px; border-radius:10px;
      border:1px solid var(--line); background: rgba(0,0,0,.22); color:var(--ink);
    }
    .bar{height:10px; border-radius:999px; border:1px solid var(--line); background: rgba(0,0,0,.18); overflow:hidden; margin-top:10px;}
    .fill{height:100%; width:0%; background: linear-gradient(90deg, rgba(34,197,94,.85), rgba(124,58,237,.85));}

<<<<<<< HEAD
    .overlay{position:fixed; inset:0; display:grid; place-items:center; background: rgba(0,0,0,.45); backdrop-filter: blur(8px);}
=======
    .overlay{
      position:fixed; inset:0; display:grid; place-items:center;
      background: rgba(0,0,0,.45); backdrop-filter: blur(8px);
    }
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    .panel{
      width:min(780px, calc(100vw - 24px));
      border:1px solid var(--line);
      border-radius:26px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      box-shadow: var(--shadow);
      padding:18px 18px 16px;
      text-align:left;
    }
    .badge{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 10px; border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color:var(--muted); font-size:12px;
    }
    .panelHead{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:10px;}
    .panel h2{margin:8px 0 8px; font-size:22px; letter-spacing:.2px;}
    .panel p{margin:0 0 10px; color:var(--muted); line-height:1.55;}
    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px;}
    @media(max-width:760px){ .grid2{grid-template-columns:1fr} }
    .note{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius:18px;
      padding:12px;
      color:var(--muted);
      font-size:13px;
      line-height:1.5;
    }
    .note b{color:var(--ink)}

    .flash{
      position:fixed; left:50%; top:14px; transform:translateX(-50%);
      padding:10px 12px; border-radius:14px; border:1px solid var(--line);
      background: rgba(0,0,0,.35); color:var(--ink); font-size:13px; box-shadow: var(--shadow);
      opacity:0; pointer-events:none; transition: opacity .15s ease, transform .15s ease;
      backdrop-filter: blur(10px);
    }
    .flash.show{opacity:1; transform:translateX(-50%) translateY(-2px);}
    .good{color:rgba(190,255,215,.95)}
    .bad{color:rgba(255,200,200,.95)}
  </style>
</head>

<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="topbar">
      <div class="pill">
        <span>üî´ Wasserpistole (3D)</span>
        <span>Munition: <b id="ammo">12</b>/<span id="ammoMax">12</span> <span class="kbd">R</span></span>
        <span>Score: <b id="score">0</b></span>
        <span>Streak: <b id="streak">0</b></span>
        <span>Fails: <b id="fails">0</b></span>
        <span>Level: <b id="level">1</b></span>
        <span id="bossTag" style="display:none;color:rgba(245,158,11,.95)">üëë BOSS</span>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn" id="homeBtn">üè† Startseite</button>
        <button class="btn" id="resetBtn">üîÅ Neustart</button>
      </div>
    </div>

    <div class="center"><div class="cross"></div></div>

    <div class="bottom">
      <div class="card">
        <div class="title">
          <h1 id="missionTitle">Auftrag: Schie√üe das fehlerhafte Wort aus dem Satz heraus</h1>
          <div class="pill" style="padding:8px 10px; font-size:12px;">
<<<<<<< HEAD
            WASD ¬∑ Maus ¬∑ Klick schie√üen ¬∑ Wasserstrahl ¬∑ Impact ¬∑ Hint nach 2 Fehlversuchen
=======
            WASD bewegen ¬∑ Maus schauen ¬∑ Klick schie√üen ¬∑ ESC frei ¬∑ Wort fliegt weg + Wassertrail
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
          </div>
        </div>
        <p class="sentence" id="sentence">‚Äî</p>
        <p class="hint" id="hint">Tipp: Genau <b>1 Wort</b> ist falsch. (Hint nach 2 Fehlversuchen)</p>
        <div class="bar"><div class="fill" id="progress"></div></div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel">
      <div class="panelHead">
        <span class="badge">HoS ¬∑ 3D Spiel ¬∑ Deutsch</span>
        <span class="badge">Laptop Mode ‚úÖ</span>
      </div>
<<<<<<< HEAD
      <h2>Jetzt wirklich ein Deutsch-Spiel üòÑ</h2>
      <p>
        Das falsche Wort hat <b>keine Markierung</b> ‚Äì du musst lesen.
        Nach <b>2 Fehlversuchen</b> kommt ein kurzer Hint (Glow-Puls am richtigen Wort).
=======
      <h2>Wasserpistolen-Entspannung (hell & lesbar) üòÑ</h2>
      <p>
        Im 3D-Raum siehst du den Satz als zusammenh√§ngende Wort-Leiste.
        Schie√üe das falsche Wort <b>aus dem Satz heraus</b> ‚Äì es fliegt weg und hinterl√§sst eine L√ºcke.
        <br><br>
        <b>Bonus:</b> Am Ende kommt eine Bossrunde mit <b>2 Fehlern</b> (beide treffen = +30).
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      </p>
      <div class="grid2">
        <div class="note">
          <b>Steuerung</b><br>
          ‚Ä¢ <span class="kbd">Klick</span> schie√üen<br>
<<<<<<< HEAD
          ‚Ä¢ <span class="kbd">W</span> vorw√§rts / <span class="kbd">S</span> r√ºckw√§rts<br>
=======
          ‚Ä¢ <span class="kbd">WASD</span> laufen (W vorw√§rts ‚úÖ)<br>
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
          ‚Ä¢ Maus schauen (Pointer Lock)<br>
          ‚Ä¢ <span class="kbd">R</span> nachladen<br>
          ‚Ä¢ <span class="kbd">ESC</span> Maus frei
        </div>
        <div class="note">
          <b>Punkte</b><br>
          ‚úÖ richtig: +10 + Streak-Bonus<br>
<<<<<<< HEAD
          ‚ùå falsch: ‚àí5 (au√üer √úbungsmodus) + Streak reset<br>
          üîé Hint: nach 2 Fehlversuchen (kurz)
=======
          ‚ùå falsch: ‚àí5, Streak = 0 (au√üer √úbungsmodus)<br>
          üëë Boss: 2 Fehler ‚Üí beide treffen = <b>+30</b><br>
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
        </div>
      </div>
      <div style="display:flex; gap:10px; margin-top:14px; flex-wrap:wrap;">
        <button class="btn" id="startBtn">‚ñ∂ Start</button>
        <button class="btn" id="practiceBtn">üß™ √úbungsmodus (ohne Abzug)</button>
      </div>
    </div>
  </div>

  <div class="flash" id="flash"></div>

  <script type="module">
    import * as THREE from "./lib/three.module.js";

    // -----------------------------
    // Aufgaben
    // -----------------------------
    const TASKS = [
<<<<<<< HEAD
      { sentence: "Die Maschiene ist sehr laut, aber zuverl√§ssig.", wrong: "Maschiene" },
      { sentence: "Er giebt mir jeden Tag eine neue Aufgabe.", wrong: "giebt" },
      { sentence: "Ich glaube, das du heute fr√ºher kommst.", wrong: "das" },
      { sentence: "Im winter tragen viele Menschen warme Jacken.", wrong: "winter" },
      { sentence: "Ich habe dich vieleicht falsch verstanden.", wrong: "vieleicht" },
      { sentence: "Das ist das Beste, was ich je gesehen habe, seid gestern.", wrong: "seid" },
      { sentence: "Er war ent√§uscht von dem Ergebnis.", wrong: "ent√§uscht" },
      { sentence: "Die maschine steht heute in der Werkstatt.", wrong: "maschine" },
      { sentence: "Sie hat das Problem wiederspiegeln wollen, aber es gelang nicht.", wrong: "wiederspiegeln" },
      { sentence: "Wir sind Morgen um acht Uhr fertig.", wrong: "Morgen" },
      { sentence: "Bitte stelle die Tasse Vorsichtig auf den Tisch.", wrong: "Vorsichtig" },
      { sentence: "Gestern ging ich Schnell nach Hause, weil es regnete.", wrong: "Schnell" },
    ];

    const BOSS_TASKS = [
      { sentence: "Ich glaube, das du die Maschiene schon morgen reparierst.", wrongs: ["das", "Maschiene"] },
      { sentence: "Im winter ist die Maschiene oft kaputt, aber das passiert selten.", wrongs: ["winter", "Maschiene"] }
=======
      { sentence: "Gestern ging ich Schnell nach Hause, weil es regnete.", wrong: "Schnell", note: "Adverb klein: schnell." },
      { sentence: "Bitte stelle die Tasse Vorsichtig auf den Tisch.", wrong: "Vorsichtig", note: "Adverb klein: vorsichtig." },
      { sentence: "Wir sind Morgen um acht Uhr fertig.", wrong: "Morgen", note: "Zeitadverb klein: morgen." },
      { sentence: "Die maschine steht heute in der Werkstatt.", wrong: "maschine", note: "Nomen gro√ü: Maschine." },
      { sentence: "Im winter tragen viele Menschen warme Jacken.", wrong: "winter", note: "Nomen gro√ü: Winter." },
      { sentence: "Er giebt mir jeden Tag eine neue Aufgabe.", wrong: "giebt", note: "Richtig: gibt." },
      { sentence: "Die Maschiene ist sehr laut, aber zuverl√§ssig.", wrong: "Maschiene", note: "Richtig: Maschine." },
      { sentence: "Ich glaube, das du heute fr√ºher kommst.", wrong: "das", note: "Konjunktion: dass." },
      { sentence: "Ich habe dich vieleicht falsch verstanden.", wrong: "vieleicht", note: "Richtig: vielleicht." },
      { sentence: "Er war ent√§uscht von dem Ergebnis.", wrong: "ent√§uscht", note: "Richtig: entt√§uscht." },
      { sentence: "Das ist das Beste, was ich je gesehen habe, seid gestern.", wrong: "seid", note: "Zeitangabe: seit." },
      { sentence: "Sie hat das Problem wiederspiegeln wollen, aber es gelang nicht.", wrong: "wiederspiegeln", note: "Richtig: widerspiegeln." }
    ];

    const BOSS_TASKS = [
      { sentence: "Ich glaube, das du die Maschiene schon morgen reparierst.", wrongs: ["das", "Maschiene"], note: "dass ¬∑ Maschine" },
      { sentence: "Im winter ist die Maschiene oft kaputt, aber das passiert selten.", wrongs: ["winter", "Maschiene"], note: "Winter ¬∑ Maschine" }
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    ];

    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
      return arr;
    }
    shuffle(TASKS); shuffle(BOSS_TASKS);

    // -----------------------------
    // State + UI
    // -----------------------------
    const state = {
      idx: 0, score: 0, streak: 0,
      ammoMax: 12, ammo: 12,
      practice: false,
      done: 0, total: TASKS.length,
      locked: false, paused: true,
      level: 1,
<<<<<<< HEAD
      bossActive: false, bossHitsRemaining: 0, bossBonusAwarded: false,
      failsThisSentence: 0,
      bossIdx: 0
=======
      bossActive: false,
      bossHitsRemaining: 0,
      bossBonusAwarded: false
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    };

    const $ = (q)=>document.querySelector(q);
    const ammoEl = $("#ammo"), ammoMaxEl = $("#ammoMax");
    const scoreEl = $("#score"), streakEl = $("#streak");
    const failsEl = $("#fails"), levelEl = $("#level");
    const sentenceEl = $("#sentence"), hintEl = $("#hint");
    const overlay = $("#overlay"), flash = $("#flash");
    const progress = $("#progress");
    const bossTag = $("#bossTag"), missionTitle = $("#missionTitle");

    ammoMaxEl.textContent = String(state.ammoMax);

    function flashMsg(msg, good=true){
      flash.textContent = msg;
      flash.classList.add("show");
      flash.classList.toggle("good", good);
      flash.classList.toggle("bad", !good);
      clearTimeout(flash._t);
      flash._t = setTimeout(()=>flash.classList.remove("show"), 950);
    }

    function uiUpdate(){
      ammoEl.textContent = String(state.ammo);
      scoreEl.textContent = String(state.score);
      streakEl.textContent = String(state.streak);
      failsEl.textContent = String(state.failsThisSentence);
      levelEl.textContent = String(state.level);

      const denom = state.total + 1;
      const numer = state.done + (state.bossActive ? 1 : 0);
      progress.style.width = `${Math.round((numer/denom)*100)}%`;

      bossTag.style.display = state.bossActive ? "inline" : "none";
      missionTitle.textContent = state.bossActive
<<<<<<< HEAD
        ? `üëë Bossrunde: ${state.bossHitsRemaining} Fehler √ºbrig`
=======
        ? `üëë Bossrunde: Schie√üe beide Fehler (${state.bossHitsRemaining} √ºbrig)`
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
        : "Auftrag: Schie√üe das fehlerhafte Wort aus dem Satz heraus";
    }

    $("#homeBtn").addEventListener("click", ()=>{ window.location.href = "index.html"; });
    $("#resetBtn").addEventListener("click", ()=>{
      hardReset();
      overlay.style.display = "grid";
      state.paused = true;
      unlockPointer();
    });
    $("#startBtn").addEventListener("click", ()=>{ state.practice=false; startGame(); });
    $("#practiceBtn").addEventListener("click", ()=>{ state.practice=true; startGame(); });

    // -----------------------------
<<<<<<< HEAD
    // Three.js
=======
    // Three.js (heller + Tone Mapping)
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    // -----------------------------
    const canvas = $("#c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
<<<<<<< HEAD
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.45;

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b1220, 8, 85);

    const camera = new THREE.PerspectiveCamera(72, innerWidth/innerHeight, 0.1, 400);
    camera.position.set(0, 1.7, 6.0);

    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    scene.add(new THREE.HemisphereLight(0xffffff, 0x334466, 0.95));

    const key = new THREE.DirectionalLight(0xffffff, 1.2);
    key.position.set(8, 12, 6);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0x9fd7ff, 0.55);
    fill.position.set(-10, 6, -8);
    scene.add(fill);

    function makeGridTex(){
      const c = document.createElement("canvas");
      c.width = 512; c.height = 512;
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#0b1220";
      ctx.fillRect(0,0,512,512);

      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.lineWidth = 1;
      for(let i=0;i<=32;i++){
        const p=i*(512/32);
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,512); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(512,p); ctx.stroke();
      }
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 2;
      for(let i=0;i<=8;i++){
        const p=i*(512/8);
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,512); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(512,p); ctx.stroke();
      }
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(20,20);
      tex.anisotropy = 8;
      tex.needsUpdate = true;
      return tex;
=======
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.35; // heller!
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b1220, 10, 70);

    const camera = new THREE.PerspectiveCamera(72, innerWidth/innerHeight, 0.1, 300);
    camera.position.set(0, 1.7, 6.2);

    // Sky dome (soft gradient)
    const skyGeo = new THREE.SphereGeometry(140, 32, 20);
    const skyMat = new THREE.ShaderMaterial({
      side: THREE.BackSide,
      uniforms: {
        topColor: { value: new THREE.Color(0x233a66) },
        bottomColor: { value: new THREE.Color(0x070b13) },
        offset: { value: 30.0 },
        exponent: { value: 0.75 }
      },
      vertexShader: `
        varying vec3 vWorldPosition;
        void main() {
          vec4 wp = modelMatrix * vec4(position, 1.0);
          vWorldPosition = wp.xyz;
          gl_Position = projectionMatrix * viewMatrix * wp;
        }`,
      fragmentShader: `
        uniform vec3 topColor;
        uniform vec3 bottomColor;
        uniform float offset;
        uniform float exponent;
        varying vec3 vWorldPosition;
        void main() {
          float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;
          float t = pow(max(h, 0.0), exponent);
          gl_FragColor = vec4(mix(bottomColor, topColor, t), 1.0);
        }`
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // Better lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.50));
    scene.add(new THREE.HemisphereLight(0xffffff, 0x334466, 0.85));

    const dirKey = new THREE.DirectionalLight(0xffffff, 1.15);
    dirKey.position.set(8, 12, 6);
    dirKey.castShadow = false;
    scene.add(dirKey);

    const dirFill = new THREE.DirectionalLight(0x9fd7ff, 0.55);
    dirFill.position.set(-10, 6, -8);
    scene.add(dirFill);

    // Ground with subtle grid texture
    function makeGridTexture(){
      const c = document.createElement("canvas");
      c.width = 512; c.height = 512;
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#0b1220";
      ctx.fillRect(0,0,c.width,c.height);

      // small grid
      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.lineWidth = 1;
      for(let i=0;i<=32;i++){
        const p = i*(c.width/32);
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,c.height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(c.width,p); ctx.stroke();
      }
      // big grid
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 2;
      for(let i=0;i<=8;i++){
        const p = i*(c.width/8);
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,c.height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(c.width,p); ctx.stroke();
      }
      // vignette-ish
      const g = ctx.createRadialGradient(256,256,40,256,256,260);
      g.addColorStop(0,"rgba(255,255,255,0.00)");
      g.addColorStop(1,"rgba(0,0,0,0.35)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,512,512);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(20,20);
      tex.anisotropy = 8;
      return tex;
    }

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(260, 260),
      new THREE.MeshStandardMaterial({
        map: makeGridTexture(),
        color: 0xffffff,
        roughness: 0.95,
        metalness: 0.0
      })
    );
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    scene.add(ground);

    // Extra environment props (simple, but nicer)
    const props = new THREE.Group();
    scene.add(props);
    const crateMat = new THREE.MeshStandardMaterial({ color: 0x1a2a44, roughness: 0.8, metalness: 0.05 });
    const crateEdge = new THREE.MeshStandardMaterial({ color: 0x2a4a74, roughness: 0.5, metalness: 0.08 });

    function addCrate(x,z,s=1){
      const g = new THREE.Group();
      const box = new THREE.Mesh(new THREE.BoxGeometry(1.0*s, 0.9*s, 1.0*s), crateMat);
      box.position.y = 0.45*s;
      const rim = new THREE.Mesh(new THREE.BoxGeometry(1.05*s, 0.12*s, 1.05*s), crateEdge);
      rim.position.y = 0.90*s;
      g.add(box, rim);
      g.position.set(x,0,z);
      props.add(g);
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    }
    addCrate(-6,-10,1.1);
    addCrate(0,-11.2,1.3);
    addCrate(6,-9.6,1.0);
    addCrate(-2.7,-13.2,1.15);
    addCrate(2.8,-13.6,1.05);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(280,280),
      new THREE.MeshStandardMaterial({ map: makeGridTex(), color:0xffffff, roughness:0.95, metalness:0.0 })
    );
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // -----------------------------
<<<<<<< HEAD
    // Gun
=======
    // 3D Wasserpistole (upgraded)
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    // -----------------------------
    const gun = new THREE.Group();
    camera.add(gun);
    scene.add(camera);

    function makeGun(){
      const bodyMat  = new THREE.MeshStandardMaterial({ color: 0x7c3aed, roughness: 0.25, metalness: 0.10 });
      const darkMat  = new THREE.MeshStandardMaterial({ color: 0x0b1220, roughness: 0.55, metalness: 0.08 });
      const accentMat= new THREE.MeshStandardMaterial({ color: 0x22c55e, roughness: 0.25, metalness: 0.06 });
<<<<<<< HEAD
      const tankMat  = new THREE.MeshStandardMaterial({ color: 0x66ccff, roughness: 0.12, metalness: 0.02, transparent:true, opacity:0.62 });

      const root = new THREE.Group();

      const body = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.24, 0.98), bodyMat);
      body.position.set(0.50, -0.30, -0.96);

      const front = new THREE.Mesh(new THREE.BoxGeometry(0.34, 0.18, 0.40), bodyMat);
      front.position.set(0.46, -0.27, -1.40);

=======
      const tankMat  = new THREE.MeshStandardMaterial({
        color: 0x66ccff, roughness: 0.12, metalness: 0.02, transparent:true, opacity:0.65
      });
      const chromeMat= new THREE.MeshStandardMaterial({ color: 0xcbd5e1, roughness: 0.18, metalness: 0.65 });

      const g = new THREE.Group();

      // main body
      const body = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.24, 0.98), bodyMat);
      body.position.set(0.50, -0.30, -0.96);

      // front housing
      const front = new THREE.Mesh(new THREE.BoxGeometry(0.34, 0.18, 0.40), bodyMat);
      front.position.set(0.46, -0.27, -1.40);

      // barrel
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.070, 0.070, 0.72, 16), darkMat);
      barrel.rotation.x = Math.PI/2;
      barrel.position.set(0.44, -0.28, -1.68);

<<<<<<< HEAD
=======
      // nozzle + ring
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.052, 0.065, 0.14, 16), accentMat);
      nozzle.rotation.x = Math.PI/2;
      nozzle.position.set(0.44, -0.28, -2.06);

<<<<<<< HEAD
=======
      const ring = new THREE.Mesh(new THREE.TorusGeometry(0.07, 0.015, 10, 22), chromeMat);
      ring.position.set(0.44, -0.28, -2.00);
      ring.rotation.x = Math.PI/2;

      // grip
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      const grip = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.38, 0.30), darkMat);
      grip.position.set(0.64, -0.55, -0.68);
      grip.rotation.x = 0.12;

<<<<<<< HEAD
=======
      // trigger guard + trigger
      const guard = new THREE.Mesh(new THREE.TorusGeometry(0.10, 0.022, 10, 24), darkMat);
      guard.position.set(0.66, -0.46, -0.78);
      guard.rotation.x = Math.PI/2;

      const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.10, 0.02), chromeMat);
      trigger.position.set(0.66, -0.48, -0.78);

      // tank + cap
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.16, 0.52, 20), tankMat);
      tank.rotation.z = Math.PI/2;
      tank.position.set(0.16, -0.20, -0.86);

<<<<<<< HEAD
      root.add(body, front, barrel, nozzle, grip, tank);

      root.scale.setScalar(0.72);
      root.position.set(0.30, -0.32, 0.10);
      root.rotation.set(0.02, -0.06, 0);

      gun.add(root);
      gun.userData.nozzle = nozzle;
      gun.userData.root = root;
    }
    makeGun();

    // -----------------------------
    // Pointer lock + movement
=======
      const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.10, 16), accentMat);
      cap.rotation.z = Math.PI/2;
      cap.position.set(-0.10, -0.10, -0.86);

      // top rail
      const rail = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.05, 0.40), chromeMat);
      rail.position.set(0.48, -0.14, -1.05);

      // side accent
      const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.12, 0.60), accentMat);
      stripe.position.set(0.26, -0.28, -0.98);

      g.add(body, front, barrel, nozzle, ring, grip, guard, trigger, tank, cap, rail, stripe);

      // slight camera-gun sway anchor
      g.position.set(0,0,0);
      g.rotation.set(0.02, -0.06, 0.00);

      gun.add(g);
      gun.userData.nozzle = nozzle;
      gun.userData.root = g;
    }
    makeGun();

    // muzzle flash
    const muzzleFlash = new THREE.Mesh(
      new THREE.SphereGeometry(0.075, 12, 12),
      new THREE.MeshStandardMaterial({
        color: 0x66ccff, emissive: 0x66ccff, emissiveIntensity: 2.2, transparent:true, opacity:0.0
      })
    );
    gun.add(muzzleFlash);
    muzzleFlash.position.copy(gun.userData.nozzle.position).add(new THREE.Vector3(0,0,-0.06));

    // -----------------------------
    // Controls
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    // -----------------------------
    let yaw = 0, pitch = 0;
    const vel = new THREE.Vector3();
    const moveDir = new THREE.Vector3();
    const keys = { w:false,a:false,s:false,d:false, shift:false };

    function lockPointer(){ if(document.pointerLockElement !== canvas) canvas.requestPointerLock(); }
    function unlockPointer(){ if(document.pointerLockElement) document.exitPointerLock(); }

    document.addEventListener("pointerlockchange", ()=>{
      state.locked = (document.pointerLockElement === canvas);
      if(!state.locked && !state.paused){
        overlay.style.display = "grid";
        state.paused = true;
      }
    });

    document.addEventListener("mousemove", (e)=>{
      if(!state.locked) return;
      yaw -= (e.movementX || 0) * 0.0022;
      pitch -= (e.movementY || 0) * 0.0022;
      pitch = Math.max(-1.2, Math.min(1.2, pitch));
      camera.rotation.set(pitch, yaw, 0, "YXZ");
    });

    document.addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      if(k==="w") keys.w=true;
      if(k==="a") keys.a=true;
      if(k==="s") keys.s=true;
      if(k==="d") keys.d=true;
      if(k==="shift") keys.shift=true;

      if(k==="r"){
        state.ammo = state.ammoMax;
        uiUpdate();
        flashMsg("üîÑ Nachgeladen", true);
      }
    });

    document.addEventListener("keyup", (e)=>{
      const k = e.key.toLowerCase();
      if(k==="w") keys.w=false;
      if(k==="a") keys.a=false;
      if(k==="s") keys.s=false;
      if(k==="d") keys.d=false;
      if(k==="shift") keys.shift=false;
    });

    canvas.addEventListener("mousedown", (e)=>{
      if(e.button !== 0) return;
      if(state.paused){
        overlay.style.display = "none";
        state.paused = false;
        lockPointer();
        return;
      }
      if(!state.locked){ lockPointer(); return; }
      shoot();
    });

    window.addEventListener("resize", ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    // -----------------------------
<<<<<<< HEAD
    // Sentence strip
=======
    // Sentence strip (word planes) + placeholders
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    // -----------------------------
    const sentenceGroup = new THREE.Group();
    scene.add(sentenceGroup);

<<<<<<< HEAD
    const stripBase = new THREE.Vector3(0, 2.35, -4.0);
    const stripMotion = { phase: Math.random()*Math.PI*2, speed: 0.45, ampX: 0.75, ampY: 0.18 };

    const plate = new THREE.Mesh(
      new THREE.PlaneGeometry(12, 1.25),
      new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 1.0, transparent:true, opacity:0.28 })
=======
    const plate = new THREE.Mesh(
      new THREE.PlaneGeometry(10, 1.65),
      new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 1.0, metalness: 0.0, transparent:true, opacity:0.30 })
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    );
    sentenceGroup.add(plate);

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

<<<<<<< HEAD
    function makeWordCanvas(text){
      const c = document.createElement("canvas");
      const ctx = c.getContext("2d");

      const fontPx = 86;
      ctx.font = `800 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;

      const padX = 52;
      const w = Math.ceil(ctx.measureText(text).width) + padX*2;

      c.width  = Math.min(1200, Math.max(520, w));
      c.height = 240;

      ctx.clearRect(0,0,c.width,c.height);

      ctx.fillStyle = "rgba(0,0,0,0.52)";
      roundRect(ctx, 16, 34, c.width-32, c.height-68, 52);
      ctx.fill();

      ctx.lineWidth = 10;
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      roundRect(ctx, 16, 34, c.width-32, c.height-68, 52);
      ctx.stroke();

=======
    function makeWordCanvas(text, isWrong){
      const c = document.createElement("canvas");
      const ctx = c.getContext("2d");
      const fontPx = 76;                // BIG
      ctx.font = `800 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      const padX = 46;
      const w = Math.ceil(ctx.measureText(text).width) + padX*2;
      c.width = Math.min(1500, Math.max(520, w));
      c.height = 220;

      ctx.clearRect(0,0,c.width,c.height);

      // background
      ctx.fillStyle = "rgba(0,0,0,0.48)";
      roundRect(ctx, 14, 30, c.width-28, c.height-60, 46);
      ctx.fill();

      // border
      ctx.lineWidth = 10;
      ctx.strokeStyle = isWrong ? "rgba(239,68,68,0.88)" : "rgba(255,255,255,0.22)";
      roundRect(ctx, 14, 30, c.width-28, c.height-60, 46);
      ctx.stroke();

      // text
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      ctx.fillStyle = "rgba(231,238,252,0.98)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, c.width/2, c.height/2);

<<<<<<< HEAD
      return c;
    }

    function makePlaceholderCanvas(widthPx){
      const c = document.createElement("canvas");
      c.width = widthPx;
      c.height = 240;
      const ctx = c.getContext("2d");
      ctx.clearRect(0,0,c.width,c.height);

      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 10;
      ctx.setLineDash([20, 16]);
      roundRect(ctx, 20, 40, c.width-40, c.height-80, 52);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = "rgba(255,255,255,0.06)";
      roundRect(ctx, 20, 40, c.width-40, c.height-80, 52);
      ctx.fill();

=======
      if(isWrong){
        ctx.fillStyle = "rgba(239,68,68,0.95)";
        ctx.font = "900 48px ui-monospace, Menlo, Consolas, monospace";
        ctx.fillText("!", c.width-52, 64);
      }

      return c;
    }

    function makePlaceholderCanvas(widthPx){
      const c = document.createElement("canvas");
      c.width = widthPx;
      c.height = 220;
      const ctx = c.getContext("2d");
      ctx.clearRect(0,0,c.width,c.height);

      // dashed outline
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 8;
      ctx.setLineDash([18, 14]);
      roundRect(ctx, 18, 36, c.width-36, c.height-72, 44);
      ctx.stroke();
      ctx.setLineDash([]);

      // subtle fill
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      roundRect(ctx, 18, 36, c.width-36, c.height-72, 44);
      ctx.fill();

      // tiny underscore hint
      ctx.fillStyle = "rgba(231,238,252,0.45)";
      ctx.font = "700 58px ui-monospace, Menlo, Consolas, monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("____", c.width/2, c.height/2 + 6);

>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      return c;
    }

    function canvasToPlane(c, opacity=1.0){
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = 8;
      tex.needsUpdate = true;
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent:true, opacity });
      const aspect = c.width / c.height;

<<<<<<< HEAD
      const h = 0.80;
      const w = h * aspect;
      const geo = new THREE.PlaneGeometry(w, h);
      const mesh = new THREE.Mesh(geo, mat);

      mesh.userData.w = w;
=======
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent:true, opacity });
      const aspect = c.width / c.height;
      const height = 0.62;
      const width = height * aspect;
      const geo = new THREE.PlaneGeometry(width, height);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData.w = width;
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      mesh.userData._canvasW = c.width;
      return mesh;
    }

    function clearSentence(){
      const keep = new Set([plate]);
      for(const child of [...sentenceGroup.children]){
        if(keep.has(child)) continue;
        sentenceGroup.remove(child);
        if(child.material?.map) child.material.map.dispose();
        if(child.material) child.material.dispose();
        if(child.geometry) child.geometry.dispose();
      }
    }

    function tokenize(sentence){
      return sentence.split(" ").filter(Boolean);
    }

<<<<<<< HEAD
    const MAX_WORD_WORLD_W = 3.4;

    function buildSentenceStrip(sentence, wrongOrWrongs){
      clearSentence();

      const tokens = tokenize(sentence);
      const wrongs = Array.isArray(wrongOrWrongs) ? wrongOrWrongs : [wrongOrWrongs];

      const wordMeshes = [];
      for(const tok of tokens){
        const isWrong = wrongs.some(w => tok.includes(w));
        const c = makeWordCanvas(tok);
        const m = canvasToPlane(c, 1.0);
        m.userData.text = tok;
        m.userData.isWrong = isWrong;
        m.userData.alive = true;
        m.userData.kind = "word";

        if(m.userData.w > MAX_WORD_WORLD_W){
          const s = MAX_WORD_WORLD_W / m.userData.w;
          m.scale.x *= s;
          m.userData.w = MAX_WORD_WORLD_W;
        }
        wordMeshes.push(m);
      }

      const gap = 0.16;
      let totalW = -gap;
      for(const w of wordMeshes) totalW += w.userData.w + gap;

      let x = -totalW/2;
      for(const w of wordMeshes){
        w.position.set(x + w.userData.w/2, 0, 0);
        x += w.userData.w + gap;
        sentenceGroup.add(w);
      }

      plate.geometry.dispose();
      plate.geometry = new THREE.PlaneGeometry(Math.max(7.8, totalW + 0.9), 1.10);
      plate.position.set(0, 0, -0.03);

      sentenceGroup.position.copy(stripBase);
      sentenceGroup.visible = true;
    }

    function createPlaceholderFor(wordMesh){
      const wpx = wordMesh.userData._canvasW || 700;
      const c = makePlaceholderCanvas(wpx);
      const ph = canvasToPlane(c, 0.88);
      ph.userData.kind = "placeholder";
      ph.userData.w = wordMesh.userData.w;
      ph.position.copy(wordMesh.position);
      return ph;
    }

    // -----------------------------
    // Effects
    // -----------------------------
    const beams = [];
    const impacts = [];
    const hintPulses = [];
    let stripKick = 0;
    let recoil = 0;

    const beamMat = new THREE.MeshBasicMaterial({
      color: 0x66ccff, transparent: true, opacity: 0.85,
      blending: THREE.AdditiveBlending, depthWrite: false
    });
    const beamCoreMat = new THREE.MeshBasicMaterial({
      color: 0xe0fbff, transparent: true, opacity: 0.75,
      blending: THREE.AdditiveBlending, depthWrite: false
    });

    function spawnBeam(len=26){
      const nozzle = gun.userData.nozzle;
      const start = new THREE.Vector3();
      nozzle.getWorldPosition(start);
      const dir = camera.getWorldDirection(new THREE.Vector3()).normalize();

      const geo = new THREE.CylinderGeometry(0.05, 0.05, 1, 10, 1, true);
      const beam = new THREE.Mesh(geo, beamMat.clone());
      const geo2 = new THREE.CylinderGeometry(0.02, 0.02, 1, 10, 1, true);
      const core = new THREE.Mesh(geo2, beamCoreMat.clone());

      const g = new THREE.Group();
      g.add(beam, core);

      const mid = start.clone().add(dir.clone().multiplyScalar(len/2));
      g.position.copy(mid);
      g.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);

      beam.scale.set(1, len, 1);
      core.scale.set(1, len, 1);

      g.userData.life = 0.12;
      g.userData.max = 0.12;

      scene.add(g);
      beams.push(g);
    }

    function spawnImpact(worldPos){
      const geo = new THREE.PlaneGeometry(0.60, 0.60);
      const mat = new THREE.MeshBasicMaterial({
        color: 0xe0fbff,
        transparent: true,
        opacity: 0.95,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const m = new THREE.Mesh(geo, mat);
      m.position.copy(worldPos);
      m.quaternion.copy(camera.quaternion);
      m.userData.life = 0.18;
      m.userData.max  = 0.18;
      scene.add(m);
      impacts.push(m);
    }

    function spawnHintPulseFor(wordMesh){
      if(!wordMesh) return;

      wordMesh.updateMatrixWorld(true);
      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      const scl = new THREE.Vector3();
      wordMesh.matrixWorld.decompose(pos, quat, scl);

      const w = wordMesh.geometry.parameters.width * scl.x * 1.10;
      const h = wordMesh.geometry.parameters.height * scl.y * 1.18;
      const geo = new THREE.PlaneGeometry(w, h);
      const mat = new THREE.MeshBasicMaterial({
        color: 0x66ccff,
        transparent: true,
        opacity: 0.0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      const glow = new THREE.Mesh(geo, mat);
      glow.position.copy(pos);
      glow.quaternion.copy(camera.quaternion);
      glow.userData.life = 0.70;
      glow.userData.max = 0.70;

      scene.add(glow);
      hintPulses.push(glow);
    }

    // -----------------------------
    // Flying word effect
    // -----------------------------
    const flyingWords = [];
    function spawnFlyingWordFrom(mesh){
      const w = new THREE.Mesh(mesh.geometry.clone(), mesh.material.clone());
      w.material.opacity = 1.0;
      w.material.transparent = true;

      mesh.updateMatrixWorld(true);
      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      const scl = new THREE.Vector3();
      mesh.matrixWorld.decompose(pos, quat, scl);

      w.position.copy(pos);
      w.quaternion.copy(quat);
      w.scale.copy(scl);

      const camDir = camera.getWorldDirection(new THREE.Vector3()).normalize();
      const v = camDir.clone().multiplyScalar(-8.0);
      v.y += 2.4;
      v.x += (Math.random()-0.5)*1.6;
      v.z += (Math.random()-0.5)*1.6;

      w.userData.v = v;
      w.userData.life = 1.05;

      scene.add(w);
      flyingWords.push(w);
    }

    // -----------------------------
    // Task spawning
    // -----------------------------
    function spawnNormal(i){
      state.bossActive = false;
      state.bossHitsRemaining = 0;
      state.bossBonusAwarded = false;
      state.failsThisSentence = 0;

      const t = TASKS[i % TASKS.length];
      sentenceEl.textContent = t.sentence;

      state.level = 1 + Math.floor(state.done / 6);
      hintEl.innerHTML = state.practice
        ? `√úbungsmodus: keine Minuspunkte. Hint nach <b>2 Fehlversuchen</b>.`
        : `‚úÖ richtig +10 (+Streak), ‚ùå falsch ‚àí5. Hint nach <b>2 Fehlversuchen</b>.`;

      buildSentenceStrip(t.sentence, t.wrong);
      uiUpdate();
      flashMsg("Neuer Satz!", true);
    }

    function spawnBoss(){
      const boss = BOSS_TASKS[state.bossIdx % BOSS_TASKS.length];
      state.bossActive = true;
      state.bossBonusAwarded = false;
      state.bossHitsRemaining = boss.wrongs.length;
      state.failsThisSentence = 0;

      sentenceEl.textContent = boss.sentence;
      hintEl.innerHTML = state.practice
        ? `üëë Boss: 2 Fehler. Hint nach <b>2 Fehlversuchen</b>.`
        : `üëë Boss: 2 Fehler. Beide treffen ‚Üí <b>+30</b>. Hint nach <b>2 Fehlversuchen</b>.`;

      state.level = Math.max(state.level, 4);
      buildSentenceStrip(boss.sentence, boss.wrongs);
      uiUpdate();
      flashMsg("üëë Bossrunde!", true);
    }

    // -----------------------------
    // Hint logic
=======
    // sentence group motion
    const strip = {
      base: new THREE.Vector3(0, 2.55, -8.0),
      phase: Math.random()*Math.PI*2,
      speed: 0.50,
      ampX: 1.45,
      ampY: 0.30,
      hideT: 999,
      hidden: false
    };

    function buildSentenceStrip(sentence, wrongOrWrongs){
      clearSentence();

      const tokens = tokenize(sentence);
      const wrongs = Array.isArray(wrongOrWrongs) ? wrongOrWrongs : [wrongOrWrongs];

      const wordMeshes = [];
      for(const tok of tokens){
        const isWrong = wrongs.some(w => tok.includes(w));
        const c = makeWordCanvas(tok, isWrong);
        const m = canvasToPlane(c, 1.0);
        m.userData.text = tok;
        m.userData.isWrong = isWrong;
        m.userData.alive = true;
        m.userData.kind = "word";
        wordMeshes.push(m);
      }

      const gap = 0.10;
      let totalW = -gap;
      for(const w of wordMeshes) totalW += w.userData.w + gap;

      let x = -totalW/2;
      for(const w of wordMeshes){
        w.position.set(x + w.userData.w/2, 0, 0);
        w.userData.baseLocal = w.position.clone();
        x += w.userData.w + gap;
        sentenceGroup.add(w);
      }

      plate.geometry.dispose();
      plate.geometry = new THREE.PlaneGeometry(Math.max(6.0, totalW + 0.8), 1.05);
      plate.position.set(0, 0, -0.03);

      sentenceGroup.position.copy(strip.base);
      sentenceGroup.rotation.set(0, 0, 0);
      sentenceGroup.visible = true;
    }

    function createPlaceholderFor(wordMesh){
      const wpx = wordMesh.userData._canvasW || 700;
      const c = makePlaceholderCanvas(wpx);
      const ph = canvasToPlane(c, 0.85);
      ph.userData.kind = "placeholder";
      ph.userData.w = wordMesh.userData.w;
      ph.position.copy(wordMesh.position);
      ph.userData.baseLocal = ph.position.clone();
      return ph;
    }

    // -----------------------------
    // Flying words + water trail
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    // -----------------------------
    const flyingWords = [];
    const waterTrail = [];
    const trailGeo = new THREE.SphereGeometry(0.035, 8, 8);
    const trailMatBase = new THREE.MeshStandardMaterial({
      color: 0x66ccff, roughness: 0.25, metalness: 0.02, transparent:true, opacity:0.85
    });

<<<<<<< HEAD
    function getWrongWordMeshes(){
      return sentenceGroup.children.filter(o => o.userData?.kind === "word" && o.userData.alive && o.userData.isWrong);
    }

    function maybeShowHint(){
      if(state.failsThisSentence >= 2){
        const wrongs = getWrongWordMeshes();
        if(wrongs.length){
          wrongs.forEach(w => spawnHintPulseFor(w));
          flashMsg("üîé Hint!", true);
        }
        // every 2 fails => consume 2
        state.failsThisSentence = Math.max(0, state.failsThisSentence - 2);
=======
    function spawnFlyingWordFrom(mesh){
      // clone geometry/material/texture
      const w = new THREE.Mesh(mesh.geometry.clone(), mesh.material.clone());
      w.material.opacity = 1.0;
      w.material.transparent = true;

      // world transform from sentenceGroup local
      mesh.updateMatrixWorld(true);
      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      const scl = new THREE.Vector3();
      mesh.matrixWorld.decompose(pos, quat, scl);

      w.position.copy(pos);
      w.quaternion.copy(quat);
      w.scale.copy(scl);

      // velocity: away from camera + a bit upward + random sideways
      const camDir = camera.getWorldDirection(new THREE.Vector3()).normalize();
      const v = camDir.clone().multiplyScalar(-8.5); // ‚Äúflies away‚Äù from camera
      v.y += 2.6;
      v.x += (Math.random()-0.5)*1.6;
      v.z += (Math.random()-0.5)*1.6;

      w.userData.v = v;
      w.userData.w = mesh.userData.w;
      w.userData.life = 1.15; // seconds
      w.userData.spin = new THREE.Vector3(
        (Math.random()-0.5)*2.2,
        (Math.random()-0.5)*2.2,
        (Math.random()-0.5)*1.2
      );

      scene.add(w);
      flyingWords.push(w);
    }

    function addWaterBurstAtNozzle(){
      // muzzle flash
      muzzleFlash.position.copy(gun.userData.nozzle.position).add(new THREE.Vector3(0,0,-0.06));
      muzzleFlash.material.opacity = 0.95;

      // quick droplets
      const nozzle = gun.userData.nozzle;
      const muzzleWorld = new THREE.Vector3();
      nozzle.getWorldPosition(muzzleWorld);

      const dir = camera.getWorldDirection(new THREE.Vector3()).normalize();
      const count = 16;
      for(let i=0;i<count;i++){
        const m = new THREE.Mesh(trailGeo, trailMatBase.clone());
        m.position.copy(muzzleWorld);
        const spread = 0.08 + Math.random()*0.07;
        const jitter = new THREE.Vector3(
          (Math.random()-0.5)*spread,
          (Math.random()-0.5)*spread,
          (Math.random()-0.5)*spread
        );
        const v = dir.clone().multiplyScalar(22 + Math.random()*7).add(jitter.multiplyScalar(26));
        m.userData.v = v;
        m.userData.life = 0.28 + Math.random()*0.20;
        scene.add(m);
        waterTrail.push(m);
      }
    }

    function dripTrailFrom(pos){
      // small trailing droplets behind the flying word
      const m = new THREE.Mesh(trailGeo, trailMatBase.clone());
      m.position.copy(pos);
      m.userData.v = new THREE.Vector3((Math.random()-0.5)*1.2, Math.random()*1.4, (Math.random()-0.5)*1.2);
      m.userData.life = 0.20 + Math.random()*0.18;
      scene.add(m);
      waterTrail.push(m);
    }

    // -----------------------------
    // Spawning tasks
    // -----------------------------
    function spawnNormal(i){
      state.bossActive = false;
      state.bossHitsRemaining = 0;
      state.bossBonusAwarded = false;

      const t = TASKS[i % TASKS.length];
      sentenceEl.textContent = t.sentence;

      state.level = 1 + Math.floor(state.done / 6);

      const info = t.note ? `(${t.note})` : "";
      hintEl.innerHTML = state.practice
        ? `√úbungsmodus: keine Minuspunkte. Genau <b>1 Wort</b> ist falsch. <span style="opacity:.85">${info}</span>`
        : `‚úÖ richtig +10 (+Streak), ‚ùå falsch ‚àí5 (Streak reset). <span style="opacity:.85">${info}</span>`;

      buildSentenceStrip(t.sentence, t.wrong);
      uiUpdate();
      flashMsg("Neuer Satz!", true);
    }

    function spawnBoss(){
      const boss = BOSS_TASKS[0];
      state.bossActive = true;
      state.bossBonusAwarded = false;
      state.bossHitsRemaining = boss.wrongs.length;

      sentenceEl.textContent = boss.sentence;
      hintEl.innerHTML = state.practice
        ? `üëë <b>Bossrunde:</b> 2 Fehler. Triff beide (kein Abzug). <span style="opacity:.85">(${boss.note})</span>`
        : `üëë <b>Bossrunde:</b> 2 Fehler. Beide treffen ‚Üí <b>+30 Bonus</b>. <span style="opacity:.85">(${boss.note})</span>`;

      state.level = Math.max(state.level, 4);
      buildSentenceStrip(boss.sentence, boss.wrongs);
      uiUpdate();
      flashMsg("üëë Bossrunde!", true);
    }

    // -----------------------------
    // Raycast shooting (words only)
    // -----------------------------
    const raycaster = new THREE.Raycaster();

    function shoot(){
      if(state.ammo <= 0){
        flashMsg("üíß Leer! (R zum Nachladen)", false);
        return;
      }
      state.ammo--;
      uiUpdate();

      addWaterBurstAtNozzle();

      const origin = camera.getWorldPosition(new THREE.Vector3());
      const direction = camera.getWorldDirection(new THREE.Vector3()).normalize();

      raycaster.set(origin, direction);
      raycaster.far = 300;

      const wordTargets = sentenceGroup.children.filter(o => o.userData?.kind === "word" && o.userData.alive);
      const hits = raycaster.intersectObjects(wordTargets, false);

      if(!hits.length){
        flashMsg("üí¶ Daneben!", false);
        return;
      }

      const hit = hits[0].object;
      if(!hit.userData.alive){
        flashMsg("üí¶ Fast!", false);
        return;
      }

      if(hit.userData.isWrong){
        // visible ‚Äúshoot out‚Äù effect:
        // 1) spawn flying clone in world space
        spawnFlyingWordFrom(hit);

        // 2) replace with placeholder in the strip
        const ph = createPlaceholderFor(hit);
        sentenceGroup.add(ph);

        // 3) remove original
        hit.userData.alive = false;
        sentenceGroup.remove(hit);
        if(hit.material?.map) hit.material.map.dispose();
        if(hit.material) hit.material.dispose();
        if(hit.geometry) hit.geometry.dispose();

        // scoring
        const streakBonus = Math.min(12, state.streak);
        state.score += 10 + streakBonus;
        state.streak += 1;

        if(state.bossActive){
          state.bossHitsRemaining = Math.max(0, state.bossHitsRemaining - 1);
          uiUpdate();
          flashMsg(`‚úÖ Boss-Treffer! (${state.bossHitsRemaining} √ºbrig)`, true);

          if(state.bossHitsRemaining === 0 && !state.bossBonusAwarded){
            state.bossBonusAwarded = true;
            state.score += 30;
            uiUpdate();
            flashMsg("üëë Boss besiegt! +30 Bonus!", true);
            setTimeout(()=>endGame(true), 700);
          }
          return;
        }

        state.done += 1;
        uiUpdate();
        flashMsg("‚úÖ Treffer!", true);

        if(state.done >= state.total){
          setTimeout(()=>spawnBoss(), 650);
        }else{
          state.idx += 1;
          setTimeout(()=>spawnNormal(state.idx), 650);
        }
      }else{
        if(!state.practice){
          state.score = Math.max(0, state.score - 5);
          state.streak = 0;
        }
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
        uiUpdate();
        flashMsg("‚ùå Falsches Wort!", false);
      }
    }

    // -----------------------------
    // Shooting
    // -----------------------------
    function shoot(){
      if(state.ammo <= 0){
        flashMsg("üíß Leer! (R)", false);
        return;
      }
      state.ammo--;
      uiUpdate();

      spawnBeam(26);

      const origin = camera.getWorldPosition(new THREE.Vector3());
      const direction = camera.getWorldDirection(new THREE.Vector3()).normalize();
      raycaster.set(origin, direction);
      raycaster.far = 400;

      const targets = sentenceGroup.children.filter(o => o.userData?.kind === "word" && o.userData.alive);
      const hits = raycaster.intersectObjects(targets, false);

      if(!hits.length){
        state.failsThisSentence += 1;
        uiUpdate();
        flashMsg("üí¶ Daneben!", false);
        maybeShowHint();
        return;
      }

      const hit = hits[0].object;

      // impact + kick/recoil always
      spawnImpact(hits[0].point.clone());
      stripKick = Math.min(0.22, stripKick + 0.14);
      recoil = Math.min(0.18, recoil + 0.10);

      if(hit.userData.isWrong){
        spawnFlyingWordFrom(hit);

        const ph = createPlaceholderFor(hit);
        sentenceGroup.add(ph);

        hit.userData.alive = false;
        sentenceGroup.remove(hit);
        if(hit.material?.map) hit.material.map.dispose();
        if(hit.material) hit.material.dispose();
        if(hit.geometry) hit.geometry.dispose();

        const streakBonus = Math.min(12, state.streak);
        state.score += 10 + streakBonus;
        state.streak += 1;

        state.failsThisSentence = 0;

        if(state.bossActive){
          state.bossHitsRemaining = Math.max(0, state.bossHitsRemaining - 1);
          uiUpdate();
          flashMsg(`‚úÖ Boss-Treffer! (${state.bossHitsRemaining})`, true);

          if(state.bossHitsRemaining === 0 && !state.bossBonusAwarded){
            state.bossBonusAwarded = true;
            state.score += 30;
            uiUpdate();
            flashMsg("üëë Boss besiegt! +30", true);
            setTimeout(()=>endGame(true), 700);
          }
          return;
        }

        state.done += 1;
        uiUpdate();
        flashMsg("‚úÖ Treffer!", true);

        if(state.done >= state.total){
          setTimeout(()=>spawnBoss(), 620);
        }else{
          state.idx += 1;
          setTimeout(()=>spawnNormal(state.idx), 620);
        }
      }else{
        state.failsThisSentence += 1;

        if(!state.practice){
          state.score = Math.max(0, state.score - 5);
          state.streak = 0;
        }

        uiUpdate();
        flashMsg("‚ùå Falsch!", false);
        maybeShowHint();
      }
    }

    // -----------------------------
    // Flow
    // -----------------------------
    function hardReset(){
      state.idx = 0; state.score = 0; state.streak = 0;
      state.ammo = state.ammoMax;
      state.done = 0; state.level = 1;
      state.bossActive = false; state.bossHitsRemaining = 0; state.bossBonusAwarded = false;
      state.failsThisSentence = 0;
      state.bossIdx = 0;

<<<<<<< HEAD
      camera.position.set(0, 1.7, 6.0);
=======
      camera.position.set(0, 1.7, 6.2);
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
      yaw = 0; pitch = 0;
      camera.rotation.set(0,0,0);

      spawnNormal(0);
      uiUpdate();
    }

    function startGame(){
      overlay.style.display = "none";
      state.paused = false;
      hardReset();
      lockPointer();
    }

    function endGame(wonBoss=false){
      unlockPointer();
      state.paused = true;
      overlay.style.display = "grid";
      overlay.querySelector("h2").textContent = wonBoss ? "Boss geschafft! üèÜ" : "Fertig! üéâ";
      overlay.querySelector("p").innerHTML =
<<<<<<< HEAD
        `Score: <b>${state.score}</b> ¬∑ Streak: <b>${state.streak}</b><br>
         Du kannst neu starten oder √úbungsmodus w√§hlen.`;
    }

    // -----------------------------
    // Update loop
=======
        `Ergebnis: <b>${state.score}</b> Punkte ¬∑ Streak: <b>${state.streak}</b><br>
         ${wonBoss ? "Bonus: <b>+30</b> ‚úÖ<br>" : ""}
         Du kannst neu starten oder √úbungsmodus w√§hlen.`;
      flashMsg(wonBoss ? "üèÜ Perfekt!" : "üéâ Fertig!", true);
    }

    // -----------------------------
    // Update loop (movement + strip + effects)
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    // -----------------------------
    const clock = new THREE.Clock();

    function updateMovement(dt){
      if(state.locked && !state.paused){
<<<<<<< HEAD
        const speed = keys.shift ? 6.6 : 4.8;

        moveDir.set(0,0,0);
=======
        const speed = keys.shift ? 6.6 : 4.6;

        moveDir.set(0,0,0);
        // W forward, S backward
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
        if(keys.w) moveDir.z += 1;
        if(keys.s) moveDir.z -= 1;
        if(keys.a) moveDir.x -= 1;
        if(keys.d) moveDir.x += 1;

        if(moveDir.lengthSq() > 0){
          moveDir.normalize();
          const forward = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0, yaw, 0));
          const right = new THREE.Vector3(1,0,0).applyEuler(new THREE.Euler(0, yaw, 0));
          vel.x = (right.x * moveDir.x + forward.x * moveDir.z) * speed;
          vel.z = (right.z * moveDir.x + forward.z * moveDir.z) * speed;
        }else{
          vel.x *= 0.85; vel.z *= 0.85;
        }

        camera.position.x += vel.x * dt;
        camera.position.z += vel.z * dt;

<<<<<<< HEAD
        camera.position.x = THREE.MathUtils.clamp(camera.position.x, -30, 30);
        camera.position.z = THREE.MathUtils.clamp(camera.position.z, -30, 30);
=======
        camera.position.x = THREE.MathUtils.clamp(camera.position.x, -40, 40);
        camera.position.z = THREE.MathUtils.clamp(camera.position.z, -40, 35);
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
        camera.position.y = 1.7;
      }
    }

    function updateSentenceStrip(t, dt){
<<<<<<< HEAD
      const L = Math.min(6, state.level);
      stripMotion.speed = 0.35 + L*0.04;
      stripMotion.ampX  = 0.55 + L*0.10;
      stripMotion.ampY  = 0.12 + L*0.03;

      sentenceGroup.position.x = stripBase.x + Math.sin(t*stripMotion.speed + stripMotion.phase) * stripMotion.ampX;
      sentenceGroup.position.y = stripBase.y + Math.sin(t*stripMotion.speed*1.2 + stripMotion.phase*1.7) * stripMotion.ampY;
      sentenceGroup.position.z = stripBase.z;

      sentenceGroup.quaternion.copy(camera.quaternion);
      const e = new THREE.Euler().setFromQuaternion(sentenceGroup.quaternion, "YXZ");
      e.z = 0;
      e.x *= 0.10;
      sentenceGroup.quaternion.setFromEuler(e);

      if(stripKick > 0){
        sentenceGroup.position.x += (Math.random()-0.5) * stripKick * 0.40;
        sentenceGroup.position.y += (Math.random()-0.5) * stripKick * 0.22;
        stripKick = Math.max(0, stripKick - dt*2.8);
      }
    }

    function updateGunRecoil(dt){
      const r = gun.userData.root;
      if(!r) return;
      if(recoil > 0){
        r.position.z += recoil * 0.12;
        recoil = Math.max(0, recoil - dt*3.2);
      }
=======
      // group moves together (fair, readable)
      const L = Math.min(7, state.level);
      strip.speed = 0.36 + L*0.05;
      strip.ampX = 1.05 + L*0.20;
      strip.ampY = 0.18 + L*0.05;

      sentenceGroup.position.x = strip.base.x + Math.sin(t*strip.speed + strip.phase) * strip.ampX;
      sentenceGroup.position.y = strip.base.y + Math.sin(t*strip.speed*1.2 + strip.phase*1.7) * strip.ampY;
      sentenceGroup.position.z = strip.base.z;

      // face camera, keep stable
      sentenceGroup.quaternion.copy(camera.quaternion);
      const e = new THREE.Euler().setFromQuaternion(sentenceGroup.quaternion, "YXZ");
      e.z = 0;
      e.x *= 0.12;
      sentenceGroup.quaternion.setFromEuler(e);
    }

    function updateGunSway(t){
      // subtle bob + recoil recovery
      const r = gun.userData.root;
      if(!r) return;
      const bob = state.locked && !state.paused ? 1.0 : 0.3;
      r.position.x = 0.02 * Math.sin(t*6.2) * bob;
      r.position.y = -0.01 * Math.abs(Math.sin(t*6.2)) * bob;
    }

    function updateMuzzle(dt){
      muzzleFlash.material.opacity = Math.max(0, muzzleFlash.material.opacity - dt*2.9);
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
    }

    function updateFlyingWords(dt){
      for(let i=flyingWords.length-1;i>=0;i--){
        const w = flyingWords[i];
        w.userData.life -= dt;
<<<<<<< HEAD
        w.position.addScaledVector(w.userData.v, dt);
        w.userData.v.y -= 7.5 * dt;
        w.material.opacity = Math.max(0, w.userData.life / 1.05);
=======

        w.position.addScaledVector(w.userData.v, dt);
        w.userData.v.y -= 7.0 * dt; // gravity-ish
        w.rotation.x += w.userData.spin.x * dt;
        w.rotation.y += w.userData.spin.y * dt;
        w.rotation.z += w.userData.spin.z * dt;

        // dripping trail
        if(Math.random() < 0.55){
          dripTrailFrom(w.position);
        }

        // fade
        if(w.material) w.material.opacity = Math.max(0, Math.min(1, w.userData.life / 1.15));
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672

        if(w.userData.life <= 0){
          scene.remove(w);
          if(w.material?.map) w.material.map.dispose();
          if(w.material) w.material.dispose();
          if(w.geometry) w.geometry.dispose();
          flyingWords.splice(i,1);
        }
      }
    }

<<<<<<< HEAD
    function updateBeams(dt){
      for(let i=beams.length-1;i>=0;i--){
        const b = beams[i];
        b.userData.life -= dt;
        const a = Math.max(0, b.userData.life / b.userData.max);
        b.children.forEach((m, idx)=>{
          m.material.opacity = idx===0 ? (0.85*a) : (0.70*a);
        });
        if(b.userData.life <= 0){
          scene.remove(b);
          b.children.forEach(m=>{
            if(m.material) m.material.dispose();
            if(m.geometry) m.geometry.dispose();
          });
          beams.splice(i,1);
        }
      }
    }

    function updateImpacts(dt){
      for(let i=impacts.length-1;i>=0;i--){
        const p = impacts[i];
        p.userData.life -= dt;
        const a = Math.max(0, p.userData.life / p.userData.max);

        const s = 1 + (1-a)*0.9;
        p.scale.set(s, s, 1);
        p.material.opacity = 0.95 * a;
        p.quaternion.copy(camera.quaternion);

        if(p.userData.life <= 0){
          scene.remove(p);
          p.material.dispose();
          p.geometry.dispose();
          impacts.splice(i,1);
        }
      }
    }

    function updateHintPulses(dt){
      for(let i=hintPulses.length-1;i>=0;i--){
        const g = hintPulses[i];
        g.userData.life -= dt;
        const a = Math.max(0, g.userData.life / g.userData.max);

        const pulse = Math.sin((1-a) * Math.PI);
        g.material.opacity = 0.55 * pulse;
        g.quaternion.copy(camera.quaternion);

        if(g.userData.life <= 0){
          scene.remove(g);
          g.material.dispose();
          g.geometry.dispose();
          hintPulses.splice(i,1);
=======
    function updateWaterTrail(dt){
      for(let i=waterTrail.length-1;i>=0;i--){
        const p = waterTrail[i];
        p.userData.life -= dt;
        p.position.addScaledVector(p.userData.v, dt);
        p.userData.v.y -= 10.0 * dt;
        if(p.material) p.material.opacity = Math.max(0, p.userData.life / 0.55);

        if(p.userData.life <= 0){
          scene.remove(p);
          if(p.material) p.material.dispose();
          waterTrail.splice(i,1);
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672
        }
      }
    }

    function loop(){
      const dt = Math.min(0.033, clock.getDelta());
      const t = clock.getElapsedTime();

      updateMovement(dt);
      updateSentenceStrip(t, dt);
<<<<<<< HEAD
      updateGunRecoil(dt);
      updateFlyingWords(dt);
      updateBeams(dt);
      updateImpacts(dt);
      updateHintPulses(dt);
=======
      updateGunSway(t);
      updateMuzzle(dt);
      updateFlyingWords(dt);
      updateWaterTrail(dt);
>>>>>>> 8e2186890651906ff53aef67b3fa2d1c354dc672

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    // init
    hardReset();
    uiUpdate();
    loop();
  </script>
</body>
</html>
