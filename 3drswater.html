<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HoS ¬∑ 3D Wasserpistolen-Spiel (Rechtschreibung & Gro√ü/Klein)</title>
  <style>
    :root{
      --bg:#0b1220;
      --ink:#e7eefc;
      --muted:#b8c2dd;
      --line: rgba(255,255,255,.14);
      --good:#22c55e;
      --bad:#ef4444;
      --accent:#7c3aed;
      --warn:#f59e0b;
      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); color:var(--ink);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(124,58,237,.25), transparent 60%),
        radial-gradient(900px 600px at 80% 20%, rgba(34,197,94,.18), transparent 55%),
        radial-gradient(1000px 700px at 50% 110%, rgba(245,158,11,.10), transparent 55%),
        var(--bg);
      height:100vh;
      overflow:hidden;
      user-select:none;
    }
    canvas{display:block;width:100%;height:100%}

    .hud{position:fixed; inset:0; pointer-events:none; display:flex; flex-direction:column; padding:14px; gap:10px;}
    .topbar{display:flex; gap:10px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;}
    .pill{
      pointer-events:auto;
      display:inline-flex; gap:10px; align-items:center;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.25);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      font-size:13px;
      color:var(--muted);
      flex-wrap:wrap;
    }
    .pill b{color:var(--ink)}
    .btn{
      pointer-events:auto;
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--ink);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-size:13px;
      box-shadow: 0 12px 35px rgba(0,0,0,.22);
      transition: transform .08s ease, background .15s ease, border-color .15s ease;
    }
    .btn:hover{ background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.22);}
    .btn:active{ transform: translateY(1px) scale(.99); }

    .center{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      width:18px; height:18px;
      display:grid; place-items:center;
      opacity:.9;
    }
    .cross{width:18px; height:18px; position:relative;}
    .cross:before,.cross:after{
      content:""; position:absolute; left:50%; top:50%;
      background: rgba(231,238,252,.9);
      transform:translate(-50%,-50%);
      border-radius:2px;
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
    }
    .cross:before{ width:16px; height:2px; }
    .cross:after{ width:2px; height:16px; }

    .bottom{margin-top:auto; display:flex; justify-content:center;}
    .card{
      pointer-events:auto;
      width:min(1050px, calc(100vw - 24px));
      border:1px solid var(--line);
      background: rgba(0,0,0,.28);
      box-shadow: var(--shadow);
      border-radius:22px;
      padding:12px 14px;
      backdrop-filter: blur(10px);
    }
    .title{
      display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap;
      align-items:center;
      margin-bottom:8px;
    }
    .title h1{margin:0; font-size:14px; letter-spacing:.25px; text-transform:uppercase; color:var(--muted);}
    .sentence{margin:0; font-size:18px; line-height:1.35; color:var(--ink);}
    .hint{margin:8px 0 0; font-size:12px; color:var(--muted); line-height:1.5;}
    .kbd{
      font-family:var(--mono);
      font-size:11px;
      padding:4px 6px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
      color:var(--ink);
    }
    .bar{
      height:10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      overflow:hidden;
      margin-top:10px;
    }
    .fill{height:100%; width:0%; background: linear-gradient(90deg, rgba(34,197,94,.85), rgba(124,58,237,.85));}

    .overlay{
      position:fixed; inset:0;
      display:grid; place-items:center;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(8px);
    }
    .panel{
      width:min(760px, calc(100vw - 24px));
      border:1px solid var(--line);
      border-radius:26px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      box-shadow: var(--shadow);
      padding:18px 18px 16px;
      text-align:left;
    }
    .panelHead{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:10px;}
    .badge{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
    }
    .panel h2{margin:8px 0 8px; font-size:22px; letter-spacing:.2px;}
    .panel p{margin:0 0 10px; color:var(--muted); line-height:1.55;}
    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px;}
    @media(max-width:760px){ .grid2{grid-template-columns:1fr} }
    .note{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius:18px;
      padding:12px;
      color:var(--muted);
      font-size:13px;
      line-height:1.5;
    }
    .note b{color:var(--ink)}
    .flash{
      position:fixed; left:50%; top:14px; transform:translateX(-50%);
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.35);
      color:var(--ink);
      font-size:13px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .15s ease, transform .15s ease;
      backdrop-filter: blur(10px);
    }
    .flash.show{opacity:1; transform:translateX(-50%) translateY(-2px);}
    .good{color:rgba(190,255,215,.95)}
    .bad{color:rgba(255,200,200,.95)}
  </style>
</head>

<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="topbar">
      <div class="pill">
        <span>üî´ Wasserpistole (3D)</span>
        <span>Munition: <b id="ammo">12</b>/<span id="ammoMax">12</span> <span class="kbd">R</span></span>
        <span>Score: <b id="score">0</b></span>
        <span>Streak: <b id="streak">0</b></span>
        <span>Level: <b id="level">1</b></span>
        <span id="bossTag" style="display:none;color:rgba(245,158,11,.95)">üëë BOSS</span>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn" id="homeBtn">üè† Startseite</button>
        <button class="btn" id="resetBtn">üîÅ Neustart</button>
      </div>
    </div>

    <div class="center"><div class="cross"></div></div>

    <div class="bottom">
      <div class="card">
        <div class="title">
          <h1 id="missionTitle">Auftrag: Schie√üe das fehlerhafte Wort (Gro√ü/Klein oder Rechtschreibung)</h1>
          <div class="pill" style="padding:8px 10px; font-size:12px;">
            WASD bewegen ¬∑ Maus schauen ¬∑ Klick schie√üen ¬∑ ESC frei ¬∑ Ziele bewegen & verstecken ¬∑ Deckung blockt
          </div>
        </div>
        <p class="sentence" id="sentence">‚Äî</p>
        <p class="hint" id="hint">Tipp: Genau <b>1 Wort</b> ist falsch.</p>
        <div class="bar"><div class="fill" id="progress"></div></div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel">
      <div class="panelHead">
        <span class="badge">HoS ¬∑ 3D Spiel ¬∑ Deutsch</span>
        <span class="badge">Laptop Mode ‚úÖ</span>
      </div>
      <h2>Wasserpistolen-Entspannung (mit Grammatik-Bonus) üòÑ</h2>
      <p>
        Im Satz unten ist <b>genau ein Wort</b> falsch: entweder <b>Gro√ü/Klein</b> oder <b>Rechtschreibung</b>
        (z.B. <i>giebt</i>, <i>Maschiene</i>, <i>seid/seit</i>, <i>dass/das</i> ‚Ä¶).
        <b>Schie√üe dieses Wort</b> als Ziel im Raum weg. <br><br>
        <b>Bonus:</b> Am Ende kommt eine <b>Bossrunde</b> mit <b>2 Fehlern</b> (beide treffen = +30).
      </p>
      <div class="grid2">
        <div class="note">
          <b>Steuerung</b><br>
          ‚Ä¢ <span class="kbd">Klick</span> schie√üen<br>
          ‚Ä¢ <span class="kbd">WASD</span> laufen<br>
          ‚Ä¢ Maus schauen (Pointer Lock)<br>
          ‚Ä¢ <span class="kbd">R</span> nachladen<br>
          ‚Ä¢ <span class="kbd">ESC</span> Maus frei
        </div>
        <div class="note">
          <b>Punkte</b><br>
          ‚úÖ korrektes Ziel: +10 + Streak-Bonus<br>
          ‚ùå falsches Ziel: ‚àí5, Streak = 0<br>
          üëë Bossrunde: 2 Fehler ‚Üí beide treffen = <b>+30</b><br>
          <span style="color:rgba(255,255,255,.7)">Quickcheck: Score/Streak oben.</span>
        </div>
      </div>
      <div style="display:flex; gap:10px; margin-top:14px; flex-wrap:wrap;">
        <button class="btn" id="startBtn">‚ñ∂ Start</button>
        <button class="btn" id="practiceBtn">üß™ √úbungsmodus (ohne Abzug)</button>
      </div>
    </div>
  </div>

  <div class="flash" id="flash"></div>

  <script type="module">
    import * as THREE from "./lib/three.module.js";

    // -----------------------------
    // Aufgabenpool (genau 1 Fehler pro Satz)
    // wrong muss exakt so im Satz vorkommen
    // -----------------------------
    const TASKS = [
      // F√§lschlich gro√ü
      { sentence: "Gestern ging ich Schnell nach Hause, weil es regnete.", wrong: "Schnell", note: "Adverb klein: schnell." },
      { sentence: "Bitte stelle die Tasse Vorsichtig auf den Tisch.", wrong: "Vorsichtig", note: "Adverb klein: vorsichtig." },
      { sentence: "Der Lehrer erkl√§rte Ruhig die Aufgabe.", wrong: "Ruhig", note: "Adverb klein: ruhig." },
      { sentence: "Wir wollen Sp√§ter noch lernen.", wrong: "Sp√§ter", note: "Adverb klein: sp√§ter." },
      { sentence: "Wir sind Morgen um acht Uhr fertig.", wrong: "Morgen", note: "Zeitadverb klein: morgen." },

      // F√§lschlich klein (Nomen)
      { sentence: "Die maschine steht heute in der Werkstatt.", wrong: "maschine", note: "Nomen gro√ü: Maschine." },
      { sentence: "Im winter tragen viele Menschen warme Jacken.", wrong: "winter", note: "Nomen gro√ü: Winter." },
      { sentence: "Er legte das buch auf den Tisch.", wrong: "buch", note: "Nomen gro√ü: Buch." },
      { sentence: "Das m√§dchen lachte laut und rannte weg.", wrong: "m√§dchen", note: "Nomen gro√ü: M√§dchen." },

      // H√§ufige Rechtschreibfehler
      { sentence: "Er giebt mir jeden Tag eine neue Aufgabe.", wrong: "giebt", note: "Richtig: gibt." },
      { sentence: "Die Maschiene ist sehr laut, aber zuverl√§ssig.", wrong: "Maschiene", note: "Richtig: Maschine." },
      { sentence: "Ich glaube, das du heute fr√ºher kommst.", wrong: "das", note: "Konjunktion: dass." },
      { sentence: "Ich habe dich vieleicht falsch verstanden.", wrong: "vieleicht", note: "Richtig: vielleicht." },
      { sentence: "Er war ent√§uscht von dem Ergebnis.", wrong: "ent√§uscht", note: "Richtig: entt√§uscht." },
      { sentence: "Das ist das Beste, was ich je gesehen habe, seid gestern.", wrong: "seid", note: "Zeitangabe: seit." },
      { sentence: "Sie hat das Problem wiederspiegeln wollen, aber es gelang nicht.", wrong: "wiederspiegeln", note: "Richtig: widerspiegeln." }
    ];

    // -----------------------------
    // Bossrunde (2 Fehler pro Satz) ‚Äì beide m√ºssen weg
    // wrongs: exakte Schreibweise im Satz
    // -----------------------------
    const BOSS_TASKS = [
      {
        sentence: "Ich glaube, das du die Maschiene schon morgen reparierst.",
        wrongs: ["das", "Maschiene"],
        note: "Konjunktion: dass ¬∑ Richtig: Maschine."
      },
      {
        sentence: "Er giebt zu, das er vieleicht zu Laut gesprochen hat.",
        wrongs: ["giebt", "das", "vieleicht", "Laut"] // zu viele ‚Äì wir brauchen genau 2 ‚Üí wir nehmen nur 2:
      },
      {
        sentence: "Er giebt zu, das er vieleicht zu laut gesprochen hat.",
        wrongs: ["giebt", "das"],
        note: "Richtig: gibt ¬∑ Konjunktion: dass."
      },
      {
        sentence: "Im winter ist die Maschiene oft kaputt, aber das passiert selten.",
        wrongs: ["winter", "Maschiene"],
        note: "Nomen: Winter ¬∑ Richtig: Maschine."
      }
    ].filter(b => b.wrongs.length === 2);

    // Shuffle helper
    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
      return arr;
    }
    shuffle(TASKS);
    shuffle(BOSS_TASKS);

    // -----------------------------
    // State
    // -----------------------------
    const state = {
      idx: 0,
      score: 0,
      streak: 0,
      ammoMax: 12,
      ammo: 12,
      practice: false,
      done: 0,
      total: TASKS.length,
      locked: false,
      paused: true,
      level: 1,

      bossActive: false,
      bossHitsRemaining: 0,
      bossBonusAwarded: false
    };

    // DOM
    const $ = (q)=>document.querySelector(q);
    const ammoEl = $("#ammo");
    const ammoMaxEl = $("#ammoMax");
    const scoreEl = $("#score");
    const streakEl = $("#streak");
    const sentenceEl = $("#sentence");
    const hintEl = $("#hint");
    const overlay = $("#overlay");
    const flash = $("#flash");
    const progress = $("#progress");
    const levelEl = $("#level");
    const bossTag = $("#bossTag");
    const missionTitle = $("#missionTitle");

    ammoMaxEl.textContent = String(state.ammoMax);

    function flashMsg(msg, good=true){
      flash.textContent = msg;
      flash.classList.add("show");
      flash.classList.toggle("good", good);
      flash.classList.toggle("bad", !good);
      clearTimeout(flash._t);
      flash._t = setTimeout(()=>flash.classList.remove("show"), 900);
    }

    function uiUpdate(){
      ammoEl.textContent = String(state.ammo);
      scoreEl.textContent = String(state.score);
      streakEl.textContent = String(state.streak);
      levelEl.textContent = String(state.level);

      // progress: Boss z√§hlt als extra "letzter Schritt"
      const denom = state.total + 1;
      const numer = state.done + (state.bossActive ? 1 : 0);
      progress.style.width = `${Math.round((numer/denom)*100)}%`;

      bossTag.style.display = state.bossActive ? "inline" : "none";
      missionTitle.textContent = state.bossActive
        ? `üëë Bossrunde: Schie√üe beide fehlerhaften W√∂rter weg (${state.bossHitsRemaining} √ºbrig)`
        : "Auftrag: Schie√üe das fehlerhafte Wort (Gro√ü/Klein oder Rechtschreibung)";
    }

    // Root: Startseite
    $("#homeBtn").addEventListener("click", ()=>{ window.location.href = "index.html"; });

    $("#resetBtn").addEventListener("click", ()=>{
      hardReset();
      overlay.style.display = "grid";
      state.paused = true;
      unlockPointer();
      restoreOverlayText();
    });

    $("#startBtn").addEventListener("click", ()=>{
      state.practice = false;
      startGame();
    });
    $("#practiceBtn").addEventListener("click", ()=>{
      state.practice = true;
      startGame();
    });

    function restoreOverlayText(){
      overlay.querySelector("h2").textContent = "Wasserpistolen-Entspannung (mit Grammatik-Bonus) üòÑ";
      overlay.querySelector("p").innerHTML =
        `Im Satz unten ist <b>genau ein Wort</b> falsch: entweder <b>Gro√ü/Klein</b> oder <b>Rechtschreibung</b>
         (z.B. <i>giebt</i>, <i>Maschiene</i>, <i>seid/seit</i>, <i>dass/das</i> ‚Ä¶).
         <b>Schie√üe dieses Wort</b> als Ziel im Raum weg.<br><br>
         <b>Bonus:</b> Am Ende kommt eine <b>Bossrunde</b> mit <b>2 Fehlern</b> (beide treffen = +30).`;
    }

    // -----------------------------
    // Three.js setup
    // -----------------------------
    const canvas = $("#c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b1220, 14, 55);

    const camera = new THREE.PerspectiveCamera(72, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 1.7, 8);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x223355, 0.85));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(7, 12, 5);
    scene.add(dirLight);

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(240, 240),
      new THREE.MeshStandardMaterial({ color: 0x0b1220, roughness: 0.95, metalness: 0.02 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    scene.add(ground);

    // Scenery poles
    const poles = new THREE.Group();
    scene.add(poles);
    for(let i=0;i<28;i++){
      const h = 1.2 + Math.random()*3.5;
      const m = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.10, h, 10),
        new THREE.MeshStandardMaterial({ color: 0x1a2a44, roughness: 0.75 })
      );
      const a = Math.random()*Math.PI*2;
      const r = 12 + Math.random()*24;
      m.position.set(Math.cos(a)*r, h/2, Math.sin(a)*r);
      poles.add(m);
    }

    // -----------------------------
    // 3D Wasserpistole
    // -----------------------------
    const gun = new THREE.Group();
    camera.add(gun);
    scene.add(camera);

    function makeGun(){
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x7c3aed, roughness: 0.35, metalness: 0.05 });
      const darkMat = new THREE.MeshStandardMaterial({ color: 0x101827, roughness: 0.7, metalness: 0.05 });
      const tankMat = new THREE.MeshStandardMaterial({ color: 0x66ccff, roughness: 0.2, metalness: 0.02, transparent:true, opacity:0.75 });
      const accentMat = new THREE.MeshStandardMaterial({ color: 0x22c55e, roughness: 0.35, metalness: 0.04 });

      const body = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.20, 0.82), bodyMat);
      body.position.set(0.42, -0.28, -0.80);

      const grip = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.30, 0.26), darkMat);
      grip.position.set(0.52, -0.46, -0.55);
      grip.rotation.x = 0.12;

      const triggerGuard = new THREE.Mesh(new THREE.TorusGeometry(0.09, 0.02, 10, 20), darkMat);
      triggerGuard.position.set(0.56, -0.40, -0.62);
      triggerGuard.rotation.x = Math.PI/2;

      const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.55, 14), darkMat);
      barrel.rotation.x = Math.PI/2;
      barrel.position.set(0.38, -0.26, -1.18);

      const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.055, 0.10, 14), accentMat);
      nozzle.rotation.x = Math.PI/2;
      nozzle.position.set(0.38, -0.26, -1.45);

      const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.38, 16), tankMat);
      tank.rotation.z = Math.PI/2;
      tank.position.set(0.20, -0.18, -0.72);

      const sight = new THREE.Mesh(new THREE.BoxGeometry(0.10, 0.06, 0.12), accentMat);
      sight.position.set(0.40, -0.16, -0.92);

      gun.add(body, grip, triggerGuard, barrel, nozzle, tank, sight);
      gun.rotation.set(0.02, -0.06, 0.00);
      gun.userData.nozzle = nozzle;
    }
    makeGun();

    // Muzzle flash
    const muzzleFlash = new THREE.Mesh(
      new THREE.SphereGeometry(0.06, 10, 10),
      new THREE.MeshStandardMaterial({ color: 0x66ccff, emissive: 0x66ccff, emissiveIntensity: 1.8, transparent:true, opacity:0.0 })
    );
    gun.add(muzzleFlash);
    muzzleFlash.position.copy(gun.userData.nozzle.position).add(new THREE.Vector3(0,0,-0.05));

    // -----------------------------
    // Pointer lock FPS
    // -----------------------------
    let yaw = 0, pitch = 0;
    const vel = new THREE.Vector3();
    const moveDir = new THREE.Vector3();
    const keys = { w:false,a:false,s:false,d:false, shift:false };

    function lockPointer(){ if(document.pointerLockElement !== canvas) canvas.requestPointerLock(); }
    function unlockPointer(){ if(document.pointerLockElement) document.exitPointerLock(); }

    document.addEventListener("pointerlockchange", ()=>{
      state.locked = (document.pointerLockElement === canvas);
      if(!state.locked && !state.paused){
        overlay.style.display = "grid";
        state.paused = true;
        restoreOverlayText();
      }
    });

    document.addEventListener("mousemove", (e)=>{
      if(!state.locked) return;
      yaw -= (e.movementX || 0) * 0.0022;
      pitch -= (e.movementY || 0) * 0.0022;
      pitch = Math.max(-1.2, Math.min(1.2, pitch));
      camera.rotation.set(pitch, yaw, 0, "YXZ");
    });

    document.addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      if(k==="w") keys.w=true;
      if(k==="a") keys.a=true;
      if(k==="s") keys.s=true;
      if(k==="d") keys.d=true;
      if(k==="shift") keys.shift=true;

      if(k==="r"){
        state.ammo = state.ammoMax;
        uiUpdate();
        flashMsg("üîÑ Nachgeladen", true);
      }
    });

    document.addEventListener("keyup", (e)=>{
      const k = e.key.toLowerCase();
      if(k==="w") keys.w=false;
      if(k==="a") keys.a=false;
      if(k==="s") keys.s=false;
      if(k==="d") keys.d=false;
      if(k==="shift") keys.shift=false;
    });

    canvas.addEventListener("mousedown", (e)=>{
      if(e.button !== 0) return;
      if(state.paused){
        overlay.style.display = "none";
        state.paused = false;
        lockPointer();
        return;
      }
      if(!state.locked){ lockPointer(); return; }
      shoot();
    });

    window.addEventListener("resize", ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    // -----------------------------
    // Targets + cover
    // -----------------------------
    const targetGroup = new THREE.Group();
    scene.add(targetGroup);

    const coverGroup = new THREE.Group();
    scene.add(coverGroup);

    const coverMat = new THREE.MeshStandardMaterial({ color: 0x15233a, roughness: 0.9, metalness: 0.02 });
    function buildCovers(){
      coverGroup.clear();
      const placements = [
        { x:-5.2, z:-9.8, w:1.2, h:2.6, d:0.7 },
        { x: 0.0, z:-10.6, w:1.6, h:3.0, d:0.9 },
        { x: 5.0, z:-9.4, w:1.1, h:2.2, d:0.7 },
        { x:-2.6, z:-13.0, w:1.4, h:2.8, d:0.8 },
        { x: 2.6, z:-13.4, w:1.3, h:2.6, d:0.8 }
      ];
      for(const p of placements){
        const m = new THREE.Mesh(new THREE.BoxGeometry(p.w,p.h,p.d), coverMat);
        m.position.set(p.x, p.h/2, p.z);
        coverGroup.add(m);
      }
    }
    buildCovers();

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function makeWordSprite(text, isWrong){
      const c = document.createElement("canvas");
      const ctx = c.getContext("2d");
      ctx.font = "700 44px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      const padX = 26;
      const w = Math.ceil(ctx.measureText(text).width) + padX*2;
      c.width = Math.min(1024, Math.max(260, w));
      c.height = 128;

      ctx.clearRect(0,0,c.width,c.height);

      ctx.fillStyle = "rgba(0,0,0,0.35)";
      roundRect(ctx, 10, 20, c.width-20, c.height-40, 28);
      ctx.fill();

      ctx.lineWidth = 6;
      ctx.strokeStyle = isWrong ? "rgba(239,68,68,0.70)" : "rgba(255,255,255,0.22)";
      roundRect(ctx, 10, 20, c.width-20, c.height-40, 28);
      ctx.stroke();

      ctx.fillStyle = "rgba(231,238,252,0.95)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, c.width/2, c.height/2);

      if(isWrong){
        ctx.fillStyle = "rgba(239,68,68,0.9)";
        ctx.font = "900 28px ui-monospace, Menlo, Consolas, monospace";
        ctx.fillText("!", c.width-34, 38);
      }

      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = 8;

      const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false });
      const spr = new THREE.Sprite(mat);

      const scaleX = (c.width / 512) * 2.25;
      spr.scale.set(scaleX, 0.88, 1);

      spr.userData.text = text;
      spr.userData.isWrong = isWrong;
      spr.userData.alive = true;

      // movement
      spr.userData.base = new THREE.Vector3();
      spr.userData.phase = Math.random()*Math.PI*2;
      spr.userData.speed = 0.55 + Math.random()*0.6;
      spr.userData.ampX = 0.35 + Math.random()*0.55;
      spr.userData.ampY = 0.18 + Math.random()*0.32;
      spr.userData.ampZ = 0.25 + Math.random()*0.55;

      // hide behavior
      spr.userData.hideT = 1.4 + Math.random()*2.2;
      spr.userData.hidden = false;

      return spr;
    }

    function disposeSprite(spr){
      if(spr.material?.map) spr.material.map.dispose();
      if(spr.material) spr.material.dispose();
    }

    function clearTargets(){
      for(const o of [...targetGroup.children]) {
        targetGroup.remove(o);
        disposeSprite(o);
      }
    }

    function tokenize(sentence){
      return sentence.split(" ").filter(Boolean);
    }

    function spawnNormal(i){
      state.bossActive = false;
      state.bossHitsRemaining = 0;
      state.bossBonusAwarded = false;

      clearTargets();
      const t = TASKS[i % TASKS.length];
      sentenceEl.textContent = t.sentence;

      state.level = 1 + Math.floor(state.done / 6);

      const info = t.note ? `Hinweis nach Treffer: ${t.note}` : "";
      hintEl.innerHTML = state.practice
        ? `√úbungsmodus: keine Minuspunkte. Genau <b>1 Wort</b> ist falsch. ${info ? `<span style="opacity:.85">(${info})</span>` : ""}`
        : `Treffer-Regel: ‚úÖ richtig +10 (+Streak), ‚ùå falsch ‚àí5 (Streak reset). ${info ? `<span style="opacity:.85">(${info})</span>` : ""}`;

      const tokens = tokenize(t.sentence);
      const wrong = t.wrong;

      const baseZ = -10 - Math.min(6, state.level) * 0.55;
      const radius = 8.2 + Math.min(4, state.level) * 0.35;
      const yTop = 3.05;
      const yBottom = 1.45;

      const n = tokens.length;
      const split = n > 9 ? Math.ceil(n/2) : n;

      for(let k=0;k<n;k++){
        const tok = tokens[k];
        const isWrong = tok.includes(wrong);

        const spr = makeWordSprite(tok, isWrong);

        const row = (n > 9 && k >= split) ? 1 : 0;
        const inRowIndex = row ? (k - split) : k;
        const inRowCount = row ? (n - split) : split;

        const a0 = -0.98, a1 = 0.98;
        const a = inRowCount === 1 ? 0 : THREE.MathUtils.lerp(a0, a1, inRowIndex/(inRowCount-1));

        const x = Math.sin(a) * radius;
        const z = Math.cos(a) * radius + baseZ;
        const y = row ? yBottom : yTop;

        spr.position.set(x, y, z);
        spr.userData.base.set(x,y,z);

        targetGroup.add(spr);
      }

      uiUpdate();
    }

    function spawnBoss(){
      state.bossActive = true;
      state.bossBonusAwarded = false;

      clearTargets();
      const boss = BOSS_TASKS[0]; // bereits geshuffled
      state.bossHitsRemaining = boss.wrongs.length;

      sentenceEl.textContent = boss.sentence;
      hintEl.innerHTML = state.practice
        ? `üëë <b>Bossrunde:</b> <b>2 Fehler</b> im Satz. Triff beide (kein Abzug im √úbungsmodus). <span style="opacity:.85">(${boss.note || ""})</span>`
        : `üëë <b>Bossrunde:</b> <b>2 Fehler</b> im Satz. Triff beide ‚Üí <b>+30 Bonus</b>. <span style="opacity:.85">(${boss.note || ""})</span>`;

      // Boss = etwas schwerer
      state.level = Math.max(state.level, 4);

      const tokens = tokenize(boss.sentence);
      const wrongs = boss.wrongs;

      const baseZ = -12 - Math.min(7, state.level) * 0.60;
      const radius = 8.6 + Math.min(5, state.level) * 0.40;
      const yTop = 3.15;
      const yBottom = 1.55;

      const n = tokens.length;
      const split = n > 9 ? Math.ceil(n/2) : n;

      for(let k=0;k<n;k++){
        const tok = tokens[k];
        const isWrong = wrongs.some(w => tok.includes(w));

        const spr = makeWordSprite(tok, isWrong);

        // Boss-Ziele etwas schneller & mehr verstecken
        spr.userData.speed *= 1.25;
        spr.userData.ampX *= 1.25;
        spr.userData.ampY *= 1.15;
        spr.userData.ampZ *= 1.25;
        spr.userData.hideT *= 0.8;

        const row = (n > 9 && k >= split) ? 1 : 0;
        const inRowIndex = row ? (k - split) : k;
        const inRowCount = row ? (n - split) : split;

        const a0 = -0.98, a1 = 0.98;
        const a = inRowCount === 1 ? 0 : THREE.MathUtils.lerp(a0, a1, inRowIndex/(inRowCount-1));

        const x = Math.sin(a) * radius;
        const z = Math.cos(a) * radius + baseZ;
        const y = row ? yBottom : yTop;

        spr.position.set(x, y, z);
        spr.userData.base.set(x,y,z);

        targetGroup.add(spr);
      }

      uiUpdate();
      flashMsg("üëë Bossrunde gestartet! 2 Fehler!", true);
    }

    // -----------------------------
    // Shooting
    // -----------------------------
    const raycaster = new THREE.Raycaster();

    const streams = [];
    const dropGeo = new THREE.SphereGeometry(0.03, 8, 8);
    const dropBaseMat = new THREE.MeshStandardMaterial({ color: 0x66ccff, roughness: 0.25, metalness: 0.02, transparent:true, opacity:0.9 });

    function addWaterBurst(){
      const nozzle = gun.userData.nozzle;
      const muzzleWorld = new THREE.Vector3();
      nozzle.getWorldPosition(muzzleWorld);

      muzzleFlash.position.copy(nozzle.position).add(new THREE.Vector3(0,0,-0.05));
      muzzleFlash.material.opacity = 0.9;

      const dir = camera.getWorldDirection(new THREE.Vector3()).normalize();

      const count = 14;
      for(let i=0;i<count;i++){
        const m = new THREE.Mesh(dropGeo, dropBaseMat.clone());
        m.position.copy(muzzleWorld);

        const spread = 0.06 + Math.random()*0.06;
        const jitter = new THREE.Vector3(
          (Math.random()-0.5)*spread,
          (Math.random()-0.5)*spread,
          (Math.random()-0.5)*spread
        );

        const v = dir.clone().multiplyScalar(16 + Math.random()*6).add(jitter.multiplyScalar(20));
        m.userData.v = v;
        m.userData.life = 0.35 + Math.random()*0.20;

        scene.add(m);
        streams.push(m);
      }
    }

    function shoot(){
      if(state.ammo <= 0){
        flashMsg("üíß Leer! (R zum Nachladen)", false);
        return;
      }
      state.ammo--;
      uiUpdate();

      addWaterBurst();

      const origin = camera.getWorldPosition(new THREE.Vector3());
      const direction = camera.getWorldDirection(new THREE.Vector3()).normalize();

      raycaster.set(origin, direction);
      raycaster.far = 120;

      const hits = raycaster.intersectObjects([...coverGroup.children, ...targetGroup.children], false);
      if(!hits.length){
        flashMsg("üí¶ Daneben!", false);
        return;
      }

      const hit = hits[0].object;

      if(coverGroup.children.includes(hit)){
        flashMsg("üß± Geblockt! (Deckung)", false);
        return;
      }

      if(!hit.userData.alive || !hit.visible){
        flashMsg("üí¶ Fast!", false);
        return;
      }

      const isWrong = !!hit.userData.isWrong;

      if(isWrong){
        hit.userData.alive = false;
        targetGroup.remove(hit);
        disposeSprite(hit);

        // scoring
        const bonus = Math.min(12, state.streak);
        state.score += 10 + bonus;
        state.streak += 1;

        if(state.bossActive){
          state.bossHitsRemaining = Math.max(0, state.bossHitsRemaining - 1);
          uiUpdate();
          flashMsg(`‚úÖ Boss-Treffer! (${state.bossHitsRemaining} √ºbrig)`, true);

          if(state.bossHitsRemaining === 0 && !state.bossBonusAwarded){
            state.bossBonusAwarded = true;
            state.score += 30;
            uiUpdate();
            flashMsg("üëë Boss besiegt! +30 Bonus!", true);
            setTimeout(()=>endGame(true), 650);
          }
          return;
        }

        state.done += 1;

        if(state.done % 6 === 0){
          flashMsg(`‚úÖ Treffer! Level ${1 + Math.floor(state.done/6)}!`, true);
        }else{
          flashMsg("‚úÖ Treffer!", true);
        }

        if(state.done >= state.total){
          // Start boss round
          setTimeout(()=>spawnBoss(), 520);
        }else{
          state.idx += 1;
          setTimeout(()=>spawnNormal(state.idx), 420);
        }
      }else{
        if(!state.practice){
          state.score = Math.max(0, state.score - 5);
          state.streak = 0;
        }
        flashMsg("‚ùå Falsches Wort!", false);
        uiUpdate();
      }
    }

    // -----------------------------
    // Game flow
    // -----------------------------
    function hardReset(){
      state.idx = 0;
      state.score = 0;
      state.streak = 0;
      state.ammo = state.ammoMax;
      state.done = 0;
      state.level = 1;
      state.bossActive = false;
      state.bossHitsRemaining = 0;
      state.bossBonusAwarded = false;

      camera.position.set(0, 1.7, 8);
      yaw = 0; pitch = 0;
      camera.rotation.set(0,0,0);

      uiUpdate();
      spawnNormal(0);
    }

    function startGame(){
      overlay.style.display = "none";
      state.paused = false;
      hardReset();
      lockPointer();
    }

    function endGame(wonBoss=false){
      unlockPointer();
      state.paused = true;
      overlay.style.display = "grid";
      overlay.querySelector("h2").textContent = wonBoss ? "Bossrunde geschafft! üèÜ" : "Runde geschafft! üéâ";
      overlay.querySelector("p").innerHTML =
        `Ergebnis: <b>${state.score}</b> Punkte ¬∑ Streak: <b>${state.streak}</b><br>
         ${wonBoss ? "Bonus wurde vergeben: <b>+30</b> ‚úÖ<br>" : ""}
         Du kannst neu starten oder √úbungsmodus w√§hlen.`;
      flashMsg(wonBoss ? "üèÜ Perfekt! Boss down." : "üéâ Fertig!", true);
    }

    // -----------------------------
    // Movement + target motion + water
    // -----------------------------
    function updateMovement(dt){
      if(state.locked && !state.paused){
        const speed = keys.shift ? 6.4 : 4.4;

        moveDir.set(0,0,0);
        if(keys.w) moveDir.z -= 1;
        if(keys.s) moveDir.z += 1;
        if(keys.a) moveDir.x -= 1;
        if(keys.d) moveDir.x += 1;

        if(moveDir.lengthSq() > 0){
          moveDir.normalize();
          const forward = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0, yaw, 0));
          const right = new THREE.Vector3(1,0,0).applyEuler(new THREE.Euler(0, yaw, 0));
          vel.x = (right.x * moveDir.x + forward.x * moveDir.z) * speed;
          vel.z = (right.z * moveDir.x + forward.z * moveDir.z) * speed;
        }else{
          vel.x *= 0.85;
          vel.z *= 0.85;
        }

        camera.position.x += vel.x * dt;
        camera.position.z += vel.z * dt;

        camera.position.x = THREE.MathUtils.clamp(camera.position.x, -40, 40);
        camera.position.z = THREE.MathUtils.clamp(camera.position.z, -42, 20);
        camera.position.y = 1.7;
      }
    }

    function updateTargets(t, dt){
      for(const spr of targetGroup.children){
        spr.quaternion.copy(camera.quaternion);

        const L = Math.min(7, state.level);
        const sp = spr.userData.speed * (1.0 + L*0.10);
        const ph = spr.userData.phase;

        const bx = spr.userData.base.x;
        const by = spr.userData.base.y;
        const bz = spr.userData.base.z;

        spr.position.x = bx + Math.sin(t*sp + ph) * spr.userData.ampX * (1.0 + L*0.15);
        spr.position.y = by + Math.sin(t*sp*1.25 + ph*1.7) * spr.userData.ampY * (1.0 + L*0.12);
        spr.position.z = bz + Math.cos(t*sp*0.9 + ph*0.7) * spr.userData.ampZ * (1.0 + L*0.18);

        spr.userData.hideT -= dt * (1.0 + L*0.22);
        if(!spr.userData.hidden && spr.userData.hideT <= 0){
          spr.userData.hidden = true;
          spr.visible = false;
          spr.userData.hideT = 0.55 + Math.random()*0.65;
        }else if(spr.userData.hidden && spr.userData.hideT <= 0){
          spr.userData.hidden = false;
          spr.visible = true;
          spr.userData.hideT = 1.1 + Math.random()*2.2;
        }
      }
    }

    function updateWater(dt){
      muzzleFlash.material.opacity *= Math.pow(0.02, dt);
      muzzleFlash.material.opacity = Math.max(0, muzzleFlash.material.opacity - dt*2.2);

      for(let i=streams.length-1;i>=0;i--){
        const m = streams[i];
        m.userData.life -= dt;
        m.position.addScaledVector(m.userData.v, dt);
        m.userData.v.y -= 10.0*dt;
        if(m.material) m.material.opacity = Math.max(0, m.userData.life / 0.6);

        if(m.userData.life <= 0){
          scene.remove(m);
          if(m.material) m.material.dispose();
          streams.splice(i,1);
        }
      }
    }

    const clock = new THREE.Clock();
    function loop(){
      const dt = Math.min(0.033, clock.getDelta());
      const t = clock.getElapsedTime();

      updateMovement(dt);
      updateTargets(t, dt);
      updateWater(dt);

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    // Init
    hardReset();
    uiUpdate();
    loop();
  </script>
</body>
</html>