<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HoS ¬∑ 3D Wasserpistole (Impact + Hint nach 2 Fehlern)</title>
  <style>
    :root{
      --ink:#e7eefc; --muted:#b8c2dd; --line: rgba(255,255,255,.14);
      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); color:var(--ink);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(124,58,237,.28), transparent 60%),
        radial-gradient(900px 600px at 80% 20%, rgba(34,197,94,.20), transparent 55%),
        radial-gradient(1000px 700px at 50% 110%, rgba(245,158,11,.12), transparent 55%),
        #09101d;
      height:100vh; overflow:hidden; user-select:none;
    }
    canvas{display:block;width:100%;height:100%}

    .hud{position:fixed; inset:0; pointer-events:none; display:flex; flex-direction:column; padding:14px; gap:10px;}
    .topbar{display:flex; gap:10px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;}
    .pill{
      pointer-events:auto; display:inline-flex; gap:10px; align-items:center; flex-wrap:wrap;
      padding:10px 12px; border-radius:999px; border:1px solid var(--line);
      background: rgba(0,0,0,.22); box-shadow: var(--shadow); backdrop-filter: blur(10px);
      font-size:13px; color:var(--muted);
    }
    .pill b{color:var(--ink)}
    .btn{
      pointer-events:auto; appearance:none; border:1px solid var(--line); background: rgba(255,255,255,.06);
      color:var(--ink); padding:10px 12px; border-radius:14px; cursor:pointer;
      font-size:13px; box-shadow: 0 12px 35px rgba(0,0,0,.22);
    }
    .btn:hover{ background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.22); }

    .center{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:24px; height:24px; display:grid; place-items:center; opacity:.92;}
    .cross{width:24px; height:24px; position:relative;}
    .cross:before,.cross:after{
      content:""; position:absolute; left:50%; top:50%;
      background: rgba(231,238,252,.92);
      transform:translate(-50%,-50%);
      border-radius:2px;
      box-shadow: 0 0 0 4px rgba(255,255,255,.06);
    }
    .cross:before{ width:22px; height:2px; }
    .cross:after{ width:2px; height:22px; }

    .bottom{margin-top:auto; display:flex; justify-content:center;}
    .card{
      pointer-events:auto;
      width:min(1100px, calc(100vw - 24px));
      border:1px solid var(--line);
      background: rgba(0,0,0,.24);
      box-shadow: var(--shadow);
      border-radius:22px;
      padding:12px 14px;
      backdrop-filter: blur(10px);
    }
    .title{display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:8px;}
    .title h1{margin:0; font-size:14px; letter-spacing:.25px; text-transform:uppercase; color:var(--muted);}
    .sentence{margin:0; font-size:18px; line-height:1.35; color:var(--ink);}
    .hint{margin:8px 0 0; font-size:12px; color:var(--muted); line-height:1.5;}
    .kbd{
      font-family:var(--mono); font-size:11px; padding:4px 6px; border-radius:10px;
      border:1px solid var(--line); background: rgba(0,0,0,.22); color:var(--ink);
    }
    .bar{height:10px; border-radius:999px; border:1px solid var(--line); background: rgba(0,0,0,.18); overflow:hidden; margin-top:10px;}
    .fill{height:100%; width:0%; background: linear-gradient(90deg, rgba(34,197,94,.85), rgba(124,58,237,.85));}

    .overlay{position:fixed; inset:0; display:grid; place-items:center; background: rgba(0,0,0,.45); backdrop-filter: blur(8px);}
    .panel{
      width:min(780px, calc(100vw - 24px));
      border:1px solid var(--line);
      border-radius:26px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      box-shadow: var(--shadow);
      padding:18px 18px 16px;
      text-align:left;
    }
    .badge{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 10px; border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color:var(--muted); font-size:12px;
    }
    .panelHead{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:10px;}
    .panel h2{margin:8px 0 8px; font-size:22px; letter-spacing:.2px;}
    .panel p{margin:0 0 10px; color:var(--muted); line-height:1.55;}
    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px;}
    @media(max-width:760px){ .grid2{grid-template-columns:1fr} }
    .note{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius:18px;
      padding:12px;
      color:var(--muted);
      font-size:13px;
      line-height:1.5;
    }
    .note b{color:var(--ink)}

    .flash{
      position:fixed; left:50%; top:14px; transform:translateX(-50%);
      padding:10px 12px; border-radius:14px; border:1px solid var(--line);
      background: rgba(0,0,0,.35); color:var(--ink); font-size:13px; box-shadow: var(--shadow);
      opacity:0; pointer-events:none; transition: opacity .15s ease, transform .15s ease;
      backdrop-filter: blur(10px);
    }
    .flash.show{opacity:1; transform:translateX(-50%) translateY(-2px);}
    .good{color:rgba(190,255,215,.95)}
    .bad{color:rgba(255,200,200,.95)}
  </style>
</head>

<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="topbar">
      <div class="pill">
        <span>üî´ Wasserpistole (3D)</span>
        <span>Munition: <b id="ammo">12</b>/<span id="ammoMax">12</span> <span class="kbd">R</span></span>
        <span>Score: <b id="score">0</b></span>
        <span>Streak: <b id="streak">0</b></span>
        <span>Fails: <b id="fails">0</b></span>
        <span>Level: <b id="level">1</b></span>
        <span id="bossTag" style="display:none;color:rgba(245,158,11,.95)">üëë BOSS</span>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn" id="homeBtn">üè† Startseite</button>
        <button class="btn" id="resetBtn">üîÅ Neustart</button>
      </div>
    </div>

    <div class="center"><div class="cross"></div></div>

    <div class="bottom">
      <div class="card">
        <div class="title">
          <h1 id="missionTitle">Auftrag: Schie√üe das fehlerhafte Wort aus dem Satz heraus</h1>
          <div class="pill" style="padding:8px 10px; font-size:12px;">
            WASD ¬∑ Maus ¬∑ Klick schie√üen ¬∑ Wasserstrahl ¬∑ Impact ¬∑ Hint nach 2 Fehlversuchen
          </div>
        </div>
        <p class="sentence" id="sentence">‚Äî</p>
        <p class="hint" id="hint">Tipp: Genau <b>1 Wort</b> ist falsch. (Hint nach 2 Fehlversuchen)</p>
        <div class="bar"><div class="fill" id="progress"></div></div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel">
      <div class="panelHead">
        <span class="badge">HoS ¬∑ 3D Spiel ¬∑ Deutsch</span>
        <span class="badge">Laptop Mode ‚úÖ</span>
      </div>
      <h2>Jetzt wirklich ein Deutsch-Spiel üòÑ</h2>
      <p>
        Das falsche Wort hat <b>keine Markierung</b> ‚Äì du musst lesen.
        Nach <b>2 Fehlversuchen</b> kommt ein kurzer Hint (Glow-Puls am richtigen Wort).
      </p>
      <div class="grid2">
        <div class="note">
          <b>Steuerung</b><br>
          ‚Ä¢ <span class="kbd">Klick</span> schie√üen<br>
          ‚Ä¢ <span class="kbd">W</span> vorw√§rts / <span class="kbd">S</span> r√ºckw√§rts<br>
          ‚Ä¢ Maus schauen (Pointer Lock)<br>
          ‚Ä¢ <span class="kbd">R</span> nachladen<br>
          ‚Ä¢ <span class="kbd">ESC</span> Maus frei
        </div>
        <div class="note">
          <b>Punkte</b><br>
          ‚úÖ richtig: +10 + Streak-Bonus<br>
          ‚ùå falsch: ‚àí5 (au√üer √úbungsmodus) + Streak reset<br>
          üîé Hint: nach 2 Fehlversuchen (kurz)
        </div>
      </div>
      <div style="display:flex; gap:10px; margin-top:14px; flex-wrap:wrap;">
        <button class="btn" id="startBtn">‚ñ∂ Start</button>
        <button class="btn" id="practiceBtn">üß™ √úbungsmodus (ohne Abzug)</button>
      </div>
    </div>
  </div>

  <div class="flash" id="flash"></div>

  <script type="module">
    import * as THREE from "./lib/three.module.js";

    // -----------------------------
    // Aufgaben
    // -----------------------------
    const TASKS = [
      { sentence: "Die Maschiene ist sehr laut, aber zuverl√§ssig.", wrong: "Maschiene" },
      { sentence: "Er giebt mir jeden Tag eine neue Aufgabe.", wrong: "giebt" },
      { sentence: "Ich glaube, das du heute fr√ºher kommst.", wrong: "das" },
      { sentence: "Im winter tragen viele Menschen warme Jacken.", wrong: "winter" },
      { sentence: "Ich habe dich vieleicht falsch verstanden.", wrong: "vieleicht" },
      { sentence: "Das ist das Beste, was ich je gesehen habe, seid gestern.", wrong: "seid" },
      { sentence: "Er war ent√§uscht von dem Ergebnis.", wrong: "ent√§uscht" },
      { sentence: "Die maschine steht heute in der Werkstatt.", wrong: "maschine" },
      { sentence: "Sie hat das Problem wiederspiegeln wollen, aber es gelang nicht.", wrong: "wiederspiegeln" },
      { sentence: "Wir sind Morgen um acht Uhr fertig.", wrong: "Morgen" },
      { sentence: "Bitte stelle die Tasse Vorsichtig auf den Tisch.", wrong: "Vorsichtig" },
      { sentence: "Gestern ging ich Schnell nach Hause, weil es regnete.", wrong: "Schnell" },
    ];

    const BOSS_TASKS = [
      { sentence: "Ich glaube, das du die Maschiene schon morgen reparierst.", wrongs: ["das", "Maschiene"] },
      { sentence: "Im winter ist die Maschiene oft kaputt, aber das passiert selten.", wrongs: ["winter", "Maschiene"] }
    ];

    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
      return arr;
    }
    shuffle(TASKS); shuffle(BOSS_TASKS);

    // -----------------------------
    // State + UI
    // -----------------------------
    const state = {
      idx: 0, score: 0, streak: 0,
      ammoMax: 12, ammo: 12,
      practice: false,
      done: 0, total: TASKS.length,
      locked: false, paused: true,
      level: 1,
      bossActive: false, bossHitsRemaining: 0, bossBonusAwarded: false,
      failsThisSentence: 0,
      bossIdx: 0
    };

    const $ = (q)=>document.querySelector(q);
    const ammoEl = $("#ammo"), ammoMaxEl = $("#ammoMax");
    const scoreEl = $("#score"), streakEl = $("#streak");
    const failsEl = $("#fails"), levelEl = $("#level");
    const sentenceEl = $("#sentence"), hintEl = $("#hint");
    const overlay = $("#overlay"), flash = $("#flash");
    const progress = $("#progress");
    const bossTag = $("#bossTag"), missionTitle = $("#missionTitle");

    ammoMaxEl.textContent = String(state.ammoMax);

    function flashMsg(msg, good=true){
      flash.textContent = msg;
      flash.classList.add("show");
      flash.classList.toggle("good", good);
      flash.classList.toggle("bad", !good);
      clearTimeout(flash._t);
      flash._t = setTimeout(()=>flash.classList.remove("show"), 950);
    }

    function uiUpdate(){
      ammoEl.textContent = String(state.ammo);
      scoreEl.textContent = String(state.score);
      streakEl.textContent = String(state.streak);
      failsEl.textContent = String(state.failsThisSentence);
      levelEl.textContent = String(state.level);

      const denom = state.total + 1;
      const numer = state.done + (state.bossActive ? 1 : 0);
      progress.style.width = `${Math.round((numer/denom)*100)}%`;

      bossTag.style.display = state.bossActive ? "inline" : "none";
      missionTitle.textContent = state.bossActive
        ? `üëë Bossrunde: ${state.bossHitsRemaining} Fehler √ºbrig`
        : "Auftrag: Schie√üe das fehlerhafte Wort aus dem Satz heraus";
    }

    $("#homeBtn").addEventListener("click", ()=>{ window.location.href = "index.html"; });
    $("#resetBtn").addEventListener("click", ()=>{
      hardReset();
      overlay.style.display = "grid";
      state.paused = true;
      unlockPointer();
    });
    $("#startBtn").addEventListener("click", ()=>{ state.practice=false; startGame(); });
    $("#practiceBtn").addEventListener("click", ()=>{ state.practice=true; startGame(); });

    // -----------------------------
    // Three.js
    // -----------------------------
    const canvas = $("#c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.45;

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b1220, 8, 85);

    const camera = new THREE.PerspectiveCamera(72, innerWidth/innerHeight, 0.1, 400);
    camera.position.set(0, 1.7, 6.0);

    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    scene.add(new THREE.HemisphereLight(0xffffff, 0x334466, 0.95));

    const key = new THREE.DirectionalLight(0xffffff, 1.2);
    key.position.set(8, 12, 6);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0x9fd7ff, 0.55);
    fill.position.set(-10, 6, -8);
    scene.add(fill);

    function makeGridTex(){
      const c = document.createElement("canvas");
      c.width = 512; c.height = 512;
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#0b1220";
      ctx.fillRect(0,0,512,512);

      ctx.strokeStyle = "rgba(255,255,255,0.06)";
      ctx.lineWidth = 1;
      for(let i=0;i<=32;i++){
        const p=i*(512/32);
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,512); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(512,p); ctx.stroke();
      }
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 2;
      for(let i=0;i<=8;i++){
        const p=i*(512/8);
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,512); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(512,p); ctx.stroke();
      }
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(20,20);
      tex.anisotropy = 8;
      tex.needsUpdate = true;
      return tex;
    }

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(280,280),
      new THREE.MeshStandardMaterial({ map: makeGridTex(), color:0xffffff, roughness:0.95, metalness:0.0 })
    );
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // -----------------------------
    // Gun
    // -----------------------------
    const gun = new THREE.Group();
    camera.add(gun);
    scene.add(camera);

    function makeGun(){
      const bodyMat  = new THREE.MeshStandardMaterial({ color: 0x7c3aed, roughness: 0.25, metalness: 0.10 });
      const darkMat  = new THREE.MeshStandardMaterial({ color: 0x0b1220, roughness: 0.55, metalness: 0.08 });
      const accentMat= new THREE.MeshStandardMaterial({ color: 0x22c55e, roughness: 0.25, metalness: 0.06 });
      const tankMat  = new THREE.MeshStandardMaterial({ color: 0x66ccff, roughness: 0.12, metalness: 0.02, transparent:true, opacity:0.62 });

      const root = new THREE.Group();

      const body = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.24, 0.98), bodyMat);
      body.position.set(0.50, -0.30, -0.96);

      const front = new THREE.Mesh(new THREE.BoxGeometry(0.34, 0.18, 0.40), bodyMat);
      front.position.set(0.46, -0.27, -1.40);

      const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.070, 0.070, 0.72, 16), darkMat);
      barrel.rotation.x = Math.PI/2;
      barrel.position.set(0.44, -0.28, -1.68);

      const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.052, 0.065, 0.14, 16), accentMat);
      nozzle.rotation.x = Math.PI/2;
      nozzle.position.set(0.44, -0.28, -2.06);

      const grip = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.38, 0.30), darkMat);
      grip.position.set(0.64, -0.55, -0.68);
      grip.rotation.x = 0.12;

      const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.16, 0.52, 20), tankMat);
      tank.rotation.z = Math.PI/2;
      tank.position.set(0.16, -0.20, -0.86);

      root.add(body, front, barrel, nozzle, grip, tank);

      root.scale.setScalar(0.72);
      root.position.set(0.30, -0.32, 0.10);
      root.rotation.set(0.02, -0.06, 0);

      gun.add(root);
      gun.userData.nozzle = nozzle;
      gun.userData.root = root;
    }
    makeGun();

    // -----------------------------
    // Pointer lock + movement
    // -----------------------------
    let yaw = 0, pitch = 0;
    const vel = new THREE.Vector3();
    const moveDir = new THREE.Vector3();
    const keys = { w:false,a:false,s:false,d:false, shift:false };

    function lockPointer(){ if(document.pointerLockElement !== canvas) canvas.requestPointerLock(); }
    function unlockPointer(){ if(document.pointerLockElement) document.exitPointerLock(); }

    document.addEventListener("pointerlockchange", ()=>{
      state.locked = (document.pointerLockElement === canvas);
      if(!state.locked && !state.paused){
        overlay.style.display = "grid";
        state.paused = true;
      }
    });

    document.addEventListener("mousemove", (e)=>{
      if(!state.locked) return;
      yaw -= (e.movementX || 0) * 0.0022;
      pitch -= (e.movementY || 0) * 0.0022;
      pitch = Math.max(-1.2, Math.min(1.2, pitch));
      camera.rotation.set(pitch, yaw, 0, "YXZ");
    });

    document.addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      if(k==="w") keys.w=true;
      if(k==="a") keys.a=true;
      if(k==="s") keys.s=true;
      if(k==="d") keys.d=true;
      if(k==="shift") keys.shift=true;

      if(k==="r"){
        state.ammo = state.ammoMax;
        uiUpdate();
        flashMsg("üîÑ Nachgeladen", true);
      }
    });

    document.addEventListener("keyup", (e)=>{
      const k = e.key.toLowerCase();
      if(k==="w") keys.w=false;
      if(k==="a") keys.a=false;
      if(k==="s") keys.s=false;
      if(k==="d") keys.d=false;
      if(k==="shift") keys.shift=false;
    });

    canvas.addEventListener("mousedown", (e)=>{
      if(e.button !== 0) return;
      if(state.paused){
        overlay.style.display = "none";
        state.paused = false;
        lockPointer();
        return;
      }
      if(!state.locked){ lockPointer(); return; }
      shoot();
    });

    window.addEventListener("resize", ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    // -----------------------------
    // Sentence strip
    // -----------------------------
    const sentenceGroup = new THREE.Group();
    scene.add(sentenceGroup);

    const stripBase = new THREE.Vector3(0, 2.35, -4.0);
    const stripMotion = { phase: Math.random()*Math.PI*2, speed: 0.45, ampX: 0.75, ampY: 0.18 };

    const plate = new THREE.Mesh(
      new THREE.PlaneGeometry(12, 1.25),
      new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 1.0, transparent:true, opacity:0.28 })
    );
    sentenceGroup.add(plate);

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function makeWordCanvas(text){
      const c = document.createElement("canvas");
      const ctx = c.getContext("2d");

      const fontPx = 86;
      ctx.font = `800 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;

      const padX = 52;
      const w = Math.ceil(ctx.measureText(text).width) + padX*2;

      c.width  = Math.min(1200, Math.max(520, w));
      c.height = 240;

      ctx.clearRect(0,0,c.width,c.height);

      ctx.fillStyle = "rgba(0,0,0,0.52)";
      roundRect(ctx, 16, 34, c.width-32, c.height-68, 52);
      ctx.fill();

      ctx.lineWidth = 10;
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      roundRect(ctx, 16, 34, c.width-32, c.height-68, 52);
      ctx.stroke();

      ctx.fillStyle = "rgba(231,238,252,0.98)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, c.width/2, c.height/2);

      return c;
    }

    function makePlaceholderCanvas(widthPx){
      const c = document.createElement("canvas");
      c.width = widthPx;
      c.height = 240;
      const ctx = c.getContext("2d");
      ctx.clearRect(0,0,c.width,c.height);

      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 10;
      ctx.setLineDash([20, 16]);
      roundRect(ctx, 20, 40, c.width-40, c.height-80, 52);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = "rgba(255,255,255,0.06)";
      roundRect(ctx, 20, 40, c.width-40, c.height-80, 52);
      ctx.fill();

      return c;
    }

    function canvasToPlane(c, opacity=1.0){
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = 8;
      tex.needsUpdate = true;
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent:true, opacity });
      const aspect = c.width / c.height;

      const h = 0.80;
      const w = h * aspect;
      const geo = new THREE.PlaneGeometry(w, h);
      const mesh = new THREE.Mesh(geo, mat);

      mesh.userData.w = w;
      mesh.userData._canvasW = c.width;
      return mesh;
    }

    function clearSentence(){
      const keep = new Set([plate]);
      for(const child of [...sentenceGroup.children]){
        if(keep.has(child)) continue;
        sentenceGroup.remove(child);
        if(child.material?.map) child.material.map.dispose();
        if(child.material) child.material.dispose();
        if(child.geometry) child.geometry.dispose();
      }
    }

    function tokenize(sentence){
      return sentence.split(" ").filter(Boolean);
    }

    const MAX_WORD_WORLD_W = 3.4;

    function buildSentenceStrip(sentence, wrongOrWrongs){
      clearSentence();

      const tokens = tokenize(sentence);
      const wrongs = Array.isArray(wrongOrWrongs) ? wrongOrWrongs : [wrongOrWrongs];

      const wordMeshes = [];
      for(const tok of tokens){
        const isWrong = wrongs.some(w => tok.includes(w));
        const c = makeWordCanvas(tok);
        const m = canvasToPlane(c, 1.0);
        m.userData.text = tok;
        m.userData.isWrong = isWrong;
        m.userData.alive = true;
        m.userData.kind = "word";

        if(m.userData.w > MAX_WORD_WORLD_W){
          const s = MAX_WORD_WORLD_W / m.userData.w;
          m.scale.x *= s;
          m.userData.w = MAX_WORD_WORLD_W;
        }
        wordMeshes.push(m);
      }

      const gap = 0.16;
      let totalW = -gap;
      for(const w of wordMeshes) totalW += w.userData.w + gap;

      let x = -totalW/2;
      for(const w of wordMeshes){
        w.position.set(x + w.userData.w/2, 0, 0);
        x += w.userData.w + gap;
        sentenceGroup.add(w);
      }

      plate.geometry.dispose();
      plate.geometry = new THREE.PlaneGeometry(Math.max(7.8, totalW + 0.9), 1.10);
      plate.position.set(0, 0, -0.03);

      sentenceGroup.position.copy(stripBase);
      sentenceGroup.visible = true;
    }

    function createPlaceholderFor(wordMesh){
      const wpx = wordMesh.userData._canvasW || 700;
      const c = makePlaceholderCanvas(wpx);
      const ph = canvasToPlane(c, 0.88);
      ph.userData.kind = "placeholder";
      ph.userData.w = wordMesh.userData.w;
      ph.position.copy(wordMesh.position);
      return ph;
    }

    // -----------------------------
    // Effects
    // -----------------------------
    const beams = [];
    const impacts = [];
    const hintPulses = [];
    let stripKick = 0;
    let recoil = 0;

    const beamMat = new THREE.MeshBasicMaterial({
      color: 0x66ccff, transparent: true, opacity: 0.85,
      blending: THREE.AdditiveBlending, depthWrite: false
    });
    const beamCoreMat = new THREE.MeshBasicMaterial({
      color: 0xe0fbff, transparent: true, opacity: 0.75,
      blending: THREE.AdditiveBlending, depthWrite: false
    });

    function spawnBeam(len=26){
      const nozzle = gun.userData.nozzle;
      const start = new THREE.Vector3();
      nozzle.getWorldPosition(start);
      const dir = camera.getWorldDirection(new THREE.Vector3()).normalize();

      const geo = new THREE.CylinderGeometry(0.05, 0.05, 1, 10, 1, true);
      const beam = new THREE.Mesh(geo, beamMat.clone());
      const geo2 = new THREE.CylinderGeometry(0.02, 0.02, 1, 10, 1, true);
      const core = new THREE.Mesh(geo2, beamCoreMat.clone());

      const g = new THREE.Group();
      g.add(beam, core);

      const mid = start.clone().add(dir.clone().multiplyScalar(len/2));
      g.position.copy(mid);
      g.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);

      beam.scale.set(1, len, 1);
      core.scale.set(1, len, 1);

      g.userData.life = 0.12;
      g.userData.max = 0.12;

      scene.add(g);
      beams.push(g);
    }

    function spawnImpact(worldPos){
      const geo = new THREE.PlaneGeometry(0.60, 0.60);
      const mat = new THREE.MeshBasicMaterial({
        color: 0xe0fbff,
        transparent: true,
        opacity: 0.95,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const m = new THREE.Mesh(geo, mat);
      m.position.copy(worldPos);
      m.quaternion.copy(camera.quaternion);
      m.userData.life = 0.18;
      m.userData.max  = 0.18;
      scene.add(m);
      impacts.push(m);
    }

    function spawnHintPulseFor(wordMesh){
      if(!wordMesh) return;

      wordMesh.updateMatrixWorld(true);
      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      const scl = new THREE.Vector3();
      wordMesh.matrixWorld.decompose(pos, quat, scl);

      const w = wordMesh.geometry.parameters.width * scl.x * 1.10;
      const h = wordMesh.geometry.parameters.height * scl.y * 1.18;
      const geo = new THREE.PlaneGeometry(w, h);
      const mat = new THREE.MeshBasicMaterial({
        color: 0x66ccff,
        transparent: true,
        opacity: 0.0,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      const glow = new THREE.Mesh(geo, mat);
      glow.position.copy(pos);
      glow.quaternion.copy(camera.quaternion);
      glow.userData.life = 0.70;
      glow.userData.max = 0.70;

      scene.add(glow);
      hintPulses.push(glow);
    }

    // -----------------------------
    // Flying word effect
    // -----------------------------
    const flyingWords = [];
    function spawnFlyingWordFrom(mesh){
      const w = new THREE.Mesh(mesh.geometry.clone(), mesh.material.clone());
      w.material.opacity = 1.0;
      w.material.transparent = true;

      mesh.updateMatrixWorld(true);
      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      const scl = new THREE.Vector3();
      mesh.matrixWorld.decompose(pos, quat, scl);

      w.position.copy(pos);
      w.quaternion.copy(quat);
      w.scale.copy(scl);

      const camDir = camera.getWorldDirection(new THREE.Vector3()).normalize();
      const v = camDir.clone().multiplyScalar(-8.0);
      v.y += 2.4;
      v.x += (Math.random()-0.5)*1.6;
      v.z += (Math.random()-0.5)*1.6;

      w.userData.v = v;
      w.userData.life = 1.05;

      scene.add(w);
      flyingWords.push(w);
    }

    // -----------------------------
    // Task spawning
    // -----------------------------
    function spawnNormal(i){
      state.bossActive = false;
      state.bossHitsRemaining = 0;
      state.bossBonusAwarded = false;
      state.failsThisSentence = 0;

      const t = TASKS[i % TASKS.length];
      sentenceEl.textContent = t.sentence;

      state.level = 1 + Math.floor(state.done / 6);
      hintEl.innerHTML = state.practice
        ? `√úbungsmodus: keine Minuspunkte. Hint nach <b>2 Fehlversuchen</b>.`
        : `‚úÖ richtig +10 (+Streak), ‚ùå falsch ‚àí5. Hint nach <b>2 Fehlversuchen</b>.`;

      buildSentenceStrip(t.sentence, t.wrong);
      uiUpdate();
      flashMsg("Neuer Satz!", true);
    }

    function spawnBoss(){
      const boss = BOSS_TASKS[state.bossIdx % BOSS_TASKS.length];
      state.bossActive = true;
      state.bossBonusAwarded = false;
      state.bossHitsRemaining = boss.wrongs.length;
      state.failsThisSentence = 0;

      sentenceEl.textContent = boss.sentence;
      hintEl.innerHTML = state.practice
        ? `üëë Boss: 2 Fehler. Hint nach <b>2 Fehlversuchen</b>.`
        : `üëë Boss: 2 Fehler. Beide treffen ‚Üí <b>+30</b>. Hint nach <b>2 Fehlversuchen</b>.`;

      state.level = Math.max(state.level, 4);
      buildSentenceStrip(boss.sentence, boss.wrongs);
      uiUpdate();
      flashMsg("üëë Bossrunde!", true);
    }

    // -----------------------------
    // Hint logic
    // -----------------------------
    const raycaster = new THREE.Raycaster();

    function getWrongWordMeshes(){
      return sentenceGroup.children.filter(o => o.userData?.kind === "word" && o.userData.alive && o.userData.isWrong);
    }

    function maybeShowHint(){
      if(state.failsThisSentence >= 2){
        const wrongs = getWrongWordMeshes();
        if(wrongs.length){
          wrongs.forEach(w => spawnHintPulseFor(w));
          flashMsg("üîé Hint!", true);
        }
        // every 2 fails => consume 2
        state.failsThisSentence = Math.max(0, state.failsThisSentence - 2);
        uiUpdate();
      }
    }

    // -----------------------------
    // Shooting
    // -----------------------------
    function shoot(){
      if(state.ammo <= 0){
        flashMsg("üíß Leer! (R)", false);
        return;
      }
      state.ammo--;
      uiUpdate();

      spawnBeam(26);

      const origin = camera.getWorldPosition(new THREE.Vector3());
      const direction = camera.getWorldDirection(new THREE.Vector3()).normalize();
      raycaster.set(origin, direction);
      raycaster.far = 400;

      const targets = sentenceGroup.children.filter(o => o.userData?.kind === "word" && o.userData.alive);
      const hits = raycaster.intersectObjects(targets, false);

      if(!hits.length){
        state.failsThisSentence += 1;
        uiUpdate();
        flashMsg("üí¶ Daneben!", false);
        maybeShowHint();
        return;
      }

      const hit = hits[0].object;

      // impact + kick/recoil always
      spawnImpact(hits[0].point.clone());
      stripKick = Math.min(0.22, stripKick + 0.14);
      recoil = Math.min(0.18, recoil + 0.10);

      if(hit.userData.isWrong){
        spawnFlyingWordFrom(hit);

        const ph = createPlaceholderFor(hit);
        sentenceGroup.add(ph);

        hit.userData.alive = false;
        sentenceGroup.remove(hit);
        if(hit.material?.map) hit.material.map.dispose();
        if(hit.material) hit.material.dispose();
        if(hit.geometry) hit.geometry.dispose();

        const streakBonus = Math.min(12, state.streak);
        state.score += 10 + streakBonus;
        state.streak += 1;

        state.failsThisSentence = 0;

        if(state.bossActive){
          state.bossHitsRemaining = Math.max(0, state.bossHitsRemaining - 1);
          uiUpdate();
          flashMsg(`‚úÖ Boss-Treffer! (${state.bossHitsRemaining})`, true);

          if(state.bossHitsRemaining === 0 && !state.bossBonusAwarded){
            state.bossBonusAwarded = true;
            state.score += 30;
            uiUpdate();
            flashMsg("üëë Boss besiegt! +30", true);
            setTimeout(()=>endGame(true), 700);
          }
          return;
        }

        state.done += 1;
        uiUpdate();
        flashMsg("‚úÖ Treffer!", true);

        if(state.done >= state.total){
          setTimeout(()=>spawnBoss(), 620);
        }else{
          state.idx += 1;
          setTimeout(()=>spawnNormal(state.idx), 620);
        }
      }else{
        state.failsThisSentence += 1;

        if(!state.practice){
          state.score = Math.max(0, state.score - 5);
          state.streak = 0;
        }

        uiUpdate();
        flashMsg("‚ùå Falsch!", false);
        maybeShowHint();
      }
    }

    // -----------------------------
    // Flow
    // -----------------------------
    function hardReset(){
      state.idx = 0; state.score = 0; state.streak = 0;
      state.ammo = state.ammoMax;
      state.done = 0; state.level = 1;
      state.bossActive = false; state.bossHitsRemaining = 0; state.bossBonusAwarded = false;
      state.failsThisSentence = 0;
      state.bossIdx = 0;

      camera.position.set(0, 1.7, 6.0);
      yaw = 0; pitch = 0;
      camera.rotation.set(0,0,0);

      spawnNormal(0);
      uiUpdate();
    }

    function startGame(){
      overlay.style.display = "none";
      state.paused = false;
      hardReset();
      lockPointer();
    }

    function endGame(wonBoss=false){
      unlockPointer();
      state.paused = true;
      overlay.style.display = "grid";
      overlay.querySelector("h2").textContent = wonBoss ? "Boss geschafft! üèÜ" : "Fertig! üéâ";
      overlay.querySelector("p").innerHTML =
        `Score: <b>${state.score}</b> ¬∑ Streak: <b>${state.streak}</b><br>
         Du kannst neu starten oder √úbungsmodus w√§hlen.`;
    }

    // -----------------------------
    // Update loop
    // -----------------------------
    const clock = new THREE.Clock();

    function updateMovement(dt){
      if(state.locked && !state.paused){
        const speed = keys.shift ? 6.6 : 4.8;

        moveDir.set(0,0,0);
        if(keys.w) moveDir.z += 1;
        if(keys.s) moveDir.z -= 1;
        if(keys.a) moveDir.x -= 1;
        if(keys.d) moveDir.x += 1;

        if(moveDir.lengthSq() > 0){
          moveDir.normalize();
          const forward = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(0, yaw, 0));
          const right = new THREE.Vector3(1,0,0).applyEuler(new THREE.Euler(0, yaw, 0));
          vel.x = (right.x * moveDir.x + forward.x * moveDir.z) * speed;
          vel.z = (right.z * moveDir.x + forward.z * moveDir.z) * speed;
        }else{
          vel.x *= 0.85; vel.z *= 0.85;
        }

        camera.position.x += vel.x * dt;
        camera.position.z += vel.z * dt;

        camera.position.x = THREE.MathUtils.clamp(camera.position.x, -30, 30);
        camera.position.z = THREE.MathUtils.clamp(camera.position.z, -30, 30);
        camera.position.y = 1.7;
      }
    }

    function updateSentenceStrip(t, dt){
      const L = Math.min(6, state.level);
      stripMotion.speed = 0.35 + L*0.04;
      stripMotion.ampX  = 0.55 + L*0.10;
      stripMotion.ampY  = 0.12 + L*0.03;

      sentenceGroup.position.x = stripBase.x + Math.sin(t*stripMotion.speed + stripMotion.phase) * stripMotion.ampX;
      sentenceGroup.position.y = stripBase.y + Math.sin(t*stripMotion.speed*1.2 + stripMotion.phase*1.7) * stripMotion.ampY;
      sentenceGroup.position.z = stripBase.z;

      sentenceGroup.quaternion.copy(camera.quaternion);
      const e = new THREE.Euler().setFromQuaternion(sentenceGroup.quaternion, "YXZ");
      e.z = 0;
      e.x *= 0.10;
      sentenceGroup.quaternion.setFromEuler(e);

      if(stripKick > 0){
        sentenceGroup.position.x += (Math.random()-0.5) * stripKick * 0.40;
        sentenceGroup.position.y += (Math.random()-0.5) * stripKick * 0.22;
        stripKick = Math.max(0, stripKick - dt*2.8);
      }
    }

    function updateGunRecoil(dt){
      const r = gun.userData.root;
      if(!r) return;
      if(recoil > 0){
        r.position.z += recoil * 0.12;
        recoil = Math.max(0, recoil - dt*3.2);
      }
    }

    function updateFlyingWords(dt){
      for(let i=flyingWords.length-1;i>=0;i--){
        const w = flyingWords[i];
        w.userData.life -= dt;
        w.position.addScaledVector(w.userData.v, dt);
        w.userData.v.y -= 7.5 * dt;
        w.material.opacity = Math.max(0, w.userData.life / 1.05);

        if(w.userData.life <= 0){
          scene.remove(w);
          if(w.material?.map) w.material.map.dispose();
          if(w.material) w.material.dispose();
          if(w.geometry) w.geometry.dispose();
          flyingWords.splice(i,1);
        }
      }
    }

    function updateBeams(dt){
      for(let i=beams.length-1;i>=0;i--){
        const b = beams[i];
        b.userData.life -= dt;
        const a = Math.max(0, b.userData.life / b.userData.max);
        b.children.forEach((m, idx)=>{
          m.material.opacity = idx===0 ? (0.85*a) : (0.70*a);
        });
        if(b.userData.life <= 0){
          scene.remove(b);
          b.children.forEach(m=>{
            if(m.material) m.material.dispose();
            if(m.geometry) m.geometry.dispose();
          });
          beams.splice(i,1);
        }
      }
    }

    function updateImpacts(dt){
      for(let i=impacts.length-1;i>=0;i--){
        const p = impacts[i];
        p.userData.life -= dt;
        const a = Math.max(0, p.userData.life / p.userData.max);

        const s = 1 + (1-a)*0.9;
        p.scale.set(s, s, 1);
        p.material.opacity = 0.95 * a;
        p.quaternion.copy(camera.quaternion);

        if(p.userData.life <= 0){
          scene.remove(p);
          p.material.dispose();
          p.geometry.dispose();
          impacts.splice(i,1);
        }
      }
    }

    function updateHintPulses(dt){
      for(let i=hintPulses.length-1;i>=0;i--){
        const g = hintPulses[i];
        g.userData.life -= dt;
        const a = Math.max(0, g.userData.life / g.userData.max);

        const pulse = Math.sin((1-a) * Math.PI);
        g.material.opacity = 0.55 * pulse;
        g.quaternion.copy(camera.quaternion);

        if(g.userData.life <= 0){
          scene.remove(g);
          g.material.dispose();
          g.geometry.dispose();
          hintPulses.splice(i,1);
        }
      }
    }

    function loop(){
      const dt = Math.min(0.033, clock.getDelta());
      const t = clock.getElapsedTime();

      updateMovement(dt);
      updateSentenceStrip(t, dt);
      updateGunRecoil(dt);
      updateFlyingWords(dt);
      updateBeams(dt);
      updateImpacts(dt);
      updateHintPulses(dt);

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    // init
    hardReset();
    uiUpdate();
    loop();
  </script>
</body>
</html>

