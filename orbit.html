<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rechtschreib-Shooter 3D</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            user-select: none; 
            font-family: 'Segoe UI', sans-serif; 
            cursor: none; /* Wir verstecken den normalen Mauszeiger! */
        }
        
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 5;
        }

        #header {
            margin-top: 20px;
            text-align: center;
            color: #00ffcc;
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }

        #score-display {
            font-size: 1.5rem;
            color: white;
            margin-top: 10px;
        }

        #status {
            color: yellow;
            margin-top: 20px;
            font-weight: bold;
        }

        /* Das Fadenkreuz */
        #crosshair {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 50, 50, 0.9);
            border-radius: 50%;
            pointer-events: none; /* Wichtig: Klicks gehen durch das Fadenkreuz hindurch */
            z-index: 10;
            transform: translate(-50%, -50%); /* Zentriert den Kreis auf der Maus */
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            transition: transform 0.1s ease-out; /* Leichtes Nachziehen fÃ¼r cooles Feeling */
        }
        
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="header">
            <h1>Orthographie-Orbit</h1>
            <p>Bewege die Maus zum Zielen â€“ Klick zum SchieÃŸen!</p>
        </div>
        <div id="score-display">Score: 0</div>
        <div id="status">Lade System...</div>
    </div>
    
    <div id="crosshair" style="left: 50%; top: 50%;"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        let scene, camera, renderer, raycaster;
        // Wir brauchen einen Vektor fÃ¼r die Mausposition im 3D Raum (-1 bis +1)
        let mouseVector = new THREE.Vector2(); 
        
        let letters = []; 
        let starField;
        let score = 0;
        let currentSentenceIndex = 0;
        let fontGlobal;

        const statusText = document.getElementById('status');
        const scoreText = document.getElementById('score-display');
        const crosshairDiv = document.getElementById('crosshair');

        // Deine SÃ¤tze
        const levels = [
            { text: "Der Pogel fliegt.", errorIndex: 4, correctChar: "V" },
            { text: "Das Haus ist gros.", errorIndex: 13, correctChar: "ÃŸ" },
            { text: "Viele Kiche kochen Brei.", errorIndex: 6, correctChar: "Ã¶" },
            { text: "Er liest ein Buch.", errorIndex: -1, correctChar: "" }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205); // Fast Schwarz
            scene.fog = new THREE.Fog(0x020205, 10, 80);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Licht
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 10);
            scene.add(dirLight);
            
            // Punktlicht das der Maus folgt (optional, macht es atmosphÃ¤risch)
            const pointLight = new THREE.PointLight(0x00ffcc, 0.5, 20);
            scene.add(pointLight);

            // Sterne im Hintergrund
            createStars();

            raycaster = new THREE.Raycaster();

            // Schrift laden
            const loader = new FontLoader();
            loader.load('font.json', function (font) {
                fontGlobal = font;
                statusText.innerText = ""; 
                loadLevel(0);
            }, undefined, function (err) {
                statusText.innerText = "FEHLER: font.json fehlt!";
                statusText.style.color = "red";
            });

            window.addEventListener('click', onShoot);
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', (e) => onMouseMove(e, pointLight));
        }

        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for ( let i = 0; i < 2000; i ++ ) {
                vertices.push( THREE.MathUtils.randFloatSpread( 300 ) ); // x
                vertices.push( THREE.MathUtils.randFloatSpread( 200 ) ); // y
                vertices.push( THREE.MathUtils.randFloatSpread( 100 ) ); // z - Tiefe
            }
            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
            const material = new THREE.PointsMaterial( { color: 0xaaaaaa, size: 0.4 } );
            starField = new THREE.Points( geometry, material );
            scene.add( starField );
        }

        function loadLevel(index) {
            letters.forEach(l => scene.remove(l));
            letters = [];

            if (index >= levels.length) {
                statusText.innerText = "Alle Level geschafft! ðŸŽ‰";
                statusText.style.color = "#00ffcc";
                return;
            }

            const levelData = levels[index];
            create3DText(levelData.text, levelData);
        }

        function create3DText(textStr, levelData) {
            let xOffset = - (textStr.length * 0.7); 

            for (let i = 0; i < textStr.length; i++) {
                const char = textStr[i];
                if (char === " ") {
                    xOffset += 1.2;
                    continue;
                }

                const geo = new TextGeometry(char, {
                    font: fontGlobal,
                    size: 1.5,
                    height: 0.4,
                    curveSegments: 5,
                    bevelEnabled: true,
                    bevelThickness: 0.03,
                    bevelSize: 0.02,
                    bevelSegments: 3
                });

                const mat = new THREE.MeshStandardMaterial({ 
                    color: 0x44aaff, 
                    roughness: 0.2,
                    metalness: 0.8
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(xOffset, 0, 0);
                
                mesh.userData = { 
                    isError: (i === levelData.errorIndex),
                    originalChar: char
                };

                scene.add(mesh);
                letters.push(mesh);

                geo.computeBoundingBox();
                xOffset += (geo.boundingBox.max.x - geo.boundingBox.min.x) + 0.3;
            }
        }

        // --- HIER IST DER FIX: Maus bewegt Fadenkreuz & Raycaster ---
        function onMouseMove(event, light) {
            // 1. Visuelles Fadenkreuz bewegen (Pixel)
            crosshairDiv.style.left = event.clientX + 'px';
            crosshairDiv.style.top = event.clientY + 'px';

            // 2. Maus-Licht bewegen
            // Wir rechnen Pixel grob in 3D Koordinaten um fÃ¼r das Licht
            if(light) {
                light.position.x = (event.clientX / window.innerWidth) * 40 - 20;
                light.position.y = -(event.clientY / window.innerHeight) * 20 + 10;
            }

            // 3. Raycaster Vektor aktualisieren (-1 bis +1)
            mouseVector.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouseVector.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        function onShoot() {
            if (!fontGlobal) return;

            // Wir schieÃŸen von der Kamera durch die Mausposition
            raycaster.setFromCamera(mouseVector, camera);
            const intersects = raycaster.intersectObjects(letters);

            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;

                if (hitMesh.userData.isError) {
                    // TREFFER!
                    score += 100;
                    scoreText.innerText = "Score: " + score;
                    scoreText.style.color = "#00ff00";

                    hitMesh.material.color.set(0xff0000); // Rot werden
                    hitMesh.material.emissive.set(0xff0000);

                    // Explosionseffekt (Simpel)
                    hitMesh.scale.set(1.5, 1.5, 1.5);
                    
                    setTimeout(() => {
                        createExplosion(hitMesh.position);
                        scene.remove(hitMesh); // Fehler entfernen
                        
                        // NÃ¤chstes Level
                        setTimeout(() => {
                            currentSentenceIndex++;
                            loadLevel(currentSentenceIndex);
                            scoreText.style.color = "white";
                        }, 1000);
                    }, 200);

                } else {
                    // DANEBEN
                    score -= 20;
                    scoreText.innerText = "Score: " + score;
                    scoreText.style.color = "red";
                    
                    const oldColor = hitMesh.material.color.getHex();
                    hitMesh.material.color.set(0xff8800); // Orange Warnung
                    setTimeout(() => {
                        hitMesh.material.color.setHex(oldColor);
                        scoreText.style.color = "white";
                    }, 300);
                }
            }
        }

        function createExplosion(pos) {
            const light = new THREE.PointLight(0xff0000, 5, 15);
            light.position.copy(pos);
            scene.add(light);
            setTimeout(() => scene.remove(light), 300);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Sterne langsam drehen
            if(starField) {
