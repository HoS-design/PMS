<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rechtschreib-Shooter 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: sans-serif;
            pointer-events: none; /* Damit man durchklicken kann */
            text-shadow: 1px 1px 2px black;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-color: transparent;
            border: 2px solid red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="info">
        <h1>Orthographie-Orbit</h1>
        <p>Klicke auf die falsch geschriebenen Buchstaben!</p>
        <p>Score: <span id="score">0</span></p>
    </div>
    <div id="crosshair"></div>

    <script type="module">
        // Wir importieren direkt aus deinem lib-Ordner!
        import * as THREE from './lib/three.module.js';
        // Für 3D Text brauchen wir spezielle Loader, die sind nicht im Kern-Modul.
        // Wir laden sie direkt von einem CDN, das funktioniert auch auf GitHub Pages.
        import { FontLoader } from 'https://unpkg.com/three@0.150.0/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'https://unpkg.com/three@0.150.0/examples/jsm/geometries/TextGeometry.js';

        let scene, camera, renderer, raycaster, mouse;
        let letters = []; // Hier speichern wir alle anklickbaren Buchstaben
        let score = 0;
        const scoreElement = document.getElementById('score');

        // --- DATEN (Beispiel) ---
        // Wir definieren, welcher Index im String der Fehler ist.
        const currentSentenceData = {
            text: "Der Pogel fliegt hoch.",
            errorIndex: 4, // Das 'P' bei Index 4 ist falsch (0-basiert: D=0, e=1, r=2, " "=3, P=4)
            correction: "V"
        };


        init();
        animate();

        function init() {
            // 1. Szene & Kamera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122); // Dunkelblaues Weltall
            scene.fog = new THREE.Fog(0x111122, 20, 100); // Etwas Nebel für Tiefe

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            // 2. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 3. Licht
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 10).normalize();
            scene.add(directionalLight);

            // 4. Raycaster (zum Schießen) vorbereiten
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2(); // Mausposition ist immer 0,0 (Mitte)

            // 5. Schriftart laden und Text erstellen
            loadFontAndCreateText();

            // Event Listener für Klicks/Schüsse
            window.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);
        }

        function loadFontAndCreateText() {
             const loader = new FontLoader();
             // Hier muss deine font.json Datei liegen!
             loader.load('font.json', function (font) {
                 createText(currentSentenceData.text, font);
             }, undefined, function (err) {
                 console.error("Fehler beim Laden der Schriftart! Hast du font.json hochgeladen?", err);
                 document.getElementById('info').innerHTML += "<br><span style='color:red'>FEHLER: font.json fehlt!</span>";
             });
        }

        function createText(textString, font) {
            // Wir müssen jeden Buchstaben einzeln erstellen, damit man sie einzeln abschießen kann.
            let currentXOffset = -20; // Startposition links

            for (let i = 0; i < textString.length; i++) {
                const char = textString[i];
                
                // Leerezeichen überspringen wir bei der Geometrie, schieben aber den Cursor weiter
                if (char === " ") {
                    currentXOffset += 2;
                    continue;
                }

                const textGeo = new TextGeometry(char, {
                    font: font,
                    size: 3,
                    height: 0.5, // Wie dick sind die Buchstaben (3D Tiefe)
                    curveSegments: 12,
                });

                // Material: Ein schönes leuchtendes Material
                const textMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffcc, specular: 0x555555, shininess: 30 });
                const textMesh = new THREE.Mesh(textGeo, textMaterial);

                textMesh.position.x = currentXOffset;
                textMesh.position.y = 0;
                textMesh.position.z = 0;

                // Wir speichern den Index des Buchstabens direkt im Mesh, um ihn später zu prüfen
                textMesh.userData = { charIndex: i, char: char };

                scene.add(textMesh);
                letters.push(textMesh); // In unsere Liste für den Raycaster aufnehmen

                // Breite des Buchstabens berechnen, um den nächsten zu platzieren
                textGeo.computeBoundingBox();
                const letterWidth = textGeo.boundingBox.max.x - textGeo.boundingBox.min.x;
                currentXOffset += letterWidth + 0.5; // Kleiner Abstand zwischen Buchstaben
            }
        }

        function onMouseClick(event) {
            // Raycasting von der Kamera durch die Mitte des Bildschirms (0,0)
            raycaster.setFromCamera(mouse, camera);

            // Prüfen, ob wir Objekte aus unserer 'letters' Liste treffen
            const intersects = raycaster.intersectObjects(letters);

            if (intersects.length > 0) {
                // Wir haben etwas getroffen! Das erste Objekt ist das vorderste.
                const hitObject = intersects[0].object;
                const hitIndex = hitObject.userData.charIndex;

                checkHit(hitObject, hitIndex);
            }
        }

        function checkHit(mesh, index) {
            if (index === currentSentenceData.errorIndex) {
                // TREFFER! Richtiger (also falscher) Buchstabe getroffen.
                console.log("Treffer! Fehler gefunden.");
                score += 10;
                scoreElement.innerText = score;
                scoreElement.style.color = "#00ffcc";

                // Visuelles Feedback: Buchstabe wird rot und verschwindet
                mesh.material.color.set(0xff0000);
                
                // Kurze Verzögerung, dann entfernen (später hier: Explosionseffekt)
                setTimeout(() => {
                    scene.remove(mesh);
                    // Hier müsste man jetzt den *richtigen* Buchstaben an die Stelle setzen.
                    // Das heben wir uns für den nächsten Schritt auf, wenn das hier läuft.
                    // TODO: Ersetze durch Korrektur
                }, 300);

            } else {
                // DANEBEN! Auf einen richtigen Buchstaben geschossen.
                console.log("Falsch! Das war ein korrekter Buchstabe.");
                score -= 5;
                scoreElement.innerText = score;
                scoreElement.style.color = "red";
                
                // Visuelles Feedback: Buchstabe blinkt kurz rot auf
                const oldColor = mesh.material.color.getHex();
                mesh.material.color.set(0xff0000);
                setTimeout(() => {
                     mesh.material.color.setHex(oldColor);
                     scoreElement.style.color = "white";
                }, 500);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Optional: Leichte Rotation des gesamten Satzes für mehr Dynamik
            /* letters.forEach(letter => {
                letter.rotation.y += 0.005;
            }); */
            
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
