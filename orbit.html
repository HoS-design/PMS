<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rechtschreib-Shooter 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none;
            text-shadow: 0 0 5px #00ffcc;
            z-index: 10;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        /* Kleiner Punkt in der Mitte des Fadenkreuzes */
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>

    <div id="info">
        <h1>Orthographie-Orbit</h1>
        <p>Finde den Fehler! Klicke auf den falschen Buchstaben.</p>
        <h2 id="score">Score: 0</h2>
    </div>
    <div id="crosshair"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        let scene, camera, renderer, raycaster, mouse;
        let letters = []; 
        let score = 0;
        const scoreElement = document.getElementById('score');

        // --- DEINE SÄTZE ---
        const sentences = [
            { text: "Der Pogel fliegt.", errorIndex: 4, correctChar: "V" },
            { text: "Das Haus ist gros.", errorIndex: 13, correctChar: "ß" },
            { text: "Ich esse gernen Eis.", errorIndex: 10, correctChar: "" }, // 'n' ist zu viel
            { text: "Die Sonne scheint.", errorIndex: -1, correctChar: "" } // Kein Fehler (zum Testen)
        ];
        
        // Aktueller Satz
        let currentSentence = sentences[0]; 

        init();
        animate();

        function init() {
            // Szene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); // Sehr dunkles Blau
            scene.fog = new THREE.Fog(0x050510, 10, 50);

            // Kamera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 20);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Licht
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            
            // Punktlicht beim Text für Glanz
            const pointLight = new THREE.PointLight(0x00ffcc, 1, 30);
            pointLight.position.set(0, 0, 5);
            scene.add(pointLight);

            // Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2(0, 0); // Mitte des Bildschirms

            // Schrift laden
            const loader = new FontLoader();
            loader.load('font.json', function (font) {
                createSentence3D(currentSentence.text, font);
            }, undefined, function(err) {
                console.error(err);
                alert("Fehler: font.json nicht gefunden! Bitte lade die Datei hoch.");
            });

            // Events
            window.addEventListener('click', shoot);
            window.addEventListener('resize', onWindowResize);
            
            // Mausbewegung für leichten Parallax-Effekt (optional)
            document.addEventListener('mousemove', onMouseMove);
        }

        function createSentence3D(text, font) {
            // Alte Buchstaben löschen
            letters.forEach(l => scene.remove(l));
            letters = [];

            let xOffset = 0;
            // Wir berechnen erst die Gesamtbreite, um den Text zu zentrieren
            // Das ist etwas komplexer, daher machen wir es simpel: 
            // Wir schätzen den Startpunkt links.
            xOffset = - (text.length * 0.8); 

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (char === " ") {
                    xOffset += 1;
                    continue;
                }

                const geometry = new TextGeometry(char, {
                    font: font,
                    size: 1.5,
                    height: 0.4,
                    curveSegments: 6,
                    bevelEnabled: true,
                    bevelThickness: 0.05,
                    bevelSize: 0.05,
                    bevelSegments: 3
                });

                // Material: Sci-Fi Look
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x00aaff, 
                    roughness: 0.3,
                    metalness: 0.7,
                    emissive: 0x001133
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(xOffset, 0, 0);
                
                // Wir speichern Infos im Objekt
                mesh.userData = { 
                    char: char, 
                    index: i,
                    isError: (i === currentSentence.errorIndex)
                };

                scene.add(mesh);
                letters.push(mesh);

                // Breite für nächsten Buchstaben
                geometry.computeBoundingBox();
                const width = geometry.boundingBox.max.x - geometry.boundingBox.min.x;
                xOffset += width + 0.3;
            }
        }

        function shoot() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(letters);

            if (intersects.length > 0) {
                const hitObj = intersects[0].object;
                
                if (hitObj.userData.isError) {
                    // RICHTIG GETROFFEN (also den Fehler)
                    score += 100;
                    scoreElement.innerText = "Score: " + score;
                    scoreElement.style.color = "#00ff00"; // Grün
                    
                    // Effekt: Rot werden und rotieren
                    hitObj.material.color.set(0xff0000);
                    hitObj.material.emissive.set(0xff0000);
                    
                    // Kleiner Sprung-Effekt
                    hitObj.position.y += 0.5;

                    setTimeout(() => {
                        scoreElement.style.color = "white";
                        // Hier könnte man den nächsten Satz laden
                        alert("Gut gemacht! Fehler eliminiert.");
                    }, 500);

                } else {
                    // FALSCH (richtigen Buchstaben abgeschossen)
                    score -= 50;
                    scoreElement.innerText = "Score: " + score;
                    scoreElement.style.color = "red";
                    
                    // Kurz rot blinken
                    const oldColor = hitObj.material.color.getHex();
                    hitObj.material.color.set(0xff0000);
                    setTimeout(() => {
                        hitObj.material.color.setHex(oldColor);
                        scoreElement.style.color = "white";
                    }, 300);
                }
            }
        }

        let mouseX = 0;
        let mouseY = 0;
        function onMouseMove(event) {
            mouseX = (event.clientX - window.innerWidth / 2) * 0.001;
            mouseY = (event.clientY - window.innerHeight / 2) * 0.001;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Leichte Kamerabewegung mit der Maus (Parallax)
            camera.position.x += (mouseX - camera.position.x) * 0.05;
            camera.position.y += (-mouseY - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);

            // Buchstaben schweben lassen
            const time = Date.now() * 0.001;
            letters.forEach((l, idx) => {
                l.position.y += Math.sin(time + idx) * 0.002;
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
