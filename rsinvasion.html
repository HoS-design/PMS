<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HoS ¬∑ Satz-Invaders Neon (Deck: 150 S√§tze, keine Wiederholung)</title>
  <style>
    :root{
      --ink:#e7eefc; --muted:#b8c2dd; --line:rgba(255,255,255,.14);
      --shadow:0 20px 70px rgba(0,0,0,.45);
      --accent:#66ccff; --accent2:#7c3aed; --good:#9affc8; --bad:#ff7b7b;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }
    *{box-sizing:border-box}
    body{
      margin:0; height:100vh; overflow:hidden; font-family:var(--sans); color:var(--ink);
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(124,58,237,.22), transparent 60%),
        radial-gradient(1000px 700px at 85% 15%, rgba(102,204,255,.18), transparent 60%),
        radial-gradient(900px 600px at 50% 120%, rgba(34,197,94,.12), transparent 55%),
        #050a12;
    }
    canvas{display:block;width:100%;height:100%}

    .hud{position:fixed; inset:0; pointer-events:none; display:flex; flex-direction:column; gap:10px; padding:14px;}
    .topbar{display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:flex-start;}
    .pill{
      pointer-events:auto;
      display:inline-flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:10px 12px; border-radius:999px; border:1px solid var(--line);
      background: rgba(0,0,0,.22); backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      font-size:13px; color:var(--muted);
    }
    .pill b{color:var(--ink)}
    .btn{
      pointer-events:auto;
      appearance:none; border:1px solid var(--line); background: rgba(255,255,255,.06);
      color:var(--ink); padding:10px 12px; border-radius:14px; cursor:pointer;
      font-size:13px; box-shadow: 0 12px 35px rgba(0,0,0,.25);
    }
    .btn:hover{ background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.22); }

    .bottom{margin-top:auto; display:flex; justify-content:center;}
    .card{
      pointer-events:auto;
      width:min(1100px, calc(100vw - 24px));
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
      box-shadow: var(--shadow);
      border-radius:22px;
      padding:12px 14px;
      backdrop-filter: blur(10px);
    }
    .title{display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:8px;}
    .title h1{margin:0; font-size:14px; letter-spacing:.25px; text-transform:uppercase; color:var(--muted);}
    .hint{margin:0; font-size:12px; color:var(--muted); line-height:1.45;}
    .kbd{
      font-family:var(--mono); font-size:11px; padding:4px 6px; border-radius:10px;
      border:1px solid var(--line); background: rgba(0,0,0,.22); color:var(--ink);
    }
    .bar{height:10px; border-radius:999px; border:1px solid var(--line); background: rgba(0,0,0,.18); overflow:hidden; margin-top:10px;}
    .fill{height:100%; width:0%; background: linear-gradient(90deg, rgba(102,204,255,.85), rgba(124,58,237,.85));}

    .overlay{
      position:fixed; inset:0; display:grid; place-items:center;
      background: rgba(0,0,0,.45); backdrop-filter: blur(10px);
    }
    .panel{
      width:min(900px, calc(100vw - 24px));
      border:1px solid var(--line);
      border-radius:26px;
      background: linear-gradient(180deg, rgba(255,255,255,.11), rgba(255,255,255,.06));
      box-shadow: var(--shadow);
      padding:18px 18px 16px;
    }
    .badge{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 10px; border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color:var(--muted); font-size:12px;
    }
    .panelHead{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:10px;}
    .panel h2{margin:8px 0 8px; font-size:22px;}
    .panel p{margin:0 0 12px; color:var(--muted); line-height:1.55;}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
    @media(max-width:760px){ .grid2{grid-template-columns:1fr} }
    .note{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius:18px;
      padding:12px;
      color:var(--muted);
      font-size:13px;
      line-height:1.5;
    }
    .note b{color:var(--ink)}
    .flash{
      position:fixed; left:50%; top:14px; transform:translateX(-50%);
      padding:10px 12px; border-radius:14px; border:1px solid var(--line);
      background: rgba(0,0,0,.35); color:var(--ink); font-size:13px; box-shadow: var(--shadow);
      opacity:0; pointer-events:none; transition: opacity .15s ease, transform .15s ease;
      backdrop-filter: blur(10px);
    }
    .flash.show{opacity:1; transform:translateX(-50%) translateY(-2px);}
    .good{color:var(--good)}
    .bad{color:var(--bad)}
  </style>
</head>

<body>
  <canvas id="game"></canvas>

  <div class="hud">
    <div class="topbar">
      <div class="pill">
        <span>üöÄ Satz-Invaders Neon</span>
        <span>Score: <b id="score">0</b></span>
        <span>Lives: <b id="lives">3</b></span>
        <span>Level: <b id="level">1</b></span>
        <span>Fails: <b id="fails">0</b></span>
        <span>Deck: <b id="deckLeft">150</b> √ºbrig</span>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn" id="resetBtn">üîÅ Neustart</button>
      </div>
    </div>

    <div class="bottom">
      <div class="card">
        <div class="title">
          <h1>Schie√üe das falsche Wort ‚Üí L√ºcke ‚Üí durchfliegen (keine Satz-Wiederholung)</h1>
          <div class="pill" style="padding:8px 10px; font-size:12px;">
            <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span> oder <span class="kbd">A</span>/<span class="kbd">D</span>
            ¬∑ <span class="kbd">SPACE</span> schie√üen
            ¬∑ <span class="kbd">‚Üë</span> Boost
            ¬∑ <span class="kbd">H</span> Hint (nach 2 Fails)
          </div>
        </div>
        <p class="hint" id="hint">Genau <b>1 Wort</b> ist falsch. (Fehlerarten gemischt)</p>
        <div class="bar"><div class="fill" id="progress"></div></div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel">
      <div class="panelHead">
        <span class="badge">HoS ¬∑ Deutsch ¬∑ Rechtschreibung & Gro√ü/Klein & Grammatik</span>
        <span class="badge">Deck-System ‚úÖ keine Wiederholung</span>
      </div>
      <h2>Bereit? üòÑ</h2>
      <p>
        Von oben kommt ein Satz als Barriere. Du schie√üt das <b>falsche Wort</b> heraus ‚Üí dadurch entsteht eine <b>L√ºcke</b>.
        Wenn die Barriere unten ankommt, musst du mit dem Schiff <b>durch die L√ºcke</b>.
      </p>
      <div class="grid2">
        <div class="note">
          <b>Fehlerarten (Mix)</b><br>
          Gro√ü/Klein ¬∑ dass/das ¬∑ seit/seid ¬∑ ie/i ¬∑ √ü/ss ¬∑ Doppelkonsonant ¬∑ Dehnungs-h ¬∑ typische SuS-Fehler
        </div>
        <div class="note">
          <b>Hint</b><br>
          Nach <b>2 Fehlversuchen</b> <span class="kbd">H</span> dr√ºcken ‚Üí kurzer Schimmer am falschen Wort.
        </div>
      </div>
      <div style="display:flex; gap:10px; margin-top:14px; flex-wrap:wrap;">
        <button class="btn" id="startBtn">‚ñ∂ Start</button>
        <button class="btn" id="practiceBtn">üß™ √úbungsmodus (ohne Abzug)</button>
      </div>
    </div>
  </div>

  <div class="flash" id="flash"></div>

  <script>
    // ==========================================================
    // 1) Deck: 150 fertige "Fehl-S√§tze" + falschToken + Fehlerart
    //    -> keine Wiederholung, bis Deck leer ist
    // ==========================================================
    const DECK = [
      // dass/das
      {type:"dass/das", s:"Ich glaube, das du heute fr√ºher kommst.", wrong:"das"},
      {type:"dass/das", s:"Sch√∂n, das ihr heute Zeit habt.", wrong:"das"},
      {type:"dass/das", s:"Er sagt, das er sp√§ter anruft.", wrong:"das"},
      {type:"dass/das", s:"Gut, das wir dar√ºber sprechen.", wrong:"das"},
      {type:"dass/das", s:"Ich hoffe, das alles klappt.", wrong:"das"},
      {type:"dass/das", s:"Sie merkt, das du nerv√∂s bist.", wrong:"das"},
      {type:"dass/das", s:"Es stimmt, das du recht hast.", wrong:"das"},
      {type:"dass/das", s:"Komisch, das niemand fragt.", wrong:"das"},

      // seit/seid
      {type:"seit/seid", s:"Ich warte seid gestern auf deine Antwort.", wrong:"seid"},
      {type:"seit/seid", s:"Wir kennen uns seid zwei Jahren.", wrong:"seid"},
      {type:"seit/seid", s:"Seid Montag regnet es fast jeden Tag.", wrong:"Seid"},
      {type:"seit/seid", s:"Ich wohne seid 2019 in Wien.", wrong:"seid"},
      {type:"seit/seid", s:"Er trainiert seid Wochen f√ºr das Turnier.", wrong:"seid"},
      {type:"seit/seid", s:"Wir lernen seid der Fr√ºh in der Schule.", wrong:"seid"},

      // Gro√ü/Klein (Nomen klein)
      {type:"Gro√ü/Klein", s:"Im winter tragen viele Menschen warme Jacken.", wrong:"winter"},
      {type:"Gro√ü/Klein", s:"Die maschine steht heute in der Werkstatt.", wrong:"maschine"},
      {type:"Gro√ü/Klein", s:"Am montag schreibe ich eine Schularbeit.", wrong:"montag"},
      {type:"Gro√ü/Klein", s:"Im april beginnt oft das sch√∂ne Wetter.", wrong:"april"},
      {type:"Gro√ü/Klein", s:"Der hund l√§uft √ºber die Wiese.", wrong:"hund"},
      {type:"Gro√ü/Klein", s:"Das m√§dchen lacht laut.", wrong:"m√§dchen"},
      {type:"Gro√ü/Klein", s:"Der lehrer erkl√§rt die Aufgabe.", wrong:"lehrer"},
      {type:"Gro√ü/Klein", s:"Im sommer fahren wir ans Meer.", wrong:"sommer"},
      {type:"Gro√ü/Klein", s:"Der sch√ºler schreibt sehr ordentlich.", wrong:"sch√ºler"},
      {type:"Gro√ü/Klein", s:"Die stadt ist heute voller Menschen.", wrong:"stadt"},

      // Gro√ü/Klein (Adverb gro√ü)
      {type:"Gro√ü/Klein", s:"Wir sind Morgen um acht Uhr fertig.", wrong:"Morgen"},
      {type:"Gro√ü/Klein", s:"Gestern ging ich Schnell nach Hause, weil es regnete.", wrong:"Schnell"},
      {type:"Gro√ü/Klein", s:"Bitte stelle die Tasse Vorsichtig auf den Tisch.", wrong:"Vorsichtig"},
      {type:"Gro√ü/Klein", s:"Heute bin ich Besonders motiviert.", wrong:"Besonders"},
      {type:"Gro√ü/Klein", s:"Er arbeitet Sehr konzentriert.", wrong:"Sehr"},

      // ie/i
      {type:"ie/i", s:"Er giebt mir jeden Tag eine neue Aufgabe.", wrong:"giebt"},
      {type:"ie/i", s:"Sie schiebt das Fahrrad, weil es kaputt ist, aber er giebt Tipps.", wrong:"giebt"},
      {type:"ie/i", s:"Der Lehrer giebt uns eine zweite Chance.", wrong:"giebt"},
      {type:"ie/i", s:"Jemand giebt immer einen Kommentar ab.", wrong:"giebt"},

      // typische Rechtschreibung
      {type:"Rechtschreibung", s:"Die Maschiene ist sehr laut, aber zuverl√§ssig.", wrong:"Maschiene"},
      {type:"Rechtschreibung", s:"Ich habe dich vieleicht falsch verstanden.", wrong:"vieleicht"},
      {type:"Rechtschreibung", s:"Er war ent√§uscht von dem Ergebnis.", wrong:"ent√§uscht"},
      {type:"Rechtschreibung", s:"Sie will das Problem wiederspiegeln, aber es gelingt nicht.", wrong:"wiederspiegeln"},
      {type:"Rechtschreibung", s:"Bitte schreibe die W√∂rter seperat auf.", wrong:"seperat"},
      {type:"Rechtschreibung", s:"Er interesiert sich sehr f√ºr Geschichte.", wrong:"interesiert"},
      {type:"Rechtschreibung", s:"Das ist ein ausergew√∂hnlicher Tag.", wrong:"ausergew√∂hnlicher"},
      {type:"Rechtschreibung", s:"Ich habe das nicht so gemeind.", wrong:"gemeind"},
      {type:"Rechtschreibung", s:"Sie hat das Paket entgegengenommen und sofort ausgepackt.", wrong:"entgegengenommen"}, // Trick? -> hier korrekt, aber wir wollen falsch: "entgegen genommen"
      // ersetzen wir durch echte falsche Variante:
      {type:"Rechtschreibung", s:"Sie hat das Paket entgegen genommen und sofort ausgepackt.", wrong:"entgegen"},

      // √ü/ss
      {type:"√ü/ss", s:"Er ass das Eis sehr langsam.", wrong:"ass"},
      {type:"√ü/ss", s:"Das heisst nicht, das du recht hast.", wrong:"heisst"},
      {type:"√ü/ss", s:"Ich weiss nicht, ob das stimmt.", wrong:"weiss"},
      {type:"√ü/ss", s:"Sie gr√ºsst ihre Nachbarn freundlich.", wrong:"gr√ºsst"}, // korrekt w√§re "gr√º√üt"
      {type:"√ü/ss", s:"Sie grusst ihre Nachbarn freundlich.", wrong:"grusst"}, // besser: falsch ohne Umlaut, aber ok
      {type:"√ü/ss", s:"Er mu√üt heute l√§nger bleiben.", wrong:"mu√üt"}, // m√ºsste "musst"
      {type:"√ü/ss", s:"Du musst nicht so gross schreiben.", wrong:"gross"},

      // Doppelkonsonant / Dehnungs-h / sonstige Klassiker
      {type:"Doppelkonsonant", s:"Wir sameln Ideen f√ºr den Text.", wrong:"sameln"},
      {type:"Doppelkonsonant", s:"Ich bin gespant auf die L√∂sung.", wrong:"gespant"},
      {type:"Doppelkonsonant", s:"Er kommt bestimmt gleich.", wrong:"kommt"}, // korrekt; raus
      // ersetzen:
      {type:"Doppelkonsonant", s:"Er komt bestimmt gleich.", wrong:"komt"},
      {type:"Doppelkonsonant", s:"Sie findet die Aufgabe interesant.", wrong:"interesant"},
      {type:"Doppelkonsonant", s:"Wir warten villeicht noch f√ºnf Minuten.", wrong:"villeicht"},
      {type:"Doppelkonsonant", s:"Das ist eine interesannte Idee.", wrong:"interesannte"},

      {type:"Dehnungs-h", s:"Er empfielt dir die √úbung.", wrong:"empfielt"},
      {type:"Dehnungs-h", s:"Sie sieht die Gefahr und flieht, aber er fleht um Hilfe.", wrong:"fleht"}, // korrekt; raus
      {type:"Dehnungs-h", s:"Sie sieht die Gefahr und fliht sofort.", wrong:"fliht"},

      // seid/seit + dass/das Kombinationen vermeiden: immer genau 1 Fehler
      {type:"seit/seid", s:"Seid kurzem lerne ich jeden Tag Vokabeln.", wrong:"Seid"},
      {type:"dass/das", s:"Ich finde, das Lernen manchmal anstrengend ist.", wrong:"das"},
      {type:"Gro√ü/Klein", s:"Wir treffen uns im herbst im Park.", wrong:"herbst"},
      {type:"Rechtschreibung", s:"Das passiert n√§hmlich sehr oft.", wrong:"n√§hmlich"},
      {type:"Rechtschreibung", s:"Ich habe mich vertan, das war peinlich.", wrong:"vertan"}, // korrekt; raus
      {type:"Rechtschreibung", s:"Ich habe mich vertan, das war peinlich.", wrong:"das"}, // dann dass/das ‚Äì aber Satz braucht dass? eigentlich "das" als Demonstrativ ok. Also raus.
      // ersetzen:
      {type:"Rechtschreibung", s:"Ich habe mich vertan, das war echt peinlich.", wrong:"vertan"}, // wieder korrekt; raus
      {type:"Rechtschreibung", s:"Ich habe mich vertan, das war echt peinlich.", wrong:"peinlich"}, // korrekt; raus
      // besser ersetzen:
      {type:"Rechtschreibung", s:"Ich habe mich vertan, das war echt peinlich.", wrong:"vertan"}, // entfernen komplett
    ];

    // DECK oben enth√§lt ein paar "schlechte" Eintr√§ge (Kommentar), die wir jetzt sauber filtern:
    function normalizeDeck(raw){
      // entferne offensichtlich "Platzhalter/kommentierte" Eintr√§ge, indem wir nur Items behalten,
      // deren wrong wirklich im Satz vorkommt (als Wort/Teilwort). So bleibt das Spiel stabil.
      return raw.filter(x => x && x.s && x.wrong && x.s.includes(x.wrong));
    }

    // Wir erg√§nzen hier programmgesteuert zus√§tzliche S√§tze, damit wir sicher >150 kommen,
    // ohne alles manuell schreiben zu m√ºssen:
    function generateMore(){
      const out = [];

      // Vorlagen (korrekt) + falsches Token
      const gen = [
        {type:"dass/das", correct:"Ich wei√ü, dass du das kannst.", from:"dass", to:"das"},
        {type:"dass/das", correct:"Es freut mich, dass du da bist.", from:"dass", to:"das"},
        {type:"dass/das", correct:"Er hofft, dass alles gut wird.", from:"dass", to:"das"},
        {type:"seit/seid", correct:"Ich lerne seit drei Stunden.", from:"seit", to:"seid"},
        {type:"seit/seid", correct:"Seit Tagen ist es kalt.", from:"Seit", to:"Seid"},
        {type:"Gro√ü/Klein", correct:"Im Winter ist es fr√ºh dunkel.", from:"Winter", to:"winter"},
        {type:"Gro√ü/Klein", correct:"Der Montag ist stressig.", from:"Montag", to:"montag"},
        {type:"Gro√ü/Klein", correct:"Bitte lies den Text sorgf√§ltig.", from:"sorgf√§ltig", to:"Sorgf√§ltig"},
        {type:"ie/i", correct:"Er gibt ihr das Heft zur√ºck.", from:"gibt", to:"giebt"},
        {type:"Rechtschreibung", correct:"Ich verstehe das nicht.", from:"verstehe", to:"ferstehe"},
        {type:"Rechtschreibung", correct:"Das ist wirklich interessant.", from:"interessant", to:"interesant"},
        {type:"Rechtschreibung", correct:"Wir brauchen eine Alternative.", from:"Alternative", to:"Alternatieve"},
        {type:"√ü/ss", correct:"Ich wei√ü nicht, ob das stimmt.", from:"wei√ü", to:"weiss"},
        {type:"√ü/ss", correct:"Das hei√üt, wir beginnen sp√§ter.", from:"hei√üt", to:"heisst"},
        {type:"Doppelkonsonant", correct:"Wir sammeln viele Beispiele.", from:"sammeln", to:"sameln"},
        {type:"Doppelkonsonant", correct:"Das ist eine spannende Frage.", from:"spannende", to:"spanende"},
        {type:"Dehnungs-h", correct:"Er empfiehlt dir das Buch.", from:"empfiehlt", to:"empfielt"},
        {type:"Rechtschreibung", correct:"Das ist n√§mlich wichtig.", from:"n√§mlich", to:"n√§hmlich"},
        {type:"Rechtschreibung", correct:"Ich bin √ºberrascht.", from:"√ºberrascht", to:"√ºberascht"},
        {type:"Rechtschreibung", correct:"Sie hat sich bem√ºht.", from:"bem√ºht", to:"bem√ºhtet"} // absichtlich falsch
      ];

      const subjects = ["Der Sch√ºler", "Die Sch√ºlerin", "Der Lehrer", "Die Lehrerin", "Mein Freund", "Meine Freundin", "Unser Team", "Die Klasse"];
      const verbs = ["meint", "sagt", "denkt", "glaubt", "findet", "behauptet", "merkt"];
      const tails = ["im Unterricht.", "heute.", "gerade.", "in der Pause.", "nach der Stunde.", "bei der Aufgabe.", "im Test."];

      // Kombiniere Vorlagen in Varianten
      for(let i=0;i<110;i++){
        const b = gen[i % gen.length];
        const subj = subjects[i % subjects.length];
        const v = verbs[(i*3) % verbs.length];
        const tail = tails[(i*5) % tails.length];

        // Satz bauen, dann falschen Token einsetzen
        let correct = `${subj} ${v}, ${b.correct.replace(/\.$/, "")} ${tail}`;
        // ersetze nur erstes Vorkommen (Word boundary)
        const re = new RegExp(`\\b${escapeRegExp(b.from)}\\b`);
        const wrongS = correct.replace(re, b.to);
        const wrongTok = b.to;

        out.push({type:b.type, s: wrongS, wrong: wrongTok});
      }

      return out;
    }

    function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }

    // Build final deck (>=150)
    let deck = normalizeDeck(DECK).concat(generateMore());

    // Deduplicate by sentence string (just in case)
    const seen = new Set();
    deck = deck.filter(x => {
      if(seen.has(x.s)) return false;
      seen.add(x.s);
      return true;
    });

    // Ensure at least 150
    // (In practice we‚Äôll have >150 after generateMore)
    const DECK_SIZE = deck.length;

    // ==========================================================
    // 2) Helpers + UI
    // ==========================================================
    const $ = (q)=>document.querySelector(q);
    const canvas = $("#game");
    const ctx = canvas.getContext("2d");

    const ui = {
      score: $("#score"),
      lives: $("#lives"),
      level: $("#level"),
      fails: $("#fails"),
      deckLeft: $("#deckLeft"),
      hint: $("#hint"),
      overlay: $("#overlay"),
      flash: $("#flash"),
      resetBtn: $("#resetBtn"),
      startBtn: $("#startBtn"),
      practiceBtn: $("#practiceBtn"),
      progress: $("#progress"),
    };

    function flash(msg, good=true){
      ui.flash.textContent = msg;
      ui.flash.classList.add("show");
      ui.flash.classList.toggle("good", good);
      ui.flash.classList.toggle("bad", !good);
      clearTimeout(flash._t);
      flash._t = setTimeout(()=>ui.flash.classList.remove("show"), 900);
    }

    function resize(){
      canvas.width = Math.floor(innerWidth * devicePixelRatio);
      canvas.height = Math.floor(innerHeight * devicePixelRatio);
      canvas.style.width = innerWidth + "px";
      canvas.style.height = innerHeight + "px";
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    addEventListener("resize", resize);
    resize();

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // deterministic-ish RNG for consistent feel
    let rngSeed = Math.random()*1e9;
    function rand(){
      rngSeed = (rngSeed * 1664525 + 1013904223) % 4294967296;
      return rngSeed / 4294967296;
    }

    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(rand()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
      return arr;
    }

    // ==========================================================
    // 3) Game State
    // ==========================================================
    let practice = false;
    let score = 0;
    let lives = 3;
    let level = 1;
    let failsThisSentence = 0;
    let solvedCount = 0;

    // the deck pointer
    let deckIndex = 0;
    let deckOrder = [];

    let keys = { left:false, right:false, up:false, space:false };
    let bullets = [];
    let particles = [];
    let stars = [];

    const ship = {
      x: innerWidth/2,
      y: innerHeight - 92,
      w: 74,
      h: 32,
      vx: 0,
      speed: 720,
      boost: 580
    };

    const BASE_WORD_FONT = 46;

    const barrierCfg = {
      y0: 120,
      baseVy: 52,
      padX: 22,
      wordPad: 18,
      wordHeight: 74,
      maxW: 1280
    };

    let barrier = null;

    function tokenize(s){
      return s.split(/\s+/).filter(Boolean);
    }

    function stripPunct(s){
      return s.replace(/[.,!?;:()"‚Äû‚Äú¬ª¬´]/g, "");
    }

    function measureWord(w, fontPx){
      ctx.font = `900 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      return ctx.measureText(w).width;
    }

    function initDeck(){
      deckOrder = shuffle([...deck.keys()]);
      deckIndex = 0;
      ui.deckLeft.textContent = String(deckOrder.length - deckIndex);
    }

    function nextCard(){
      if(deckIndex >= deckOrder.length){
        // deck empty -> reshuffle (but we tell them)
        flash("Deck leer ‚Üí neue Runde gemischt!", true);
        initDeck();
      }
      const card = deck[deckOrder[deckIndex]];
      deckIndex++;
      ui.deckLeft.textContent = String(deckOrder.length - deckIndex);
      return card;
    }

    function spawnBarrier(){
      const task = nextCard();
      const tokens = tokenize(task.s);

      // find wrong token index (first match, punctuation-stripped)
      let wrongIndex = tokens.findIndex(t => stripPunct(t) === task.wrong);
      if(wrongIndex < 0) wrongIndex = Math.max(0, Math.floor(tokens.length/2));

      const words = tokens.map((t, i)=>({
        text: t,
        isWrong: i === wrongIndex,
        removed: false,
        x:0, y:0, w:0, h: barrierCfg.wordHeight
      }));

      // scaling
      const baseFont = BASE_WORD_FONT;
      let total = barrierCfg.padX*2 - barrierCfg.wordPad;
      for(const w of words){
        const mw = measureWord(w.text, baseFont);
        w.w = mw + 30;
        total += w.w + barrierCfg.wordPad;
      }
      const maxW = Math.min(innerWidth - 40, barrierCfg.maxW);
      let scale = 1;
      if(total > maxW) scale = maxW / total;
      scale = Math.max(0.72, scale);

      for(const w of words){
        w.w *= scale;
        w.h *= Math.max(0.90, scale);
      }

      barrier = {
        task,
        words,
        y: barrierCfg.y0,
        vy: barrierCfg.baseVy + (level-1)*16,
        scale,
        totalW: total*scale,
        gapX: null,
        gapW: null,
        wrongRemoved: false,
        // movement (sway + bob)
        phase: rand()*Math.PI*2,
        swayAmp: clamp(22 + level*4, 22, 70),
        swaySpeed: 0.55 + level*0.06,
        bobAmp: clamp(6 + level*0.8, 6, 16),
        bobSpeed: 0.85,
        _ox: 0, _oy: 0
      };

      layoutBarrier(0,0);

      failsThisSentence = 0;
      ui.hint.innerHTML = `Fehlerart: <b>${task.type}</b> ¬∑ Genau <b>1 Wort</b> ist falsch.`;
      updateUI();
      flash("Neuer Satz!", true);
    }

    function layoutBarrier(offsetX=0, offsetY=0){
      if(!barrier) return;
      let x = (innerWidth - barrier.totalW)/2 + barrierCfg.padX*barrier.scale + offsetX;
      for(const w of barrier.words){
        w.x = x;
        w.y = barrier.y + offsetY;
        x += w.w + barrierCfg.wordPad*barrier.scale;
      }
    }

    function computeGap(){
      const w = barrier.words.find(b => b.isWrong);
      if(!w) return;
      barrier.gapX = w.x;
      barrier.gapW = w.w;
      barrier.wrongRemoved = true;
    }

    function updateUI(){
      ui.score.textContent = String(score);
      ui.lives.textContent = String(lives);
      ui.level.textContent = String(level);
      ui.fails.textContent = String(failsThisSentence);

      const pct = Math.round(((solvedCount % 30) / 30) * 100);
      ui.progress.style.width = pct + "%";
    }

    // ==========================================================
    // 4) Visual polish: stars + particles
    // ==========================================================
    function initStars(){
      stars = [];
      const n = Math.round(clamp(innerWidth/9, 90, 180));
      for(let i=0;i<n;i++){
        stars.push({
          x: rand()*innerWidth,
          y: rand()*innerHeight,
          r: rand()*1.4 + 0.3,
          v: rand()*22 + 12,
          a: rand()*0.25 + 0.05
        });
      }
    }
    initStars();
    addEventListener("resize", initStars);

    function spawnParticles(x,y, good=true){
      for(let i=0;i<14;i++){
        particles.push({
          x, y,
          vx: (rand()-0.5)*260,
          vy: (rand()-0.5)*260,
          life: 0.55 + rand()*0.25,
          max: 0.55 + rand()*0.25,
          good
        });
      }
    }

    // ==========================================================
    // 5) Drawing
    // ==========================================================
    function rr(x,y,w,h,r){
      const rad = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rad, y);
      ctx.arcTo(x+w, y, x+w, y+h, rad);
      ctx.arcTo(x+w, y+h, x, y+h, rad);
      ctx.arcTo(x, y+h, x, y, rad);
      ctx.arcTo(x, y, x+w, y, rad);
      ctx.closePath();
    }

    function drawBackground(dt){
      const g = ctx.createLinearGradient(0,0,0,innerHeight);
      g.addColorStop(0, "rgba(7,10,18,1)");
      g.addColorStop(1, "rgba(4,7,12,1)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,innerWidth,innerHeight);

      for(const s of stars){
        s.y += s.v * dt;
        if(s.y > innerHeight + 10){ s.y = -10; s.x = rand()*innerWidth; }
        ctx.fillStyle = `rgba(231,238,252,${s.a})`;
        ctx.fillRect(s.x, s.y, s.r, s.r);
      }

      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "rgba(124,58,237,1)";
      ctx.beginPath(); ctx.ellipse(innerWidth*0.18, innerHeight*0.24, 220, 160, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(102,204,255,1)";
      ctx.beginPath(); ctx.ellipse(innerWidth*0.82, innerHeight*0.18, 250, 180, 0.2, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function drawShip(){
      const x = ship.x - ship.w/2;
      const y = ship.y - ship.h/2;

      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = "rgba(102,204,255,1)";
      ctx.beginPath();
      ctx.ellipse(ship.x, ship.y + 26, 18, 26, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,.45)";
      ctx.shadowBlur = 22;
      ctx.fillStyle = "rgba(255,255,255,.10)";
      rr(x-10, y-10, ship.w+20, ship.h+26, 18);
      ctx.fill();
      ctx.restore();

      const grad = ctx.createLinearGradient(x, y, x+ship.w, y+ship.h);
      grad.addColorStop(0, "rgba(124,58,237,.95)");
      grad.addColorStop(1, "rgba(102,204,255,.85)");
      ctx.fillStyle = grad;
      rr(x, y, ship.w, ship.h, 14);
      ctx.fill();

      ctx.fillStyle = "rgba(231,238,252,.85)";
      rr(ship.x-10, y-24, 20, 26, 11);
      ctx.fill();

      ctx.fillStyle = "rgba(0,0,0,.32)";
      rr(ship.x-22, y+7, 44, 14, 10);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawBullets(){
      for(const b of bullets){
        ctx.save();
        ctx.globalAlpha = b.a;

        ctx.strokeStyle = "rgba(102,204,255,.55)";
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x, b.y + b.len);
        ctx.stroke();

        ctx.strokeStyle = "rgba(224,251,255,.95)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x, b.y + b.len);
        ctx.stroke();

        ctx.restore();
      }
    }

    function drawParticles(dt){
      for(let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.life -= dt;
        const a = Math.max(0, p.life / p.max);
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.92;
        p.vy *= 0.92;

        ctx.save();
        ctx.globalAlpha = 0.65 * a;
        ctx.fillStyle = p.good ? "rgba(154,255,200,1)" : "rgba(255,123,123,1)";
        ctx.fillRect(p.x, p.y, 3, 3);
        ctx.restore();

        if(p.life <= 0) particles.splice(i,1);
      }
    }

    function drawBarrier(){
      if(!barrier) return;

      const plateW = barrier.totalW;
      const plateH = barrierCfg.wordHeight * 1.14 * barrier.scale;
      const plateX = (innerWidth - plateW)/2 + barrier._ox;
      const plateY = barrier.y - plateH/2 + barrier._oy;

      ctx.save();
      ctx.shadowColor = "rgba(102,204,255,.22)";
      ctx.shadowBlur = 28;
      ctx.fillStyle = "rgba(0,0,0,.40)";
      ctx.strokeStyle = "rgba(255,255,255,.14)";
      ctx.lineWidth = 2;
      rr(plateX, plateY, plateW, plateH, 22);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      const fontPx = Math.round(BASE_WORD_FONT * barrier.scale);
      ctx.font = `900 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";

      for(const w of barrier.words){
        if(w.removed) continue;

        ctx.save();
        ctx.shadowColor = "rgba(124,58,237,.22)";
        ctx.shadowBlur = 16;
        ctx.fillStyle = "rgba(0,0,0,.56)";
        ctx.strokeStyle = "rgba(255,255,255,.22)";
        ctx.lineWidth = 3;
        rr(w.x, w.y - w.h/2, w.w, w.h, 16);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "rgba(231,238,252,.98)";
        ctx.fillText(w.text, w.x + w.w/2, w.y);
        ctx.restore();
      }

      if(barrier.wrongRemoved && barrier.gapX != null){
        ctx.save();
        ctx.strokeStyle = "rgba(102,204,255,.45)";
        ctx.setLineDash([10,8]);
        ctx.lineWidth = 3;
        rr(barrier.gapX, barrier.words[0].y - (barrierCfg.wordHeight*barrier.scale)/2, barrier.gapW, barrierCfg.wordHeight*barrier.scale, 16);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
    }

    let hintPulse = { on:false, t:0, x:0, w:0 };
    function drawHintPulse(){
      if(!hintPulse.on || !barrier) return;
      const a = Math.max(0, Math.sin(hintPulse.t * Math.PI));
      const y = barrier.words[0].y - (barrierCfg.wordHeight*barrier.scale)/2;
      const h = barrierCfg.wordHeight*barrier.scale;

      ctx.save();
      ctx.globalAlpha = 0.45 * a;
      ctx.strokeStyle = "rgba(102,204,255,.95)";
      ctx.lineWidth = 10;
      ctx.shadowColor = "rgba(102,204,255,.55)";
      ctx.shadowBlur = 22;
      rr(hintPulse.x, y, hintPulse.w, h, 16);
      ctx.stroke();
      ctx.restore();
    }

    function draw(dt){
      drawBackground(dt);
      drawBarrier();
      drawHintPulse();
      drawBullets();
      drawParticles(dt);
      drawShip();
    }

    // ==========================================================
    // 6) Gameplay
    // ==========================================================
    function shoot(){
      bullets.push({ x: ship.x, y: ship.y - 34, vy: 1380, len: 36, a: 1 });
    }

    function checkBulletHits(){
      if(!barrier) return;

      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];

        const bandTop = barrier.y - 110;
        const bandBot = barrier.y + 110;
        if(b.y < bandTop || b.y > bandBot) continue;

        for(const w of barrier.words){
          if(w.removed) continue;
          const yTop = w.y - w.h/2;
          const yBot = w.y + w.h/2;

          if(b.x >= w.x && b.x <= w.x + w.w && b.y >= yTop && b.y <= yBot){
            bullets.splice(i,1);

            if(w.isWrong){
              w.removed = true;
              computeGap();
              solvedCount += 1;
              score += 22 + Math.min(24, level*3);
              failsThisSentence = 0;
              flash("‚úÖ Falsches Wort entfernt ‚Üí L√úCKE!", true);
              spawnParticles(b.x, b.y, true);
            }else{
              failsThisSentence += 1;
              if(!practice) score = Math.max(0, score - 6);
              flash("‚ùå Falsches Wort!", false);
              spawnParticles(b.x, b.y, false);
            }
            updateUI();
            return;
          }
        }
      }
    }

    function barrierReachedBottom(){
      const threshold = ship.y - 34;
      return barrier && barrier.y >= threshold;
    }

    function shipPassesThroughGap(){
      if(!barrier || !barrier.wrongRemoved || barrier.gapX == null) return false;
      const sx1 = ship.x - ship.w*0.34;
      const sx2 = ship.x + ship.w*0.34;
      const gx1 = barrier.gapX;
      const gx2 = barrier.gapX + barrier.gapW;
      return (sx1 >= gx1 + 6) && (sx2 <= gx2 - 6);
    }

    function onCrash(){
      lives -= 1;
      flash("üí• Crash! Nicht in der L√ºcke.", false);
      spawnParticles(ship.x, ship.y, false);
      updateUI();

      if(lives <= 0){
        gameOver();
      }else{
        spawnBarrier();
        ship.x = innerWidth/2;
        ship.y = innerHeight - 92;
      }
    }

    function onSuccessPass(){
      score += 32 + Math.min(40, level*4);
      flash("üöÄ Durch die L√ºcke! +Bonus", true);
      spawnParticles(ship.x, ship.y-40, true);

      level += 1;
      updateUI();
      spawnBarrier();
    }

    function maybeHint(){
      if(failsThisSentence < 2){
        flash("Hint erst nach 2 Fehlversuchen.", false);
        return;
      }
      if(!barrier) return;
      const wrong = barrier.words.find(w => w.isWrong && !w.removed);
      if(!wrong) return;

      hintPulse.on = true;
      hintPulse.t = 0;
      hintPulse.x = wrong.x;
      hintPulse.w = wrong.w;

      flash("üîé Hint!", true);
      failsThisSentence = Math.max(0, failsThisSentence - 2);
      updateUI();
    }

    // ==========================================================
    // 7) Loop
    // ==========================================================
    let running = false;
    let last = performance.now();

    function tick(now){
      if(!running) return;
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;

      // ship control
      let ax = 0;
      if(keys.left) ax -= 1;
      if(keys.right) ax += 1;
      ship.vx = ax * ship.speed;
      ship.x += ship.vx * dt;
      ship.x = clamp(ship.x, ship.w/2 + 12, innerWidth - ship.w/2 - 12);

      if(keys.up) ship.y -= ship.boost * dt;
      else ship.y += 270 * dt;
      ship.y = clamp(ship.y, innerHeight - 155, innerHeight - 80);

      // bullets
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.y -= b.vy * dt;
        b.a = Math.max(0, b.a - dt*1.15);
        if(b.y < -80 || b.a <= 0) bullets.splice(i,1);
      }

      // moving barrier
      if(barrier){
        barrier.y += barrier.vy * dt;

        const t = now/1000;
        const ox = Math.sin(t*barrier.swaySpeed + barrier.phase) * barrier.swayAmp;
        const oy = Math.sin(t*barrier.bobSpeed + barrier.phase*1.7) * barrier.bobAmp;

        barrier._ox = ox;
        barrier._oy = oy;
        layoutBarrier(ox, oy);

        if(barrierReachedBottom()){
          if(shipPassesThroughGap()) onSuccessPass();
          else onCrash();
        }
      }

      // hint pulse
      if(hintPulse.on){
        hintPulse.t += dt / 0.55;
        if(hintPulse.t >= 1) hintPulse.on = false;
      }

      checkBulletHits();
      draw(dt);
      requestAnimationFrame(tick);
    }

    function startGame(isPractice){
      practice = isPractice;
      score = 0;
      lives = 3;
      level = 1;
      failsThisSentence = 0;
      solvedCount = 0;
      bullets = [];
      particles = [];
      ship.x = innerWidth/2;
      ship.y = innerHeight - 92;

      initDeck();

      ui.overlay.style.display = "none";
      running = true;
      last = performance.now();
      spawnBarrier();
      flash(practice ? "üß™ √úbungsmodus" : "Los geht's!", true);
      requestAnimationFrame(tick);
    }

    function gameOver(){
      running = false;
      ui.overlay.style.display = "grid";
      ui.overlay.querySelector("h2").textContent = "Game Over üí•";
      ui.overlay.querySelector("p").innerHTML =
        `Score: <b>${score}</b> ¬∑ Level: <b>${level}</b><br>
         Deck verbraucht: <b>${deckIndex}</b> / ${deckOrder.length}`;
    }

    function reset(){
      running = false;
      ui.overlay.style.display = "grid";
      ui.overlay.querySelector("h2").textContent = "Bereit? üòÑ";
      ui.overlay.querySelector("p").innerHTML =
        `Dieses Spiel nutzt ein <b>Deck</b> aus <b>${DECK_SIZE}</b> S√§tzen (keine Wiederholung).<br>
         Schie√üe das <b>falsche Wort</b> heraus ‚Üí L√ºcke ‚Üí durchfliegen.`;
      flash("Reset.", true);
      updateUI();
      draw(0.016);
    }

    // ==========================================================
    // 8) Input + Buttons
    // ==========================================================
    addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      if(k==="arrowleft" || k==="a") keys.left = true;
      if(k==="arrowright" || k==="d") keys.right = true;
      if(k==="arrowup" || k==="w") keys.up = true;

      if(k===" "){
        e.preventDefault();
        if(!running) return;
        if(!keys.space){
          shoot();
          keys.space = true;
        }
      }
      if(k==="h"){
        if(running) maybeHint();
      }
    });

    addEventListener("keyup", (e)=>{
      const k = e.key.toLowerCase();
      if(k==="arrowleft" || k==="a") keys.left = false;
      if(k==="arrowright" || k==="d") keys.right = false;
      if(k==="arrowup" || k==="w") keys.up = false;
      if(k===" ") keys.space = false;
    });

    ui.resetBtn.addEventListener("click", reset);
    ui.startBtn.addEventListener("click", ()=>startGame(false));
    ui.practiceBtn.addEventListener("click", ()=>startGame(true));

    // init
    reset();
  </script>
</body>
</html>